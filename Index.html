<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sumário de Requisitos Arquiteturais e Modelagem</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
    }
    h1 {
      text-align: center;
      color: #333;
    }
    .sumario {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #f9f9f9;
    }
    .sumario ul {
      /*list-style-type: none;*/
      padding: 10;
    }
    .sumario li {
      margin: 10px 0;
    }
    .sumario a {
      text-decoration: none;
      color: #007BFF;
    }
    .sumario a:hover {
      text-decoration: underline;
    }
    .capitulo {
      margin-top: 40px;
      border-top: 2px solid #ccc;
      padding-top: 20px;
 
      text-align: justify;
    }
  </style>
</head>
 
<body>
  <div class="sumario">
    <h1>Arquitetura de software</h1>
    <h2>Sumário</h2>
    <ul>
      <li><a href="#modulo-1">Módulo 1: Fundamentos de Arquitetura de Software</a></li>
      <ul>
        <li><a href="#modulo-1-capitulo-0">Capítulo 0: Visão Geral do Módulo</a></li>
        <li><a href="#modulo-1-capitulo-1">Capítulo 1: Introdução à Arquitetura de Software</a></li>
        <li><a href="#modulo-1-capitulo-2">Capítulo 2: O Profissional de Arquitetura de Software</a></li>
        <li><a href="#modulo-1-capitulo-3">Capítulo 3: Arquitetura de Software Moderna</a></li>
        <li><a href="#modulo-1-capitulo-4">Capítulo 4: Estilos Arquiteturais Monolíticos</a></li>
        <li><a href="#modulo-1-capitulo-5">Capítulo 5: Estilos Arquiteturais Distribuídos</a></li>
        <li><a href="#modulo-1-exercicios-fixacao">Exercícios de Fixação</a></li>
        <li><a href="#modulo-1-capitulo-7">Capítulo 7: Conduzindo o Processo Decisório</a></li>
        <li><a href="#modulo-1-capitulo-8">Capítulo 8: Gerenciando Riscos</a></li>
        <li><a href="#modulo-1-capitulo-9">Capítulo 9: Frameworks Arquiteturais</a></li>
        <li><a href="#modulo-1-capitulo-10">Capítulo 10: Engenharia e Arquitetura de Software</a></li>
        <li><a href="#modulo-1-capitulo-11">Capítulo 11: DEVOPS</a></li>
      </ul>
  

      <li><a href="#modulo-2">Módulo 2: Requisitos Arquiteturais e Modelagem Arquitetural</a></li>
      <ul>
        <li><a href="#modulo-2-capitulo-0">Capítulo 0: Introdução à Engenharia de Requisitos</a></li>
        <ul>
          <li><a href="#modulo-2-capitulo-0-1">0.1. Apresentação</a></li>
          <li><a href="#modulo-2-capitulo-0-2">0.2. Trajetória</a></li>
          <li><a href="#modulo-2-capitulo-0-3">0.3. Redes Sociais</a></li>
          <li><a href="#modulo-2-capitulo-0-4">0.4. Apresentação do Módulo</a></li>
        </ul>
        
        <li><a href="#modulo-2-capitulo-1">Capítulo 1: Fundamentos de Engenharia de Requisitos</a></li>
        <ul>
          <li><a href="#modulo-2-capitulo-1-1">1.1. Requisitos Arquiteturais e Funcionais</a></li>
          <li><a href="#modulo-2-capitulo-1-2">1.2. Arquitetura Mínima Viável</a></li>
          <li><a href="#modulo-2-capitulo-1-3">1.3. Padrões Arquiteturais</a></li>
          <li><a href="#modulo-2-capitulo-1-4">1.4. Desenvolvimento Ágil</a></li>
          <li><a href="#modulo-2-capitulo-1-5">1.5. Sistemas Legados</a></li>
          <li><a href="#modulo-2-capitulo-1-6">1.6. Responsabilidades de Times</a></li>
        </ul>

        <li><a href="#modulo-2-capitulo-2">Capítulo 2: Elicitação de Requisitos Arquiteturais</a></li>
        <ul>
          <li><a href="#modulo-2-capitulo-2-1">2.1. O que é Engenharia de Requisitos</a></li>
          <li><a href="#modulo-2-capitulo-2-2">2.2. Gestão de Produtos</a></li>
          <li><a href="#modulo-2-capitulo-2-3">2.3. Tipos de Conhecimento</a></li>
          <li><a href="#modulo-2-capitulo-2-4">2.4. Desafios da Elicitação de Requisitos</a></li>
        </ul>

        <li><a href="#modulo-2-capitulo-3">Capítulo 3: Uso do Trello para Gestão de Requisitos – Parte I</a></li>
        <li><a href="#modulo-2-capitulo-4">Capítulo 4: Uso do Trello para Gestão de Requisitos – Parte II</a></li>

        <li><a href="#modulo-2-capitulo-5">Capítulo 5: Primeira Aula Interativa – Demonstração de Projeto de Levantamento de Requisitos Arquiteturais</a></li>

        <li><a href="#modulo-2-capitulo-6">Capítulo 6: Análise de Requisitos Arquiteturais</a></li>
        <ul>
          <li><a href="#modulo-2-capitulo-6-1">6.1. Priorização de Requisitos</a></li>
          <li><a href="#modulo-2-capitulo-6-2">6.2. Histórias de Usuários</a></li>
          <li><a href="#modulo-2-capitulo-6-3">6.3. Débito Técnico</a></li>
        </ul>

        <li><a href="#modulo-2-capitulo-7">Capítulo 7: Qualidade e Requisitos Arquiteturais</a></li>
        <ul>
          <li><a href="#modulo-2-capitulo-7-1">7.1. Acessibilidade</a></li>
          <li><a href="#modulo-2-capitulo-7-2">7.2. Desempenho</a></li>
          <li><a href="#modulo-2-capitulo-7-3">7.3. Usabilidade</a></li>
        </ul>

        <li><a href="#modulo-2-capitulo-8">Capítulo 8: Especificação e Validação de Requisitos Arquiteturais (E-book)</a></li>

        <li><a href="#modulo-2-capitulo-9">Capítulo 9: Introdução ao Azure DevOps</a></li>

        <li><a href="#modulo-2-capitulo-10">Capítulo 10: Segunda Aula Interativa – Projeto no Azure DevOps</a></li>

        <li><a href="#modulo-2-material-complementar">Material Complementar</a></li>
        <ul>
          <li><a href="#modulo-2-material-ebook">Especificação e Validação de Requisitos Arquiteturais (E-book)</a></li>
          <li><a href="#modulo-2-material-uml">Unified Modeling Language (UML)</a></li>
          <ul>
            <li><a href="#modulo-2-material-uml-comportamental">Diagramas Comportamentais</a></li>
            <li><a href="#modulo-2-material-uml-estrutural">Diagramas Estruturais</a></li>
            <li><a href="#modulo-2-material-uml-4mais1">Modelo Arquitetural 4+1</a></li>
          </ul>
          <li><a href="#modulo-2-material-ferramentas">Ferramentas de Gerência de Projetos e Desenho Arquitetural</a></li>
          <ul>
            <li><a href="#modulo-2-material-draw-1">Draw I</a></li>
            <li><a href="#modulo-2-material-draw-2">Draw II</a></li>
          </ul>
        </ul>
      </ul>


      <ul>
        <li><a href="#modulo-3">Módulo 3: Design Patterns, Estilos e Padrões Arquiteturais</a></li>
        <ul>
          <li><a href="#modulo-3-capitulo-0">Capítulo 0 - Visão Geral do Módulo</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-0-1">0.1. Apresentação do Professor</a></li>
            <li><a href="#modulo-3-capitulo-0-2">0.2. Apresentação do Módulo</a></li>
          </ul>
          
          <li><a href="#modulo-3-capitulo-1">Capítulo 1 – Arquitetura de Software e Qualidade de Código</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-1-1">1.1. Introdução</a></li>
            <li><a href="#modulo-3-capitulo-1-2">1.2. Code Smells</a></li>
            <ul>
              <li><a href="#modulo-3-capitulo-1-2-1">1.2.1. Code Smells – Bloaters</a></li>
              <li><a href="#modulo-3-capitulo-1-2-2">1.2.2. Code Smells – Couplers</a></li>
            </ul>
            <li><a href="#modulo-3-capitulo-1-3">1.3. Análise Estática de Código</a></li>
          </ul>
          
          <li><a href="#modulo-3-capitulo-2">Capítulo 2 – Catálogos de Padrões</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-2-1">2.1. Introdução aos Catálogos de Padrões</a></li>
            <li><a href="#modulo-3-capitulo-2-3">2.3. Patterns of Enterprise Application Architecture</a></li>
            <li><a href="#modulo-3-capitulo-2-3">2.3. Design Patterns – GoF</a></li>
            <li><a href="#modulo-3-capitulo-2-4">2.4. Anti Patterns</a></li>
          </ul>
          
          <li><a href="#modulo-3-capitulo-3">Capítulo 3 – GoF – Padrões de Criação</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-3-1">3.1. Singleton</a></li>
            <li><a href="#modulo-3-capitulo-3-2">3.2. Builder</a></li>
            <li><a href="#modulo-3-capitulo-3-3">3.3. Factory Method</a></li>
            <li><a href="#modulo-3-capitulo-3-4">3.4. Abstract Factory</a></li>
          </ul>
          
          <li><a href="#modulo-3-capitulo-4">Capítulo 4 – GoF – Padrões Estruturais</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-4-1">4.1. Adapter</a></li>
            <li><a href="#modulo-3-capitulo-4-2">4.2. Facade</a></li>
            <li><a href="#modulo-3-capitulo-4-3">4.3. Flyweight</a></li>
            <li><a href="#modulo-3-capitulo-4-4">4.4. Composite</a></li>
            <li><a href="#modulo-3-capitulo-4-5">4.5. Decorator</a></li>
          </ul>
          
          <li><a href="#modulo-3-capitulo-5">Capítulo 5 – GoF – Padrões Comportamentais</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-5-1">5.1. Command</a></li>
            <li><a href="#modulo-3-capitulo-5-2">5.2. Template Method</a></li>
            <li><a href="#modulo-3-capitulo-5-3">5.3. State</a></li>
            <li><a href="#modulo-3-capitulo-5-4">5.4. Strategy</a></li>
          </ul>
          
          <li><a href="#modulo-3-capitulo-6">Atividade de Fixação</a></li>
          
          <li><a href="#modulo-3-capitulo-7">Primeira Aula Interativa - Capítulo 6 – Princípios SOLID</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-7-1">6.1. Simple Responsibility Principle</a></li>
            <li><a href="#modulo-3-capitulo-7-2">6.2. Open Closed Principle</a></li>
            <li><a href="#modulo-3-capitulo-7-3">6.3. Liskov Substitution Principle</a></li>
            <li><a href="#modulo-3-capitulo-7-4">6.4. Interface Segregation Principle</a></li>
            <li><a href="#modulo-3-capitulo-7-5">6.5. Dependency Inversion Principle</a></li>
          </ul>
          
          <li><a href="#modulo-3-capitulo-8">Capítulo 7 – Estilos Arquiteturais</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-8-1">7.1. Estilos Arquiteturais</a></li>
            <li><a href="#modulo-3-capitulo-8-2">7.2. Estilos Arquiteturais – Structure</a></li>
            <li><a href="#modulo-3-capitulo-8-3">7.3. Estilos Arquiteturais – Message Styles</a></li>
            <li><a href="#modulo-3-capitulo-8-4">7.4. Estilos Arquiteturais – Adaptive Systems</a></li>
            <li><a href="#modulo-3-capitulo-8-5">7.5. Estilos Arquiteturais – Distributed Systems</a></li>
            <li><a href="#modulo-3-capitulo-8-6">7.6. Estilos Arquiteturais – Deployment</a></li>
          </ul>
          
          <li><a href="#modulo-3-capitulo-9">Capítulo 8 – Padrões Arquiteturais</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-9-1">8.1. Padrões Arquiteturais</a></li>
            <li><a href="#modulo-3-capitulo-9-2">8.2. Model View Controller (MVC)</a></li>
            <li><a href="#modulo-3-capitulo-9-3">8.3. Model View Presenter (MVP)</a></li>
            <li><a href="#modulo-3-capitulo-9-4">8.4. Model View ViewModel (MVVM)</a></li>
          </ul>
          
          <li><a href="#modulo-3-capitulo-10">Capítulo 9 – Arquiteturas de Camadas</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-10-1">9.1. Hexagonal Architecture</a></li>
            <li><a href="#modulo-3-capitulo-10-2">9.2. Onion Architecture</a></li>
            <li><a href="#modulo-3-capitulo-10-3">9.3. Clean Architecture</a></li>
          </ul>
          
          <li><a href="#modulo-3-capitulo-11">Capítulo 10 – Padrões para Sistemas Distribuídos</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-11-1">10.1. Padrões para Sistemas Distribuídos</a></li>
            <li><a href="#modulo-3-capitulo-11-2">10.2. Enterprise Application Patterns – Point to Point Channel</a></li>
            <li><a href="#modulo-3-capitulo-11-3">10.3. Enterprise Application Patterns – Publish Subscribe Channel</a></li>
            <li><a href="#modulo-3-capitulo-11-4">10.4. Enterprise Application Patterns – Concurrency</a></li>
          </ul>
          
          <li><a href="#modulo-3-capitulo-12">Capítulo 11 – Arquiteturas de Sistemas Distribuídos</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-12-1">11.1. Enterprise Application Integration (EAI)</a></li>
            <li><a href="#modulo-3-capitulo-12-2">11.2. Service Oriented Architecture (SOA)</a></li>
            <li><a href="#modulo-3-capitulo-12-3">11.3. Enterprise Service BUS (ESB)</a></li>
          </ul>
          
          <li><a href="#modulo-3-capitulo-13">Atividade Modular</a></li>
          
          <li><a href="#modulo-3-capitulo-14">Segunda aula interativa - Capítulo 12 – Aplicação de Padrões Arquiteturais</a></li>
          <ul>
            <li><a href="#modulo-3-capitulo-14-1">12.1. Aplicação de Padrões Arquiteturais – MVC</a></li>
            <li><a href="#modulo-3-capitulo-14-2">12.2. Aplicação de Padrões Arquiteturais – MVP</a></li>
          </ul>
        </ul>
      </ul>

       
    </ul>
  </div>

  <div class="content">

    <h1>Arquitetura de software</h1>

    <!-- Conteúdo do módulo 1 -->
    <div id="modulo-1">
        <h2>Módulo 1: Fundamentos de Arquitetura de Software</h2>
        <div id="modulo-1-capitulo-0" class="capitulo">
            <h3>Capítulo 0: Visão Geral do Módulo</h3>
            <ul>
              <li>0.1. Apresentação do Professor</li>
              <li>0.2. Apresentação do Módulo</li>
            </ul>
          </div>
          
          <div id="modulo-1-capitulo-1" class="capitulo">
            <h2>Capítulo 1: Introdução à Arquitetura de Software</h2>
            <ul>
              <li><strong>1.1. Introdução à Arquitetura</strong></li>
                <P> O que é arquitetura de software? É uma modelagem do produto deve ser fito no final, o estudo do fluxo dos dados, especificação das atribuições dos módulos, composição de alto nível, um retrato do que deve ser construído, somente é detalhado o que é extremamente importante, não precisa adiantar uma decisão que não será feito hoje, pelo motivo de mudar a arquitetura, conclusão design do sistema, difícil de mudar e apoiada em padrões, baseado em padrões;</P>
                <p><strong>Principais componentes da arquitetura:</strong></p>
                <ul>
                  <li>Componentes do sistema;</li>
                  <li>Camadas;</li>
                  <li>Comunicação;</li>
                  <li>Tecnologias;</li>
                  <li>Práticas de desenvolvimento;</li>
                </ul>
                <p><strong>Decisões arquiteturais:</strong> </p>
                  <ul>
                    <li>Decisões estratégicas;</li>
                    <li>Monólito</li>
                    <li>Micro serviços</li>
                    <li>Decisões de longo prazo; </li>
                    <li>Mostram quais características estarão presentes ou ausentes na solução</li>
                    <li>Impactada pela disponibilidade de recursos;</li>
                  </ul>
              </p>
              <p>A arquitetura de software é fundamental para o desenvolvimento de sistemas robustos e escaláveis, neste capítulo exploramos três níveis principais.   A arquitetura de software que foca na estrutura interna dos sistemas e na organização dos componentes, para garantir desempenho e manutenibilidade. </p>
              <p>A arquitetura de soluções que trata da integração de múltiplos sistemas e aplicações dentro de uma organização para resolver problemas específicos.  A arquitetura corporativa que alinha a tecnologia, aos objetivos estratégicos de longo prazo da empresa. </p>
              <p>O arquiteto de softwares deve ter uma combinação de hard skills, como design patterns e clean cold e soft skills, como comunicação e liderança. Além disso, atua como um elo de comunicação entre diferentes equipes garantindo que as soluções atendam tanto as necessidades técnicas quanto empresariais.</p>

              <li><strong>1.2. Princípios Gerais de uma boa Arquitetura </strong></li>
                <p><strong> Princípios fundamentais </strong></p>
                <ul>
                  <li>Modularidade:	É utilização de separação por módulos a divisão das suas responsabilidades;</li>
                  <li>Separação de preocupações;</li>
                  <li>Interfaces bem definidas: Validação da necessidade de um modulo de pagamento precisa ter comunicação com o módulo de estoque, é saber a necessidade dos processos;</li>
                  <li>Escalabilidade; </li>
                  <li>Flexibilidade e adaptação;  </li>
                  <li>Uso de padrões; </li>
                </ul>

                <p><strong> SOLID   </strong></p>
                <ul>
                  <li>Responsabilidade única: Garantir que um elemento faça o algo específico, regra com método especifico da classe; </li>
                  <li>Open/Closed: Derivação das classes, quando posso criar novos métodos ou alterar; </li>
                  <li>Liskov:  </li>
                  <li>Segregação de interface: </li>
                  <li>Inversão de dependência: </li>
                </ul>
          
                <p><strong> Outros   </strong></p>
                <ul>
                  <li>Princípio da menor surpresa; </li>
                  <li>Princípio do menos estorço (Lei de Zipf) </li>
                  <li>Princípio do custo de oportunidade; </li>
                  <li>Princípio do custo do atraso; </li>
                </ul>
                <p></p>

              <li><strong>1.3. Trade-Offs Arquiteturais</strong></li>
                <p> Trade-off refere-se ao ato de equilibrar ou fazer concessões entre dois ou mais atributos de qualidade ou características de um sistema, onde a melhoria de um atributo geralmente leva à degradação de outro. Isso ocorre porque os recursos (como tempo, custo, desempenho, etc) são limitados e as decisões arquiteturais impactam múltiplos aspectos do sistema. </p>
                <p>Exemplo: Segurança dos dados manter em cache ou em criptografia;</p>
                <p><strong> Atributos de qualidade de software   </strong></p>
                  <ul>
                    <li> Custo</li>
                    <li>Tempo </li>
                    <li>Escopo </li>
                  </ul>
                
                  <p><strong>  Skills equipe  </strong></p>
                  <ul>
                    <li> Capacitação da equipe; </li>
                  </ul>
                  <p><strong> Objetivos de négocio   </strong></p>
                  <ul>
                    <li> </li>
                  </ul>
 
                  <p><strong> Processo de engenharia   </strong></p>
                  <ul>
                    <li> </li>
                  </ul>
 
                  <p><strong> Estilo arquitetural, validação da necessidade de qual modelo adotar   </strong></p>
                  <ul>
                    <li>Monólito </li>
                    <li>Micro serviço </li>
                    <li>NoSql </li>
                    <li>SQL </li>
                  </ul>
    
                  <p><strong> A arquitetura de software é crucial para desenvolver sistemas robustos e escaláveis, dividindo-se em três níveis principais:   </strong></p>
                  <ul>
                    <li> Arquitetura de Software: Focada na estrutura interna, organização dos componentes, desempenho e manutenibilidade.</li>
                    <li> Arquitetura de Soluções: Responsável pela integração de múltiplos sistemas e aplicações para resolver problemas específicos. </li>
                    <li> Arquitetura Corporativa: Alinha tecnologia aos objetivos estratégicos da empresa, garantindo suporte às metas de longo prazo. </li>
                    <li> O arquiteto de software combina hard skills (como design patterns e Clean Code) e soft skills (como liderança e comunicação) e atua como elo entre equipes técnicas e de negócio.</li>
                    <li> </li>
                  </ul>
            </ul>
          </div>
          
          <div id="modulo-1-capitulo-2" class="capitulo">
            <h2>Capítulo 2: O Profissional de Arquitetura de Software</h2>
            <P>Gerindo o processo de arquitetura, neste capitulo o foco está na gestão do processo de arquitetura. Um arquiteto precisa conhecer ferramentas como a matriz de decisão que ajuda a escolher em diferentes soluções e a análise de premissas e restrições, que garante que a arquitetura esteja de acordo com os limites do projeto. Além disso, frameworks como Hackman e o togas fornecem estruturas para desenvolver arquiteturas corporativas que atentam às necessidades de negócios. </P>
            
            <ul>
                <li><strong>2.1. Arquitetura de Software x Soluções x Corporativa </strong></li>
                  <p>Nesta seção, exploraremos três pilares essenciais da engenharia de sistemas: arquitetura de software, arquitetura de soluções e arquitetura corporativa. A arquitetura de soluções expande esse conceito ao nível da integração de múltiplos sistemas, abordando como diferentes aplicações e serviços se conectam para resolver problemas específicos de negócios. Por fim, a arquitetura corporativa fornece uma visão holística e estratégica, alinhando a tecnologia com os objetivos empresariais e garantindo que todas as solu ções tecnológicas suportem a visão e as metas de longo prazo da organização. Juntos, esses níveis de arquitetu ra formam uma base sólida para a criação de sistemas eficientes, adaptáveis e alinhados com as necessidades dinâmicas do mercado. </p>
                  
                  <p><strong>  Arquitetura de Software  </strong></p>
                  <p>A arquitetura de software se concentra na estrutura in terna e na organização dos componentes de um siste ma, garantindo que ele seja robusto, escalável e manu tenível. Esta área é a responsável pela organização da solução em um nível mais próximo do código e dos de senvolvedores. Algumas decisões e atividades que são responsabilidade deste profissional, por exemplo:</p>
                  <ul>
                    <li>Participação de revisões de código </li>
                    <li>Direcionar a implantação de paradigmas de de senvolvimento (ex: TDD, BDD...) </li>
                    <li>Desenvolver modelos e design de componen tes (diagrama de classes, componentes...) de arquiteturas para soluções específicas. </li>
                    <li>Apoiar o processo decisório da equipe de de senvolvimento na construção de soluções es pecíficas. Os profissionais que atuam como arquiteto de softwares normalmente têm grande bagagem técnica e experiên cia profissional no contexto do desenvolvimento do sis tema, relativamente habitual termos desenvolvedores experientes que se tornaram arquitetos. Esses profissionais eventualmente atuam como respon sáveis técnicos ou tech lead, apoiando diretamente a equipe de desenvolvimento em dúvidas relacionadas à arquitetura emergente ao longo do projeto de construção da solução. </li>
                  </ul>
 
                  <p><strong> Arquitetura de Soluções   </strong></p>
                  <p> Um arquiteto de soluções se concentra na integração de múltiplos sistemas e aplicações dentro de uma organização. Isso inclui definir como diferentes sistemas (por exemplo, ERP, CRM, e-commerce) se comunicam e trabalham juntos, utilizando middleware, APIs e outras tecnologias de integração para garantir que todas as partes funcionem de maneira coesa e eficiente. </p>
        
                  <p><strong>Arquitetura Corporativa </strong> </p>
                  <p> Um arquiteto corporativo é responsável por alinhar as estratégias de TI com os objetivos de negócios da organização. Isso envolve a criação de roadmaps tecnológicos, definição de políticas e padrões de arquitetura, e a garantia de que todas as iniciativas de TI suportem a visão e os objetivos de longo prazo da empresa, promovendo a agilidade e a inovação dentro da organização. Esse profissional normalmente tem uma atuação mais estratégica/gerencial e menos técnica</p>

                <li><strong>2.2. Soft e Hard Skills</strong></li>
                  <p>Um arquiteto (a) de software deve ter habilidades (skills) diversas. Durante muito tempo valorizou-se apenas as skills técnicas relacionadas à área de arqui tetura de software, tais como modelagem. Contudo, cada vez mais o mercado demanda de um profissional que também tenha soft skills que vão permitir a este profissional ter habilidades comportamentais para li dar, influenciar, persuadir e conquistar o apoio dos mais diversos públicos relacionados a sua atividade.   </strong></p>
                  <ul>
                    <li>Programação Orientada a Objetos.</li>
                    <li>SOLID </li>
                    <li>Design Patterns </li>
                    <li>DDD, BDD, TDD </li>
                    <li>Clean Code </li>
                    <li> </li>
                  </ul>
                  <p><strong>  Soft Skills  </strong></p>
                  <p> Hard Skills São as habilidades técnicas adquiridas ao longo do tempo, sejam por processos educacionais, leitura de livros e artigos, estudo de novas tecnologias, experiên cia prática... Estas atividades normalmente podem ser medidas e comprovadas (ex: experiência profissional comprovada, certificados, diplomas...). São as habilidades relacionadas aos aspectos compor tamentais, que devem ser desenvolvidas ao longo do tempo e que normalmente não são comprovadas de forma quantitativa ou através de certificados, o que não quer dizer que não devam ser largamente estuda das. Dentre as principais soft skills esperadas de um arquiteto podemos citar: </p>
           
                  <ul>
                    <li>Inovação </li>
                    <li>Comunicação </li>
                    <li>Capacidade de Persuasão </li>
                    <li>Capacidade de Influência </li>
                    <li>Aprendizado contínuo </li>
                    <li>Liderança </li>
                  </ul>
                  <p></p>



                <li><strong>2.3. Papel do Arquiteto</strong></li>
                <p> Nesta seção iremos estudar sobre diversas atividades e funções que devem ser desempenhadas por um arqui teto de software no dia a dia profissional. O que seria o Papel do Arquiteto? Um arquiteto de software é um profissional essencial no desenvolvimento de sistemas complexos, atuando como o responsável por definir a estrutura e os padrões de uma aplicação. Suas atividades incluem a criação de modelos de arquitetura, que descrevem a estrutura ge ral do sistema e detalham como seus componentes in teragem. Isso envolve escolher tecnologias adequadas, determinar a configuração de servidores e estabelecer padrões de codificação. Além disso, o arquiteto de sof tware deve garantir que a solução seja escalável, sus tentável e de fácil manutenção, considerando aspectos como desempenho, segurança e integração com outros sistemas. Outra função crucial do arquiteto de software é servir como um elo de comunicação entre diferentes equipes de desenvolvimento. Ele trabalha estreitamente com desenvolvedores, gerentes de projeto, analistas de ne gócios e outras partes interessadas para garantir que os requisitos técnicos e funcionais sejam compreendi dos e implementados corretamente. Isso pode envol ver a elaboração de documentação técnica detalhada, a realização de reuniões e workshops para alinhar expec tativas e resolver conflitos, além de orientar e revisar o trabalho das equipes de desenvolvimento para assegu rar a conformidade com os padrões estabelecidos. Além de suas responsabilidades técnicas e de comu nicação, o arquiteto de software também desempenha um papel estratégico dentro da organização. Ele contri bui para a visão de longo prazo da empresa, ajudando a definir a direção tecnológica e garantindo que as so luções arquitetônicas suportem os objetivos de negó cios. Isso inclui a avaliação e a adoção de novas tecno logias e tendências, a realização de análises de risco e a garantia de que a arquitetura proposta possa evoluir conforme as necessidades do mercado e da organiza ção mudem. Assim, o arquiteto de software não só ga rante a robustez e a eficiência dos sistemas atuais, mas também prepara a empresa para desafios futuros </p>
                
                <li><strong>2.4. A arquitetura dentro das grandes organizações</strong></li>
                  <p> As principais atividades de um arquiteto de software abrangem uma ampla gama de responsabilidades téc nicas e de gestão. Essas atividades podem ser agrupa das em diversas categorias, citando algumas delas: </p>
                    
                  <p><strong> 1. Definição da Arquitetura do Sistema:   </strong></p>
                  <ul>
                    <li>Documentação Técnica: Criar e manter documen tação detalhada sobre a arquitetura do sistema, in cluindo diagramas, especificações e manuais de re ferência.</li>
                    <li>Orientação e Mentoria: Fornecer orientação técnica e mentoria para os membros da equipe de desenvol vimento, ajudando a resolver problemas complexos e garantindo a adesão aos padrões arquitetônicos.  </li>
                  </ul>

                  <p><strong> 2. Coordenação e Comunicação:  </strong></p>
                  <ul>
                    <li>Análise e Avaliação de Riscos: Identificar potenciais riscos técnicos e de projeto, propondo soluções para mitigá-los e garantir a robustez do sistema.</li>
                    <li>Adaptação e Evolução da Arquitetura: Monitorar novas tendências tecnológicas e incorporar inova ções relevantes à arquitetura existente para manter a competitividade e a eficiência do sistema.  </li>
                    <li> Adaptação e Evolução da Arquitetura: Monitorar novas tendências tecnológicas e incorporar inova ções relevantes à arquitetura existente para manter a competitividade e a eficiência do sistema.  </li>
                    <li>Revisão e Otimização do Desempenho: Realizar re visões periódicas do desempenho do sistema, identi f icando áreas para otimização e melhorias contínuas.  </li>
                  </ul>    
                  
                  <p><strong> 3. Avaliação e Melhoria Contínua:   </strong></p>
                  <ul>
                    <li>Criação de Modelos Arquitetônicos: Desenvolver diagramas e modelos que representem a estrutura do sistema, detalhando como os componentes interagem entre si. </li>
                    <li>Escolha de Tecnologias e Ferramentas: Selecionar as tecnologias e ferramentas adequadas para a implementação do sistema, considerando aspectos como escalabilidade, desempenho e manutenção. </li>
                    <li>Definição de Padrões e Práticas: Estabelecer padrões de codificação, práticas de desenvolvimento e diretrizes que a equipe deve seguir para garantir a consistência e qualidade do software. </li>
                  </ul>
  
                  <p><strong>  4. Análise de trade-off e visibilidade:  </strong></p>
                  <ul>
                    <li>Colaboração com as Partes Interessadas: Trabalhar com desenvolvedores, gerentes de projeto, analistas de negócios e outras partes interessadas para entender os requisitos do projeto e garantir que a ar quitetura atenda às necessidades do negócio. </li>
                    <li>Análise de trade-off: Ato de escolher alguma coisa em detrimento de outra e vai consistir em uma análise de pontos positivos e negativos de cada uma das escolhas que faremos. Isto significa ba sicamente que escolhendo uma opção estaremos carregando os pontos negativos e positivos dela e estaremos perdendo os pontos positivos e negati vos da outra opção. Na engenharia de software existe um método que ajuda nesse processo de decisão, o ATAM (Architecture Tradeo f f Analysis Method). Seu objetivo é ajudar a escolher uma arquitetura adequada para um sistema de software, des cobrindo compensações e pontos de sensibilidade. </li>
                    <li>Apresentar ATAM – Apresentar o conceito de ATAM aos stakeholders e esclarecer dúvidas sobre o processo.  </li>
                    <ul>
                      <li>Representantes da área de negócio – todos no processo apresentam e avaliam os motivadores de negócios para o sistema em questão. </li>
                      <li>Apresente a arquitetura - o arquiteto apresenta a arquitetura de alto nível para a equipe, com um ‘nível de detalhe apropriado’  </li>
                      <li>Identifique as abordagens arquitetônicas – dife rentes abordagens arquitetônicas do sistema são apresentadas pela equipe e discutidas. </li>
                      <li>Gerar árvore de utilitários de atributos de qua lidade - definir o negócio principal e os requisitos técnicos do sistema e mapeá-los para uma pro priedade arquitetônica apropriada. Apresente um cenário para este determinado requisito. • Análise das abordagens arquitetônicas – anali se cada cenário, classificando-os por prioridade. A arquitetura é então avaliada em relação a cada cenário.  </li>
                      <li>Faça um brainstorming e priorize cenários – en tre o grupo maior de partes interessadas, apresen te os cenários atuais e expanda. </li>
                      <li>Analise as abordagens arquitetônicas – execute a etapa 6 novamente com o conhecimento agre gado da comunidade mais ampla de partes inte ressadas. </li>
                      <li>Apresentar resultados – fornece toda a documen tação às partes interessadas. Durante todo o processo do ATAM, as soluções encon tradas serão sabatinadas e analisada a viabilidade, até que se defina o modelo arquitetural do projeto.  </li>
                    </ul>
                  </ul>
                  <p><strong> 5. Liderança técnica:   </strong></p>
                  <ul>
                    <li> Direcionar as equipes de desenvolvimento na esco lha, especificação e implantação de tecnologias, as sim como a definição e evolução de padrões de de senvolvimento. Poderíamos citar diversas outras atividades (ex: mo nitoração, prototipação....), o grande ponto no mo mento é compreender que as hard e soft skills com binadas ajudam o arquiteto a desempenhar suas funções com excelência </li>
                  </ul>
            </ul>
          </div>
          
          <div id="modulo-1-capitulo-3" class="capitulo">
            <h2>Capítulo 3: Arquitetura de Software Moderna</h2>
            <p>Governança da arquitetura, a governança da arquitetura envolve garantir que as soluções arquiteturais estejam sendo implementadas corretamente e que as decisões sigam padrões estabelecidos. O arquiteto deve garantir a conformidade das soluções através de revisões periódicas e assegurar que as decisões sejam documentadas adequadamente, contribuindo para a evolução da arquitetura. </p>
            
            
            <ul>
              <li><strong>3.1. Arquitetura Intencional</strong></li>
              <p> É a visão inicial determinando o fluxo do início do sistema, são as ideias gerais do sistema, análise de requisitos e projeto, é composta pelas decisões estruturais antes do desenvolvimento do sistema, conceito que enfatiza a importância de tomar decisões arquiteturais e conscientes, com o objetivo de alinhar a arquitetura do sistema com os objetivos e requisitos do negócio.  </p>
                  
              <p>Visão clara e compartilhada;</p>
                <ul>
                  <li>Foco em qualidade; </li>
                  <li>	Uso de padrões e melhores práticas; </li>
                  <li>Adaptabilidade e flexibilidade; </li>
                </ul>
                <p> Importância arquitetura intencional </p>

 
                <ul>
                  <li> Redução de riscos </li>
                  <li> Eficiência no desenvolvimento  </li>
                  <li>Satisfação do cliente </li>
                </ul>
                <p></p>
 
               
 
              <li><strong>3.2. Engenharia de Software Ágil</strong></li>
                <p>Manifesto Ágil:
                  Princípios e Valores, indivíduos e interações, software em funcionamento, responder a mudanças, colaboração com o cliente;
                  Não trabalha com planejamento total se trabalha em pequenos ciclos;
                  Características métodos ágeis:  Ciclos de entrega, incremental, adaptável, evolutivo;
                  Impactos na arquitetura de software: Menor intencionalidade, modulação, necessidade de flexibilidade, necessidade de sustentação, interfaces;
                  </p>

              <li><strong>3.3. Arquitetura Evolutiva</strong></li>
                <p>Definição do projeto arquitetura de software voltada para ser flexível e acomodar mudanças de forma contínua e incremental. Escopos pequenos e modularizando com o tempo, não faz o melhor código de primeira, faz conforme o teste e feedback do cliente.</p>
                <ul>
                  <li>Design incremental; </li>
                  <li>Modularidade </li>
                  <li>Iteratividade </li>
                  <li>Refatoração contínua;  </li>
                  <li>Gestão de débitos técnicos; </li>
                  <li>Uso de conceitos exploratórios; </li>
                </ul>
                <p>BDUF – É você tomar muitas decisões no início do seu projeto, o problema disso é fazer muito trabalho no início vai ter determinado muitas coisas e depois você vai ter um alto custo de mudanças ao longo do tempo para garantir que isso aqui, que o que você vai entregar para o cliente seja associado ao que o cliente espera.</p>
                <ul>
                  <li>Desalinhamento projeto X executado; </li>
                  <li>	Surgimento de Bugs; </li>
                  <li>Documentação desatualizada; </li>
                  <li> Desperdício;</li>
                  <li> 	Custo de mudanças;</li>
                </ul>
                <p>Exemplo de uso: Software embargado para um avião ou maquina, neste caso todas as especificações são obrigatórias;</p>
              
              <li><strong>3.4. Arquitetura Emergente</strong></li>
                <p>É a estrutura de um sistema que evolui organicamente a partir de práticas e decisões de design contínuas, baseadas em feedback e aprendizado constante ao longo do ciclo de desenvolvimento. Resumindo os problemas que vão surgindo no meio do caminho, a equipe toma decisões junto com o arquiteto;</p>
 
                <ul>
                  <li>Iteratividade e incrementalidade; </li>
                  <li>Design simples;  </li>
                  <li>Influenciada pela equipe;</li>
                  <li>Decisões não centralizadas; </li>
                  <li>Uso de padrões; </li>
                </ul>
                <p> Praticas associadas: </p>
                  <ul>
                    <li>TDD, BDD; </li>
                    <li>Programação em PAR; </li>
                    <li>Continous integration; </li>
                    <li>Refatoração;  </li>
                    <li>Arquitetura modular; </li>
                  </ul>
                <p> Desafios: </p>
                <ul>
                  <li> Tomada de decisões coletivas;</li>
                  <li> Experiência profissional; </li>
                  <li> Conhecimento de padrões; </li>
                  <li> Liderança técnica;</li>
                  <li> Soft skill’s;</li>
                  <li> </li>
                </ul>
 
                <p> Arquitetura tradicional/convencional: define a estrutura do sistema do início do projeto, com pouca flexibilidade para mudanças.
                  Arquitetura emergente: evolui a estrutura do sistema de forma incremental e adaptativa, permitindo mudanças contínuas e respondendo ao feedback;
                  Resumo - Foca na conformidade e documentação das soluções, com revisões periódicas para garantir padrões e evolução arquitetural.
                </p>
            </ul>
          </div>
          
          <div id="modulo-1-capitulo-4" class="capitulo">
            <h2>Capítulo 4: Estilos Arquiteturais Monolíticos</h2>
            <p>Evoluções e tendências da arquitetura, neste capitulo o foco é na evolução da arquitetura e nas novas tendências tecnológicas. O arquiteto de software precisa estar atendo às mudanças e inovações para adaptar e melhorar as soluções atuais. Isso inclui a adoção de práticas como DevOps, cloud computing e arquiteturas evolutivas que são essenciais para manter a competividade e atender as demandas dinâmicas do mercado. </p>
            <ul>
              <li><strong>4.1. Conceitos Gerais</strong></li>

              <p><strong>Estilos arquiteturais:</strong></p>
              <ul>
                <li>Design patterns de alto nível; </li>
                <li>Estrutura ou organização geral para um sistema de software; </li>
                <li>Integração entre componente do sistema e com o ambiente externo; </li>
                <li>Componentes </li>
                <li>Conectores </li>
                <li>Configuração/Topologia;  </li>
                <li>Princípios e restrições  </li>
              </ul>

 
              <p><strong> Importancia: Estilos arquiteturais   </strong></p>
              <ul>
                <li>Reutilização </li>
                <li>Comunicação eficiente </li>
                <li>Facilidade de manutenção e evolução; </li>
                <li>Melhoria da qualidade de software; </li>
              </ul>

              <p><strong> Critérios de comparação: Estilos arquiteturais   </strong></p>
              <ul>
                <li>	Centralização ou distribuição; </li>
                <li> 	Entrega única ou incremental;</li>
                <li> Características arquiteturais;</li>
                <li> 	Skills Equipe;  </li>
              </ul>
              </br>
  
              
              <li><strong>4.2. Arquitetura em Camadas</strong></li>
                <p><strong>Monolítico </strong> </p>
                <p> É uma arquitetura que você entrega ele para o cliente, através de um deployment único e esse é o conceito literário; 
                  Arquitetura em camada, o estilo arquitetural em camada organiza o sistema em níveis distintos, onde cada camada tem uma responsabilidade específica e interage om as camadas adjacentes de forma controlada; </p>
                
                  <p><strong> Camadas comuns:   </strong></p>
                  <ul>
                    <li>Camada de apresentação UI; </li>
                    <li>Camada de aplicação/negócio;</li>
                    <li>Camada de serviços/integração; </li>
                    <li>Camada de persistência/dados; </li>
                  </ul>
                  
                  <p><strong>Vantagens:    </strong></p>
                  <ul>
                    <li>Separação de responsabilidades; </li>
                    <li>Simplicidade;  </li>
                    <li>Desenvolvimento paralelo; </li>
                    <li>	Independência entre camadas; </li>
                    <li>	Reutilização;  </li>
            
                  </ul>
        
                  <p><strong>Desvantagens:    </strong></p>
                  <ul>
                    <li>Comunicação </li>
                    <li>Desempenho </li>
                    <li>Disponibilidade </li>
                    <li>Escalabilidade </li>
                    <li>Evolução </li>
                  </ul>
 
                  <p><strong>Boas práticas:    </strong></p>
                  <ul>
                    <li>Definição clara de interfaces;  </li>
                    <li>Adaptação a realidade do projeto; </li>
                    <li>Subdivisão de camadas; </li>
                  </ul>
                </br>

              <li><strong>4.3. Arquitetura Pipeline</strong></li>
                <p> Organiza o processamento de dados ou tarefas em uma sequência de estágios, onde cada estágio realiza uma operação específica e passa o resultado para o próximo estágio; </p>
                <p><strong>Estrutura:    </strong></p>
                  <ul>
                    <li> Pipes</li>
                    <li>Filters </li>
                  </ul>
                  <p> Exemplo: Compiladores, processamento de dados, processamento de imagens; </p>
                
                  <p><strong> Vantagens:   </strong></p>
                  <ul>
                    <li>Separação de responsabilidades; </li>
                    <li>Reutilização; </li>
                    <li>Escalabilidade; </li>
                    <li>Desempenho; </li>
                  </ul>
                  <p><strong> Desvantagens:   </strong></p>
                  <ul>
                    <li>Dependência sequencial; </li>
                    <li>Dificuldade na reversão; </li>
                    <li>Manutenção da integração; </li>
                    <li>Evolução funcional;  </li>
                    <li>Flexibilidade; </li>
                  </ul>
                  <p><strong> Boas práticas:    </strong></p>
                  <ul>
                    <li>Definição clara de interfaces; </li>
                    <li>Minimizar acoplamento; </li>
                    <li>Monitoramento e logs; </li>
                  </ul>
                </br>

              <li><strong>4.4. Arquitetura Microkernel</strong></li>
                <p> Também conhecida como Plug-in, é um estilo onde o sistema central (Microkernel) fornece funcionalidades mínimas e essenciais, enquanto as funcionalidades adicionais são implementadas como módulos ou plug-in que podem ser acoplados ou desacoplados conforme necessário. </p>
                
                <p><strong>Estrutura:    </strong></p>
                <ul>
                  <li>Core/Kernel; </li>
                  <li>Plug-ins; </li>
                  <li>Exemplos: Navegadores, IDEs; </li>
                </ul>
                
                <p><strong>Vantagens    </strong></p>
                <ul>
                  <li>Extensibilidade; </li>
                  <li>Robustez e estabilidade; </li>
                  <li>Disponibilidade;  </li>
                  <li>Simplicidade;  </li>
                  <li>Evolução funcional;  </li>
                </ul>
 
                <p><strong> Desvantagens:   </strong></p>
                <ul>
                  <li> Dificuldade de integração; </li>
                  <li> Sobrecarga devido a comunicação;</li>
                  <li> Gerenciamento de plug-in;</li>
                  <li> Ponto central;</li>
                  <li>Teste de integração;  </li>
                </ul>

                <p><strong>  Boas práticas:  </strong></p>
                <ul>
                  <li>Design do núcleo;  </li>
                  <li> Design plug-in;</li>
                  <li>Ampla cobertura de teste; </li>
                </ul>
            </ul>
          </div>
          
          <div id="modulo-1-capitulo-5" class="capitulo">
            <h2>Capítulo 5: Estilos Arquiteturais Distribuídos</h2>
            <ul>
              <li><strong>5.1. Conceitos Gerais</strong></li>
              <p>Arquiteturas utilizadas para projetar e implementar sistemas em que os componentes estão distribuídos em diferentes nós de uma rede. A distribuição dos componentes pode ocorrer por várias razões, como escalabilidade, resiliência, alta disponibilidade ou par aproveitar recursos geograficamente distribuídos; </p>
              <p><strong> Características:  </strong></p>
              <ul>
                <li>Distribuição de componentes; </li>
                <li>Descentralização;</li>
                <li>Comunicação de componentes; </li>
                <li>Tolerância a falhas; </li>
                <li>Escalabilidade;</li>
                <li>Heterogeneidade;  </li>
              </ul>
              <p><strong> Desafios:   </strong></p>
              <ul>
                <li>Segurança;</li>
                <li>Latência e desempenho;</li>
                <li>Coordenação e sincronização; </li>
                <li>Complexidade operacional; </li>
                <li>Escalabilidade e balanceamento de carga; </li>
              </ul>
              <p><strong>Aplicações:    </strong></p>
              <ul>
                <li>Amazon web service; </li>
                <li>Netflix; </li>
                <li>Google; </li>
                <li>Uber; </li>
                <li>Spotify;</li>
              </ul>
              <p><strong>  Tendências:  </strong></p>
              <ul>
                <li>Arquiteturas serveless; </li>
                <li> Edge Computing;</li>
                <li> Arquiteturas multi-cloud;</li>
                <li>Arquitetura federada; </li>
 
              </ul>
            </br>
              <li><strong>5.2. Arquitetura Orientada a Serviços (SOA)</strong></li>
              <p>É um estilo de arquitetura de software que organiza e estrutura um sistema em torno de serviços, que são componentes modulares e autônomos que realizam funções especificas. Esses serviços se comunicam entre si através de protocolos de rede para realizar tarefas complexas e fornecer funcionalidades empresariais.</p>
              <p>Serviços: unidade ou conjunto de funcionalidades de software independente, desenvolvido para concluir uma tarefa especifica, como recuperar determinadas informações ou executar uma operação. Ele contém as integrações de dados e o código necessários para executar uma função de negócio completa. Esses serviços podem ser acessados remotamente é possível interagir com eles e atualizá-los de maneira independente;</p>
              
              <p><strong>  Estrutura  </strong></p>
              <ul>
                <li>Provedor de serviços; </li>
                <li>Broker ou registro de serviços (contratos); </li>
                <li>Solicitante de serviços; </li>
              </ul>

              <p><strong>  Vantagens:  </strong></p>
              <ul>
                <li>Flexibilidade e time to Market; </li>
                <li>Reutilização de software;</li>
                <li>Evolução; </li>
                <li>Manutenção </li>
                <li>Escalabilidade; </li>
              </ul>

              <p><strong> Desvantagens:   </strong></p>
              <ul>
                <li>Complexidade na implantação/evolução; </li>
                <li>Latência; </li>
                <li>Sobrecarga devido a comunicação; </li>
                <li>Segurança; </li>
                <li>Dependências de padrão; </li>
                <li>Gerenciamento; </li>
              </ul>


              <p><strong>Boas práticas:    </strong></p>
              <ul>
                <li>Definição clara dos serviços; </li>
                <li>Monitoramento e gestão do desempenho; </li>
                <li>Reutilização; </li>
                <li>Padronize a comunicação (Ex. rest); </li>
                <li>Evolui integrando arquiteturas modernas (microserviços e apis) </li>
              </ul>
              </br>

              <li><strong>5.3. Arquitetura Microserviços</strong></li>
              <p>Estilo de arquitetura de software em que uma aplicação é estruturada como um conjunto de serviços pequenos e independentes, que se comunicam entre si através de APIs bem definidas. Cada microserviços é responsável por uma funcionalidade especifica do sistema e pode ser desenvolvido, implantando e escalado de forma independente dos outros;</p>
              <p>API’s application programming interface, interface que permite a comunicação entre microsserviços, serviços ou cliente externos.</p>
              <p><strong>  Vantagens:  </strong></p>
              <ul>
                <li>Flexibilidade e time to Market; </li>
                <li>Reutilização de software;</li>
                <li>Evolução; </li>
                <li>Manutenção; </li>
                <li>Escalabilidade; </li>
                <li>Comunicação por API; </li>
                <li>Resiliência;</li>
              </ul>
              <p><strong>  Desvantagens:  </strong></p>
              <ul>
                <li>Gestão dos microsserviços; </li>
                <li>Complexidades ACID; </li>
                <li>Despafronização; </li>
              </ul>
              <p><strong> Boas práticas:   </strong></p>
              <ul>
                <li>Descentralização dos dados; </li>
                <li>Comunicação assíncrona sempre que possível; </li>
                <li>Versionamento de APIs;</li>
                <li>Automatização CI/CD;</li>
                <li>Monitoramento e logging centralizado; </li>
                <li>Cultura de DevOps;</li>
              </ul>

              <li>5.4. Arquitetura Orientada a Eventos</li>
              <p>Estilo de arquitetura de software em que os componentes do sistema se comunicam e interagem entre si através da troca de eventos. Um evento é uma notificação de que algo significativo aconteceu dentro do sistema, como uma mudança de estado, uma ação do usuário ou a ocorrência de uma condição especifica;</p>
              <p>Exemplo: Uma mensagem que descreve algo que aconteceu no sistema. Por exemplo, pedido realizado ou pagamento aprovado ou usuário logado ou rastreio de correio, envio de promoção. Os eventos são geralmente representados como mensagens contendo dados relevantes, como o tipo de eventos e os detalhes associados.</p>
              <p>Na arquitetura orientada a eventos é necessário um sistema e mensageria, que utiliza algum padrão de comunicação como inscrição e publicação;</p>
            
              <p><strong> Vantagens:   </strong></p>
              <ul>
                <li> Desacoplamento;</li>
                <li> Desempenho;</li>
                <li> Escalabilidade;</li>
                <li> Comunicação assíncrona;</li>
              </ul>
              <p><strong>  Desvantagens:  </strong></p>
              <ul>
                <li>Complexidade; </li>
                <li>Adequação funcional; </li>
                <li>Gerenciamento de estado/eventual consistency; </li>
                <li>Depuração e rastreamento; </li>
              </ul>
              <p><strong> Boas práticas:   </strong></p>
              <ul>
                <li>Definição clara dos eventos;</li>
                <li>Modelos claro de gerenciamento de eventos; </li>
                <li>Desacoplamento entre produtores e consumidores; </li>
                <li>Confirmação de entrega de eventos; </li>
                <li>Segurança na comunicação;</li>
              </ul>
            
            
            </ul>
          </div>
          
          <div id="modulo-1-exercicios-fixacao" class="capitulo">
            <h2>Exercícios de Fixação</h2>
            <ul>
              <li>Primeira Aula Interativa - Trabalhando Estilos Arquiteturais</li>
            </ul>
          </div>
          
          <div id="modulo-1-capitulo-7" class="capitulo">
            <h2>Capítulo 7: Conduzindo o Processo Decisório</h2>
            <p>Neste capítulo, falaremos de atividades essenciais que o profissional de arquitetura de software precisa conhe cer e aplicar para desempenhar suas atividades com excelência, atividades tais como: como conduzir o pro cesso decisório, saber utilizar frameworks arquiteturais e gerenciamento de riscos. Gerindo o processo de Arquitetura Como líder do processo decisório, o arquiteto precisa conhecer práticas e ferramentas que vão lhe apoiar a guiar este processo. É importante frisar que o arquiteto não deve decidir de forma individual, em vários momentos este profissional deve guiar o processo de análise de toma de decisões que podem resultar em decisões dife rentes da que o arquiteto tomaria inicialmente. “O arquiteto não é dono da verdade, mas quem guia o processo de descoberta da mesma”. Vamos falar de algumas ferramentas: </p>
            
            <ul>
              <li>7.1. Matriz de Decisão</li>
              <p>Uma matriz de decisão é uma ferramenta analítica usada para avaliar e comparar diversas opções ou soluções com base em múltiplos critérios ponderados. Cada opção é avaliada contra esses critérios, e as pontuações resultantes são somadas para identificar a opção mais adequada. Um arquiteto de software pode utilizar a ma triz de decisão para selecionar tecnologias, frameworks, ou arquiteturas apropriadas para um projeto específico.  </p>
              <p>Ao definir critérios como desempenho, escalabilidade, custo, facilidade de integração e manutenção, o arqui teto pode atribuir pesos a cada critério de acordo com sua importância relativa. As diferentes opções são então avaliadas e pontuadas, permitindo ao arquiteto tomar uma decisão informada e justificada sobre a melhor so lução para atender aos requisitos do projeto e aos objetivos estratégicos da organização.</p>
              
              <li>7.2. Análise de Premissas e Restrições</li>
              <p>A análise de premissas e restrições é um processo de identificação e avaliação de suposições (premissas) e limitações (restrições) que influenciam o desenvolvimento de um projeto. Premissas são condições consideradas verdadeiras para planejamento, como a disponibilidade de determinada tecnologia, enquanto restrições são limitações que o projeto deve respeitar, como orçamento, prazo ou conformidade com regulamentações. Um arquiteto de software utiliza essa análise para assegurar que a arquitetura proposta esteja alinhada com as condições reais do projeto e as expectativas das partes interessadas. Ao identificar claramente as premissas e restrições, o arquiteto pode antecipar desafios, mitigar riscos e tomar decisões mais precisas, garantindo que a solução seja viável, eficiente e esteja dentro dos limites estabelecidos</p>

              <li>7.3. Análise de Custo da Solução</li>
              <p> A análise de custo e solução é um processo que envolve a avaliação detalhada dos custos associados a diferentes opções de solução para um projeto, considerando tanto os custos iniciais quanto os custos recorrentes, como manutenção e operação. O objetivo é comparar essas opções para determinar a mais econômica e eficaz em termos de retorno sobre investimento (ROI) e alinhamento com os objetivos de negócio. Um arquiteto de software utiliza essa análise para tomar decisões informadas sobre quais tecnologias, frameworks e arquiteturas adotar, assegurando que a solução escolhida não só atenda aos requisitos técnicos, mas também seja financeiramente viável. Isso ajuda a evitar custos excessivos, maximizar os recursos disponíveis e garantir que a solução possa ser sustentada a longo prazo dentro do orçamento da organização</p>

            </ul>
          </div>
          
          <div id="modulo-1-capitulo-8" class="capitulo">
            <h2>Capítulo 8: Gerenciando Riscos</h2>
            <ul>
              <li>8.1. Conceitos de Riscos</li>
              <p> É a possibilidade de um evento ou condição que, se ocorrer, pode afetar negativamente o projeto ou o sistema. Ex. Alteração do escopo, não renovação de uma licença, falta de recursos; </p>
              <p>Oportunidade é a possibilidade de um evento ou condição que, se ocorrer, pode afetar positivamente o projeto ou o sistema; </p>
              <p><strong> Tipos de riscos:   </strong></p>
              <ul>
                <li>Riscos técnicos. Ex. atualização de uma biblioteca; </li>
                <li>Riscos de projeto: Ex. mudança de requisitos; </li>
                <li>Riscos organizacionais. Ex. mudança na estratégia;</li>
              </ul>
              <p><strong>Gerenciar riscos:   </strong></p>
              <ul>
                <li>Identificação de riscos; </li>
                <li>Avaliação de análise de riscos; </li>
                <li>Mitigação e resposta e riscos; </li>
                <li>Monitoramento e revisão de riscos; </li>
              </ul>
              <p> Prever o desenho de uma arquitetura prover, uma estrutura para o sistema que garanta a entrega dos requisitos não funcionais, se eu tenho um risco que pode impactar de forma que o meu requisito não funcional não seja atendido, eu sou o guardião tenho que atual de forma proativa para evitar isso. </p>
             
              <li>8.2. Como identificar Riscos</li>
    
              <ul>
                <li>Brainstorming e análise de causas; </li>
                <li>Entrevistas e questionários com stakeholders; </li>
                <li> Análise de documentação e requisitos;</li>
                <li>Ferramenta de identificação SWOT </li>
                <li>Garantir transações ACID; </li>
                <li> Ferramenta de identificação:</li>
                <ul>
                  <li> Diagrama de fluxo e casos de uso;</li>
                  <li>Threat modeling; </li>
                </ul>
              </ul>



              <li>8.3. Como classificar Riscos</li>
              <p>Classificando riscos: Fatores a se considerar</p>
              <ul>
                <li>Probabilidade de ocorrência; </li>
                <li>Impacto ou consequência;</li>
                <li>Urgência e necessidade de resposta; </li>
              </ul>
              <p>Matriz de risco </p>
              <p>ROAM</p>
              <p>5W2H (Plano de ação)</p>

              <li>8.4. Prática Riscos</li>
              <p>Fluxo de Ishikawa (Diagrama de peixe)</p>


            </ul>
          </div>
          
          <div id="modulo-1-capitulo-9" class="capitulo">
            <h2>Capítulo 9: Frameworks Arquiteturais</h2>
            <p> Frameworks arquiteturais são estruturas de referência que oferecem uma base organizada para o desenvolvimento e a implementação de sistemas de software complexos. Eles proporcionam um conjunto de ferramentas, padrões e práticas que facilitam a criação de arquiteturas robustas, escaláveis e eficientes. Entre os exemplos mais conhecidos estão o TOGAF (The Open Group Architecture Framework), que foca na metodologia de desenvolvimento e governança de arquiteturas empresariais, e o Zachman Framework, que fornece uma visão multidimensional da arquitetura organizacional, abordando diferentes perspectivas e preocupações dos stakeholders. Esses frameworks ajudam a garantir que os sistemas atendam às necessidades do negócio, sejam consistentes e alinhados com os objetivos estratégicos da organização.</p>
            <ul>
              <li><strong>9.1. ZACHMAN </strong></li>
              <p> O Zachman Framework é uma estrutura conceitual desenvolvida por John Zachman na década de 1980, oferecem uma abordagem sistemática para compreender, documentar e gerenciar a arquitetura de uma organização. Esta estrutura é composta por seis dimensões fundamentais: “O quê”, “Como”, “Onde”, “Quem”, “Quando” e “Por quê”, cada uma representando uma perspectiva única sobre a organização. Em sua forma atual, o framework de Zachman consiste em uma matriz de 6 colunas por 6 linhas. As colunas correspondem às clássicas perguntas 5W1H (What/ Who/Where/When/Why/How) aplicadas à organização. As colunas, portanto, referem-se aos diferentes aspectos sobre a organização que precisam ser conhecidos: </p>
              <ul>
                <li> What: sobre o que a organização precisa de infor mação? De que ela trata? Normalmente, essa coluna representa dados mantidos pela organização; </li>
                <li> How: Como a organização funciona? Como ela processa seus dados? Esta coluna normalmente refere-se a processos e funções da organização.  </li>
                <li> Where: Onde as coisas acontecem? Aqui vão informações geográficas, de localização etc.  </li>
                <li> Who: Quem está na organização e quem faz o quê? Informações sobre pessoas e estruturas organizacionais estão aqui.  </li>
                <li> When: Quando as coisas acontecem? Questões relativas ao tempo aparecem aqui.  </li>
                <li> Why: Por que as coisas acontecem? Aqui vão as in formações relativas às motivações da organização, incluindo seus planos estratégicos de negócio. As linhas da matriz referem-se aos diferentes pontos de vista e níveis de detalhe relativos à informação que descreve a organização: A primeira linha contém o escopo e o contexto, e representa o ponto de vista do estrategista como teorizador sobre a organização. Normalmente, contém in formação relevante para o planejamento estratégico de alto nível e, é claro, o próprio conteúdo da Estratégia da organização. A segunda linha contém os conceitos de negócio, representando a visão da liderança executiva (vistos como proprietários dos processos de negócio e informações relacionadas). Contém tipicamente descrição detalhada da organização no nível de processos de negócio. A terceira linha contém informações sobre os sistemas de informação (nível lógico), com a visão dos arquitetos de sistemas (designers). A quarta linha contém informações sobre a infraestrutura tecnológica (nível físico) da organização, sendo o ponto de vista dos engenheiros enquanto construtores. A quinta linha refere-se à descrição dos componentes que a organização utiliza para operar, sendo a visão dos técnicos-implementadores. A sexta e última linha representa as operações propriamente ditas da organização, instanciadas pelos seus colaboradores participantes. O framework Zachman é uma excelente referência literária sobre o assunto, apesar de ter sua aplicabilidade limitada devido a não ser tão prático e dinâmico, assim como o fato de ser um framework mais geral e que não aborda de forma específica o contexto de arquitetura de software </li>
              </ul>
            </br>
              <li><strong> 9.2. TOGAF </strong></li>
              <p> O The Open Group Architecture Framework (TOGAF) é uma estrutura de arquitetura corporativa amplamente adotada, desenvolvida pelo The Open Group, que fornece uma abordagem abrangente e estruturada para planejar, projetar, implementar e gerenciar a arquitetura de uma organização. Esta estrutura é baseada em um conjunto de melhores práticas e padrões de arquitetura, destinados a promover a consistência, a eficiência e o alinhamento estratégico em toda a empresa. O TOGAF é amplamente reconhecido por sua flexibilidade e adaptabilidade, podendo ser personalizado e ajustado de acordo com as necessidades específicas de cada organização. Ele fornece uma estrutura sólida para a gestão e evolução da arquitetura empresarial, ajudando as empresas a alinhar seus sistemas de informação com seus objetivos estratégicos, reduzir a complexidade e promover a inovação. O TOGAF divide a arquitetura corporativa em quatro pilares básicos:  </p>
              <ul>
                <li> Business Architecture (Arquitetura de Negócio): define a estratégia de negócio, governança, organização e os processos chaves do negócio. </li>
                <li> Data Archtecture (Arquitetura de Dados): descreve a estrutura física e lógica dos ativos de dados da organização, bem como os recursos a serem gerenciados. </li>
                <li> Application Architecture (Arquitetura de Aplicação): provisiona um blueprint para que as aplicações individuais sejam publicadas, as interações e o relacionamento delas com os principais processos de negócio da organização. </li>
                <li> Technology Archiitecture (Arquitetura Técnica): descreve todo o hardware, software e infraestrutu ra de TI necessários para desenvolver e implantar aplicativos de negócios </li>
                <li> Fase Preliminar: é aquela na qual “colocamos em pé” o esforço de arquitetura, estabelecendo a equipe de arquitetura e definindo o método e metamodelo customizados a serem usados em nosso esforço de arquitetura. É aqui também que escolhemos ferramentas de repositório, definimos os processos de Governança da Arquitetura e obtemos o Patrocínio necessário para forço de arquitetura. </li>
                <li> Fase A – Visão Arquitetural: Trata-se de estabelecer uma visão de como deve ser nossa arquitetura futura para atender às metas estratégicas de negócio, que são a principal entrada para esta fase. O resultado desta fase é um Documento de Visão da Arquitetura, que documenta onde a organização quer chegar com sua arquitetura para viabilizar o cumprimento das metas estratégicas, e um Plano de Projeto para a execução desta “rodada” do ADM s </li>
                <li> Fase B – Arquitetura de Negócio: Desenvolver e documentar a Arquitetura de Negócio desejada (alvo), que irá descrever o que a organização necessita para operacionalizar os objetivos de negócio e responder aos direcionamentos definidos na Visão Arquitetural. O resultado da fase é o detalhamento das necessidades em termos de processos de negócio para atender às metas estratégicas, bem como um gap analysis que nos diz qual é a distância entre nossa situação atual (AS-IS) e a arquitetura em que queremos chegar (TO-BE).  </li>
                <li> Fase C – Arquiteturas de Sistemas de Informação: Nesta fase, identificamos os sistemas e dados necessários para atender à situação futura de processos de negócio desenhada na fase anterior, bem como nossa situação atual e a distância a ser percorrida (gap analysis). </li>
                <li> Fase D – Arquitetura de Tecnologia: Esta fase se ocupa de documentar as necessidades futuras em termos de infraestrutura tecnológica para atender às necessidades de sistemas e dados identificados na fase anterior. Mais uma vez, identificamos também nossa situação atual e a distância a ser percorrida.  </li>
                <li> Fase E – Oportunidades e Soluções: Nesta fase será gerado a versão inicial completa do Roadmap de Ar quitetura, baseado nos gaps identificados nas fases B, C e D. Identificaremos também projetos e ativida des que deverão ser realizados para atingir os obje tivos definidos no Roadmap. O resultado é um por tfólio de projetos para atingir a arquitetura desejada.  </li>
                <li> Fase F – Migration Planning: Aborda o planejamento detalhado da migração, ou seja, como passar do estado atual para a Arquitetura Alvo, certificando que o valor do negócio e o custo dos pacotes de trabalho e arquiteturas de transição são entendidos pelos stakeholders.  </li>
                <li> Fase G – Governança de Implementação: Nesta etapa o principal é a realização de revisões de conformidade com o objetivo de garantir que as ativida des definidas no portfólio estão sendo executadas de acordo com a arquitetura proposta.  </li>
                <li> Fase H – Gestão de Mudanças na Arquitetura: Trata-se de acompanhar no dia a dia a continuidade da relevância da arquitetura implantada na Fase G às necessidades estratégicas da organização. Mudanças no Ambiente de Negócios e na Estratégia exi girão mudanças na arquitetura, e o processo usado nesta fase deve ser capaz de separar pequenas de grandes mudanças. As grandes mudanças, tipicamente, exigirão a reentrada no ciclo do ADM, ou seja, o estabelecimento de um novo projeto, a ser iniciado novamente na Fase A.    </li>
                <li> Gestão dos Requisitos: Esta atividade encontra-se – literalmente – no “centro” do ADM, significando que cada uma das demais fases do ADM ao mesmo tempo gera novos requisitos de arquitetura e utiliza como entrada os requisitos de arquitetura previa mente identificados.  </li>
              </ul>
              <p>Entre os atrativos de utilização do TOGAF podemos citar sua flexibilidade, visto que as fases não devem ser seguidas como uma receita fixa, sendo assim cada organização pode adotar um processo adaptado conforme suas necessidades. Sendo este framework mais usual tanto pela sua flexibilidade, quanto pelo fato de ser um framework derivado de open groups - o que facilita sua utilização e proporciona uma maior rede de apoio durante o processo de uso.</p>

            </ul>
          </div>
          
          <div id="modulo-1-capitulo-10" class="capitulo">
            <h2>Capítulo 10: Engenharia e Arquitetura de Software</h2>
            <ul>
              <li>10.1. Ciclo de Vida de Software</li>
              <p>São fases que um sistema passa desde a sua concepção até o seu desligamento;</p>
              <p><strong> Modelo Cascata   </strong></p>
              <ul>
                <li>Comunicação: Iniciação do projeto, levantmento de requisitos </li>
                <li>Planejmento: Estimativas, cronogramas e monitoração; </li>
                <li>Modelagem: Análise e projeto; </li>
                <li>Construção: Codificação e teste; </li>
                <li>Implantação: Entrega, manutenção e feedback; </li>
              </ul>
              <p><strong> Modelo interativo:   </strong></p>
              <p><strong> Modelo incremental:   </strong></p>
              <p><strong> Modelo de ciclo de vida ágil:   </strong></p>
 

              <li>10.2. Arquiteturas Monolíticas, Deploy Único e Desenvolvimento Cascata</li>
              <p><strong>    </strong></p>
                  <ul>
                    <li> </li>
                    <li> </li>
                    <li> </li>
                    <li> </li>
                    <li> </li>
                    <li> </li>
                  </ul>
              
              
              <li>10.3. Arquiteturas Evolucionárias, Deploy e Desenvolvimento Incremental</li>
              <p><strong>    </strong></p>
                  <ul>
                    <li> </li>
                    <li> </li>
                    <li> </li>
                    <li> </li>
                    <li> </li>
                    <li> </li>
                  </ul>
              
              <li>10.4. Engenharia e Arquiteturas Software Considerações</li>
              <p><strong>    </strong></p>
              <ul>
                <li> </li>
                <li> </li>
                <li> </li>
                <li> </li>
                <li> </li>
                <li> </li>
              </ul>
            
            
            </ul>
          </div>
          
          <div id="modulo-1-capitulo-11" class="capitulo">
            <h2>Capítulo 11: DEVOPS</h2>
            <ul>

              <li><strong>11.1. Princípios DevOps</strong></li>
              <p>Devops é uma abordagem que integra práticas de desenvolvimento de software (Dev) e operações (Ops) para melhorar a colaboração, aumentar a eficiência e acelerar a entrega de software;</p>
              <p><strong>  Princípio fundamentais:  </strong></p>
              <ul>
                <li> Colaboração; </li>
                <li> Automação; </li>
                <li> Entrega e integração contínua (CI/CD) </li>
                <li> Feedback rápido e iteração;</li>
                <li> Melhoria contínua; </li>
              </ul>
              <p><strong> Benefícios:    </strong></p>
              <ul>
                <li>Qualidade e confiabilidade das entregas; </li>
                <li>Aumento da colaboração entre equipes; </li>
                <li>Viabilidade fluxo contínuo de entrega de valor; </li>
                <li>Velocidade de entrega;</li>
                <li>Redução de custo e riscos;</li>
              </ul>
              <p><strong>CALMS: dimensões fundamentais:   </strong></p>
              <ul>
                <li>Cultura </li>
                <li>Automação</li>
                <li>Lean (processos enxutos) </li>
                <li>Medição </li>
                <li>Sharing (compartilhamento)</li>
              </ul>

              <li><strong>11.2. Pilares DevOps</strong></li>
              <p><strong> Pilares da mudança cultural:   </strong></p>
              <ul>
                <li>Automação: Uso de ferramentas e scripts para automatizar tarefas repetitivas, como builds, testes e deploy. Ferramentas comuns: Selenium, Junit, Gitlab, Ansible; </li>
                <li>Integração contínua (CI): Prática de manter o código pronto para deploy a qualquer momento.  </li>
                <li>Entrega contínua (CD) </li>
                <li>Monitoramento e feedback: Monitoramento contínuo do sistema para garantir os requisitos não funcionais ao longo do tempo. Ferramentas: Phrometeus, Grafana, Elasticsearch; </li>
                <li>Segurança: DevSecOps: é a prática de integrar a segurança no processo de devops desde o início do ciclo de vida;</li>
              </ul>

              <li>11.3. Ferramentas e Práticas Comuns em DevOps</li>
              
              <li>11.4. Integrando DevOps e Arquitetura de Software</li>
              <p>Arquitetura evolutiva e devops, arquitetura evolutiva é a prática de construção sistemas que podem evoluir ao longo do tempo em resposta a mudanças nos requisitos e tecnologias;  </p>
              <p>Como devops pode contribuir para isto? Princípios de arquitetura evolutiva: Desacoplamento, feedback contínua, governança mínima, Exemplo: Mocrisserviços; </p>
              <p>Design para DevOps: Envolver práticas de design de software que facilitam a automação continua, entrega contínua e monitoramento. Elementos chave: Automação e Observabilidade; </p>
              <ul>
                <li>Imutabilidade de infraestrutura; </li>
                <li>Descentralização das decisões arquiteturais;</li>
                <li>Resiliência; </li>
                <li>Exemplo: Circuit Breakers e IaC; </li>
              </ul>


            </ul>
          </div>
          
    </div>

   <!-- Conteúdo do módulo 2 -->
    <div id="modulo-2">
      <h2>Módulo 2: Requisitos Arquiteturais e Modelagem Arquitetural</h2>

      <div id="modulo-2-capitulo-0" class="capitulo">
        <p><strong>Capítulo 0: Introdução à Engenharia de Requisitos</strong></p>
        <ul>
          <li>0.1. Apresentação</li>
          <li>0.2. Trajetória</li>
          <li>0.3. Redes Sociais</li>
          <li>0.4. Apresentação do Módulo</li>
        </ul>
      </div>
      
      <div id="modulo-2-capitulo-1" class="capitulo">
        <p><strong>Capítulo 1: Fundamentos de Engenharia de Requisitos</strong></p>
        <ul>

          <li><strong>1.1. Requisitos Arquiteturais e Funcionais</strong></a></li>
          <p>Sabemos que as maiores causas de falha em projetos de software se dão por definição errônea de requisitos. Estima-se que quase 85% dos efeitos em sistemas tem origem em requisitos mal levantados (Young, 2001/2002);</p>
          <p>A definição ou descrição de um requisito pode ser facilmente encontrado em muitos livros de engenharia de software. Em linhas gerais é aquilo ou algo que é desejado, ou requisitado pelo seu cliente/usuário que será utilizado para que alguma tarefa seja realizada. Um requisito de sistema é uma especificação de uma função ou característica que um sistema de software.</p>
          <p>O levantamento de requisitos é um processo essencial para o desenvolvimento de um sistema e pode ser realizado de diversas formas, como análise do ponto de vista dos envolvidos, pesquisa etnográfica, grupos de trabalho, versões de teste e desenvolvimento compartilhado.</p>
          <p><strong>Como realizar um levantamento de requisitos?    </strong></p>
          <ul>
            <li>Requisitos Funcionais: Os requisitos funcionais definem as funcionalidades específicas do sistema, representando tudo o que envolve interação direta com o usuário. São aspectos tangíveis e geralmente os mais perceptíveis para o cliente. Esses requisitos podem surgir a partir de problemas do dia a dia, melhorias em sistemas existentes ou demandas por novas funcionalidades. Exemplo: "O sistema deve permitir que usuários autenticados criem seus perfis e adicionem informações pessoais". </li>
            <li>Requisitos Não Funcionais: Os requisitos não funcionais estão relacionados a características como desempenho, usabilidade, confiabilidade, segurança, disponibilidade e manutenibilidade. Embora fundamentais para a qualidade do sistema, muitas vezes são negligenciados, deixados apenas para o time técnico ou considerados implícitos nos requisitos funcionais. Exemplo: "O sistema deve ter um tempo de resposta de no máximo 2 segundos para todos os processos de busca". </li>
          </ul>
          <p> O sucesso de um projeto de software depende de um bom levantamento de requisitos, pois cerca de 85% das falhas ocorrem nessa fase inicial. Compreender os requisitos é essencial para evitar problemas na modelagem arquitetural e garantir um sistema eficiente.</p>
          <p><strong>  Tipos de Requisitos  </strong></p>
          <ul>
            <li> Requisitos Funcionais: Relacionam-se diretamente com as funcionalidades do sistema, como telas e processos interativos para os usuários. Exemplos incluem cadastro de usuários e geração de relatórios.</li>
            <li> Requisitos Não Funcionais: Dizem respeito a aspectos como performance, segurança e escalabilidade, garantindo qualidade e eficiência. Exemplos incluem tempo de resposta inferior a 1 segundo e alta disponibilidade. </li>
          </ul>
          <p><strong>  Tríade dos Requisitos, Para um requisito ser validado, ele deve conter:  </strong></p>
          <ul>
            <li>Motivo: Justificativa da necessidade. </li>
            <li>Origem: Quem ou o que demandou o requisito (usuário, cliente, stakeholders). </li>
            <li>Objetivo: O que se espera alcançar. </li>
          </ul>
          <p><strong>Método, Processo e Ferramenta    </strong></p>
          <ul>
            <li>Método: Forma de execução. </li>
            <li>Processo: Passo a passo para realizar a tarefa. </li>
            <li>Ferramenta: Recursos utilizados para implementar o processo. </li>
          </ul>
          <p><strong>  Levantamento de Requisitos, Pode ser realizado de diversas formas:  </strong></p>
          <ul>
            <li>Entrevistas e pesquisas: Coleta direta ou coletiva de informações com usuários. </li>
            <li>Análise de sistemas legados: Identificação de melhorias e evoluções </li>
            <li>Ideação: Geração de ideias e definição de MVPs (Produtos Mínimos Viáveis). </li>
            <li>Testes empíricos: Avaliação de versões de teste em cenários reais </li>
          </ul>
          <P>Requisitos na Era da Computação em Nuvem: Com o avanço da computação em nuvem, a preocupação com hardware diminuiu, mas surgiram novos desafios, como controle de custos e escalabilidade. Hoje, requisitos não funcionais desempenham um papel crucial na otimização de desempenho e segurança. Esse panorama destaca a importância de documentar e compreender bem os requisitos, garantindo que o sistema atenda tanto às necessidades funcionais quanto à experiência do usuário e à eficiência operacional.</P>
          <p>Conclusão: Os requisitos não funcionais são menos tangíveis e frequentemente mal gerenciados, sendo deixados para a equipe técnica sem um planejamento adequado. Entretanto, são essenciais para garantir a qualidade e a experiência do usuário no sistema.</p>
          
          <li><strong>1.2. Arquitetura Mínima Viável</strong></li>
          <p>MVP – Produto mínimo viável, pensar no mínimo para ser entregue</p>
          <p>Conclusão: É melhor as postergar as decisões quando a incerteza é grande. A cada ciclo, fazer o mínimo necessário; </p>
          
          <li><strong>1.3. Padrões Arquiteturais</strong></li>
          <p>Padrões Arquiteturais e Metodologias de Desenvolvimento de Software, O desenvolvimento de software evoluiu ao longo dos anos, resultando em diferentes abordagens para planejamento e implementação de sistemas. Essas abordagens podem ser divididas em modelos tradicionais e metodologias ágeis.</p>
          <p><strong>  Modelos Tradicionais  </strong></p>
          <P>Os métodos tradicionais foram amplamente utilizados nas fases iniciais da engenharia de software e incluem:</P>
          <ul>
            <li><strong>Modelo Cascata: </strong>Processo sequencial com fases bem definidas (análise, projeto, codificação, testes e entrega). É rígido e pouco flexível para mudanças. </li>
            <li><strong>Modelo Espiral:</strong> Iterativo, permitindo entregas contínuas e aprimoramento progressivo. </li>
            <li><strong>Modelo Incremental:</strong> Desenvolvimento por partes, entregando funcionalidades em etapas. </li>
            <li><strong>Prototipação:</strong> Criação rápida de protótipos para validar requisitos com os usuários </li>
            <li><strong>RUP (Rational Unified Process):</strong> Processo iterativo baseado em fases, combinando planejamento e desenvolvimento contínuo </li>
          </ul>
          <p>Esses modelos são eficazes quando há requisitos bem definidos desde o início, mas apresentam dificuldades para lidar com mudanças constantes.</p>
          <p><strong>  Metodologias Ágeis  </strong></p>
          <p>Para responder à necessidade de maior flexibilidade e adaptação, surgiram as metodologias ágeis, que se destacam por:          </p>
          <ul>
            <li><strong>Iterações curtas:</strong> Desenvolvimento em ciclos pequenos, com entregas frequentes.</li>
            <li><strong>Times multidisciplinares:</strong> Equipes colaborativas atuando simultaneamente.</li>
            <li><strong>Feedback contínuo:</strong> Ajustes rápidos com base no retorno dos usuários.</li>
          </ul>
          <p><strong> Os métodos ágeis mais populares são:   </strong></p>
          <ul>
            <li><strong>Scrum: </strong>Baseado em sprints curtas, com papéis definidos (Scrum Master, Product Owner) e entregas incrementais.</li>
            <li><strong>Kanban:</strong>Utiliza quadros visuais para monitorar e otimizar o fluxo de trabalho. </li>
          </ul>
          <p>Conclusão: A transição dos modelos tradicionais para metodologias ágeis reflete a evolução das necessidades do mercado. O foco deixou de ser um processo rígido e linear para um desenvolvimento mais dinâmico, adaptável e colaborativo, garantindo entregas mais rápidas e alinhadas às expectativas dos clientes.</p>


          <li><strong>1.4. Desenvolvimento Ágil</strong></li>
          <p>O Desenvolvimento Ágil é baseado em metodologias que priorizam entregas rápidas, flexibilidade e colaboração entre as equipes. Ele se fundamenta nos seguintes princípios:</p>
          <ul>
            <li> Valor: Funcionalidades devem gerar valor ao usuário.</li>
            <li> Frequência: Desenvolvimento contínuo com entregas regulares.</li>
            <li> Flexibilidade: Capacidade de reavaliar prioridades.</li>
            <li>União: Uso combinado de diferentes tecnologias. </li>
            <li>Motivação: Equipe engajada melhora os resultados. </li>
            <li> Comunicação: Clareza sobre objetivos e execução.</li>
            <li> Simplicidade, Revisão e Sustentabilidade: Código limpo e sustentável. </li>
            <li>Organização: Coordenação entre múltiplas equipes.  </li>
            <li> Autoavaliação: Revisão constante para melhorias </li>
          </ul>
          <p><strong> Vantagens do Desenvolvimento Ágil   </strong></p>
          <ul>
            <li>Maior produtividade. </li>
            <li>Entregas contínuas e incrementais. </li>
          </ul>
          <p><strong>  Scrum Framework  </strong></p>
          <p>O Scrum é um dos principais frameworks ágeis, estruturado em ciclos curtos chamados sprints. Suas etapas incluem:</p>
          <ul>
            <li> Backlog – Lista de funcionalidades a serem desenvolvidas.</li>
            <li> Planning Meeting – Definição das prioridades da sprint.</li>
            <li> Sprint Backlog – Seleção das tarefas da sprint</li>
            <li> Task – Unidade mínima de uma funcionalidade</li>
            <li>Daily – Reuniões diárias de alinhamento. </li>
            <li>Review – Apresentação dos recursos desenvolvidos. </li>
            <li> Increment – Entrega das novas funcionalidades.</li>
            <li>Retrospectiva – Reflexão para melhorias futuras. </li>
          </ul>
          <p><strong> Papéis no Scrum   </strong></p>
          <ul>
            <li>Product Owner – Define requisitos e prioridades. </li>
            <li> Scrum Master – Facilita o processo e remove impedimentos.</li>
            <li>Equipe de Desenvolvimento – Responsável pela implementação. </li>
          </ul>
          <p> O Kanban também é utilizado como um método visual para gerenciar o fluxo de trabalho. </p>
          <P> Conclusão: O Desenvolvimento Ágil traz maior eficiência e qualidade para projetos, promovendo entregas frequentes, colaboração e adaptação rápida às mudanças. </P>

          <li><strong>1.5. Sistemas Legados</strong></li>
          <p> Os sistemas legados são aplicações desenvolvidas em tecnologias antigas, muitas vezes consideradas ultrapassadas, mas que ainda são amplamente utilizadas em diversas organizações. Apesar de serem essenciais para o funcionamento de muitos negócios, sua manutenção é desafiadora, devido à falta de suporte, dificuldades de integração com novas tecnologias e escassez de profissionais qualificados.</p>
          <p><strong> Desafios dos Sistemas Legados   </strong></p>
          <ul>
            <li>Utilizam linguagens e frameworks desatualizados. </li>
            <li>Dificuldade em encontrar especialistas para suporte e manutenção. </li>
            <li> Alto custo para modernização ou substituição.</li>
            <li> Possível incompatibilidade com tecnologias mais recentes.</li>
          </ul>
          <p><strong> Estratégias para Modernização   </strong></p>
          <p>A decisão sobre o que fazer com um sistema legado envolve diferentes abordagens, como:</p>
          <ul>
            <li>Evoluir o sistema atual – Melhorando partes do código, migrando gradualmente para tecnologias modernas. </li>
            <li>Criar um sistema novo do zero – Substituir completamente o legado por uma nova solução. </li>
            <li>Combinar ambas as estratégias – Atualizar funcionalidades críticas enquanto desenvolve um novo sistema em paralelo. </li>
          </ul>
          <p> Conclusão: A modernização de sistemas legados exige um planejamento estratégico, considerando custos, riscos e impactos para o negócio. Escolher entre evolução gradual ou reestruturação completa depende da complexidade do sistema, tempo disponível e recursos da empresa. </p>
          
          
          <li>1.6. Responsabilidades de Times</li>
          <p> A organização dos times dentro de uma empresa varia conforme o porte da empresa e a quantidade de colaboradores disponíveis.</p>
          <p> Empresas de grande porte possuem equipes especializadas, com divisão clara de responsabilidades, processos bem definidos e maior burocracia, exigindo metodologias ágeis para alinhamento e colaboração eficiente.</p>
          <p> Empresas menores contam com equipes multifuncionais, onde os profissionais assumem diversas responsabilidades. Esse modelo proporciona maior flexibilidade e agilidade, mas exige um alto grau de maturidade e capacitação para evitar sobrecarga.</p>
          <p> Independentemente do tamanho da empresa, o sucesso dos times depende de uma boa distribuição de tarefas, comunicação eficiente e processos estruturados, garantindo produtividade e eficiência.</p>

        </ul>
      </div>

      <div id="modulo-2-capitulo-2" class="capitulo">
        <h2>Capítulo 2: Elicitação de Requisitos Arquiteturais</h2>
        <ul>
          <li>2.1. O que é Engenharia de Requisitos</li>
          <p> A Engenharia de Requisitos é um processo essencial no desenvolvimento de sistemas, garantindo que as necessidades dos usuários sejam corretamente compreendidas e implementadas.</p>
          <p><strong>  Principais Etapas do Processo: </strong></p>
          <ul>
            <li>Elicitação de Requisitos – Entender o que deve ser desenvolvido, identificando as dores do cliente e mapeando fontes de requisitos. </li>
            <li>Análise de Requisitos – Classificar requisitos, resolver conflitos, realizar análise de custo-benefício e modelagem conceitual. </li>
            <li>Especificação – Documentação detalhada das funcionalidades e criação de tarefas.</li>
            <li>Validação – Garantir que os requisitos atendem às expectativas antes da entrega final. </li>
          </ul>
          <p><strong> Tipos de Requisitos:   </strong></p>
          <ul>
            <li><trong> Funcionais: </trong> Definem o que o sistema deve fazer. </li>
            <li><trong> Não funcionais:</trong>Requisitos de desempenho, segurança e usabilidade. </li>
          </ul>
          <p><strong> Ferramentas e Métodos:   </strong></p>
          <ul>
            <li>Uso de entrevistas e questionários para levantamento de requisitos. </li>
            <li>Métodos ágeis (Scrum, Kanban) para organização e acompanhamento de tarefas. </li>
            <li>Definition of Ready (DoR) e Definition of Done (DoD) para garantir clareza nas entregas. </li>
          </ul>
          <p> O sucesso da engenharia de requisitos depende da colaboração entre Product Owners, desenvolvedores, testadores e stakeholders, garantindo qualidade e alinhamento com as expectativas do cliente.</p>
          
          
          <li><strong> 2.2. Gestão de Produtos</strong></li>
          <p>A Gestão de Produtos envolve a criação, desenvolvimento e evolução de um produto, equilibrando design, tecnologia e negócios para atender às necessidades dos usuários e do mercado.</p>
          <p><strong> Arquitetura e o Mundo VUCA   </strong></p>
          <p>A arquitetura de um produto não deve considerar apenas a parte técnica, mas sim a resolução de problemas reais. O conceito de Mundo VUCA nos desafia a lidar com um ambiente:</p>
          <ul>
            <li> <strong> Volátil: </strong> Mudanças rápidas e inesperadas no mercado.     </li>
            <li> <strong> Incremental:  </strong> Evolução contínua, melhorando o produto ao longo do tempo.     </li>
            <li> <strong> Complexo: </strong>  Muitos fatores interligados influenciam as decisões.    </li>
            <li> <strong> Ambíguo : </strong> Nem sempre há uma única resposta correta.     </li>
          </ul>
          <p><strong> Sistema Finalizado: O Equilíbrio Essencial   </strong></p>
          <p>Um produto bem-sucedido precisa balancear três pilares:</p>
          <ul>
            <li> <strong>Design:  </strong>  Foco na experiência do usuário, usabilidade e estética.    </li>
            <li> <strong>Tecnologia: </strong>  Infraestrutura eficiente, escalabilidade e desempenho.    </li>
            <li> <strong>Negócios : </strong> Alinhamento com objetivos estratégicos, monetização e impacto no mercado.     </li>
          </ul>
          <p><strong>  Ciclo de Gestão de Produtos  </strong></p>
          <p>A gestão eficaz de um produto envolve um ciclo contínuo de melhoria e validação:</p>
          <ul>
            <li> <strong>Definir os próximos passos:  </strong> Planejar evoluções e melhorias.      </li>
            <li> <strong>Acompanhar a construção:  </strong>  Garantir que o desenvolvimento siga o plano.    </li>
            <li> <strong>Validar o que foi feito:  </strong>  Testar e verificar se as soluções atendem aos objetivos.    </li>
            <li> <strong>Definir objetivos:  </strong> Traçar metas claras para direcionar o crescimento do produto.     </li>
          </ul>
          <p><strong>  Entendendo o Problema  </strong></p>
          <p>Antes de desenvolver soluções, é essencial entender o problema que o produto visa resolver:</p>
          <ul>
            <li> <strong> Pesquisa: </strong>  Coleta de dados, feedbacks e análise de mercado.    </li>
            <li> <strong> Definição: </strong> Identificação do problema central e das necessidades dos usuários.     </li>
            <li> <strong> Desenvolvimento: </strong>   Implementação de funcionalidades para resolver os problemas identificados.   </li>
            <li> <strong>Liberação:   </strong>  Entrega do produto ou novas funcionalidades para os usuários.      </li>
            <li> <strong>Solução:  </strong> Ajustes e melhorias contínuas baseadas em testes e feedback.     </li>
          </ul>
          <p>A Gestão de Produtos exige visão estratégica, adaptação e colaboração entre equipes, garantindo que o produto evolua e continue relevante no mercado.</p>



          <li><strong>2.3. Tipos de Conhecimento</strong></li>
          <p> Para garantir o sucesso de um projeto, é essencial identificar os conhecimentos necessários e preencher lacunas de requisitos. Falhas nesse processo podem comprometer a entrega e a qualidade do produto. Além disso, a expertise no domínio do problema pode levar à omissão de conhecimento tácito, dificultando sua documentação e comunicação.</p>
          <p><strong> Impacto da Falta de Requisitos   </strong></p>
          <p>Requisitos ausentes ou mal definidos podem:</p>
          <ul>
            <li>Introduzir retrabalho e atrasos no projeto. </li>
            <li>Gerar funcionalidades incompletas ou incompatíveis com as necessidades reais. </li>
            <li>Comprometer a experiência do usuário e a qualidade do produto final. </li>
          </ul>
          <p><strong>  Conhecimento Tácito  </strong></p>
          <p>O conhecimento tácito é aquele adquirido ao longo da vida por meio da experiência. Ele não está formalmente documentado e, muitas vezes, é difícil de ser transmitido. Para lidar com esse tipo de conhecimento, é necessário:</p>
          <ul>
            <li><strong>Identificar: </strong>Reconhecer quais informações não estão explícitas. </li>
            <li><strong>Selecionar o que é relevante: </strong> Determinar quais conhecimentos devem ser compartilhados.</li>
            <li><strong>Articular no contexto certo: </strong> Tornar esse conhecimento acessível e compreensível para os stakeholders. </li>
          </ul>
          <p><strong>  Tipos de Conhecimento  </strong></p>
          <p>No contexto de desenvolvimento de produtos e projetos, o conhecimento pode ser categorizado em quatro tipos: </p>
          <ul>
            <li> <strong> Não sabe que sabe: </strong>  O indivíduo possui conhecimento, mas não tem consciência disso até ser desafiado ou questionado.     </li>
            <li> <strong> Sabe que sabe: </strong> Conhecimento consolidado e reconhecido, podendo ser facilmente aplicado ou compartilhado.     </li>
            <li> <strong> Não sabe que não sabe: </strong> Desconhecimento de algo essencial, representando um risco ao projeto.     </li>
            <li> <strong> Sabe que não sabe: </strong> Reconhece-se a falta de conhecimento sobre um assunto, permitindo buscar aprendizado ou apoio de especialistas.     </li>
          </ul>
          <p> A gestão do conhecimento exige estratégia e comunicação eficaz para garantir que as informações críticas sejam identificadas, compartilhadas e aplicadas corretamente no desenvolvimento do projeto. </p>



          <li>2.4. Desafios da Elicitação de Requisitos</li>
          <p>A elicitação de requisitos é um processo fundamental para o desenvolvimento de um sistema, pois define o que precisa ser construído e quais são as necessidades reais dos usuários e da empresa. No entanto, esse processo apresenta diversos desafios que podem comprometer o sucesso do projeto se não forem bem gerenciados.</p>
          <p><strong> Critérios de Sucesso do Projeto  </strong></p>
          <p>O sucesso de um projeto depende de três fatores principais:</p>
          <ul>
            <li> <strong> Custo : </strong>O orçamento deve ser bem planejado e controlado.      </li>
            <li> <strong>Tempo :  </strong>O cronograma precisa ser cumprido para evitar atrasos e impactos financeiros.      </li>
            <li> <strong>Satisfação :  </strong> O produto final deve atender às expectativas dos stakeholders e usuários.     </li>
          </ul>
          <p>Já o sucesso no gerenciamento do projeto envolve um equilíbrio entre:</p>
          <ul>
            <li> <strong>Custo :  </strong> Garantia de que os recursos financeiros sejam bem utilizados.     </li>
            <li> <strong>Tempo :  </strong> Cumprimento dos prazos estabelecidos.     </li>
            <li> <strong>Escopo :  </strong>Entrega das funcionalidades esperadas sem desvio nos objetivos do projeto.      </li>
          </ul>
          <p><strong> Desafios na Definição de Requisitos   </strong></p>
          <ul>
            <li> <strong> Requisitos arquiteturais: </strong> Garantir que a estrutura do sistema suporte crescimento, desempenho e escalabilidade.     </li>
            <li> <strong> Identificação de stakeholders: </strong>Encontrar as pessoas certas para fornecer informações e tomar decisões estratégicas.      </li>
            <li> <strong> Funcionalidades que ninguém usa:  </strong> Evitar desperdício de tempo e recursos em funcionalidades que não geram valor para o usuário final.     </li>
          </ul>
          <p><strong> Identificação de Stakeholders   </strong></p>
          <p>Os stakeholders são essenciais para definir os requisitos corretos. Eles podem ser:</p>
          <ul>
            <li>Líderes e gestores com influência na empresa e no projeto. </li>
            <li>Tomadores de decisão que aprovam mudanças e funcionalidades.  </li>
            <li> Especialistas no problema, que conhecem a fundo as necessidades do sistema.  </li>
            <li>Usuários finais, que interagem diretamente com o sistema e conhecem seus desafios.   </li>
            <li> Influenciadores da aceitação do sistema, que podem apoiar ou dificultar sua adoção.   </li>
            <li>Pessoas com objetivos pessoais ligados ao sucesso do projeto, como gerentes que precisam de bons resultados para sua carreira.   </li>
          </ul>
          <p>Para garantir o sucesso do projeto, é essencial envolver os stakeholders desde o início, definir requisitos claros e manter uma comunicação eficaz ao longo do desenvolvimento.</p>
        </ul>
      </div>

      <div id="modulo-2-capitulo-3" class="capitulo">
        <h2>Capítulo 3: Uso do Trello para Gestão de Requisitos – Parte I</h2>
        <p>O Trello é uma ferramenta de gerenciamento de projetos baseada no conceito de Quadro Kanban, que permite organizar tarefas de forma visual e colaborativa. Ele é amplamente utilizado para acompanhar requisitos e modelagem arquitetural, garantindo que todas as etapas do desenvolvimento sejam bem estruturadas e rastreáveis.</p>
        <p><strong>  Quadro Kanban no Trello  </strong></p>
        <p>O Quadro Kanban no Trello é composto por listas que representam diferentes fases do fluxo de trabalho. Cada tarefa é representada por um cartão, que pode ser movido entre as listas à medida que avança no processo. Um exemplo de estrutura eficiente inclui:</p>
        <ul>
          <li> <strong>Para Fazer:  </strong> Reúne todas as tarefas pendentes que precisam ser executadas.     </li>
          <li> <strong>Planejar :  </strong> Definição de escopo, levantamento de requisitos e modelagem da solução.     </li>
          <li> <strong>Executar:  </strong> Desenvolvimento e implementação das funcionalidades.    </li>
          <li> <strong>Revisar :  </strong>  Validação do que foi desenvolvido, incluindo testes e homologação.    </li>
          <li> <strong>Ajustar:  </strong> Correção de problemas e refinamentos necessários antes da entrega final.     </li>
          <li> <strong>Feito:  </strong>  Tarefas concluídas e aprovadas, garantindo rastreabilidade do progresso.    </li>
        </ul>
        <p><strong>  Benefícios do Trello na Gestão de Projetos  </strong></p>
        <ul>
          <li> Visualização clara do fluxo de trabalho e do progresso das tarefas.</li>
          <li> Colaboração eficiente entre equipes, permitindo comentários, atribuição de responsáveis e anexação de documentos.</li>
          <li>Flexibilidade para adaptar os quadros às necessidades do projeto. </li>
          <li>Facilidade na priorização de tarefas e acompanhamento do backlog. </li>
        </ul>
        <p>Ao integrar o Trello no processo de desenvolvimento, as equipes conseguem organizar melhor as demandas, otimizar a produtividade e garantir a entrega eficiente das funcionalidades.</p>
      </div>
    
      <div id="modulo-2-capitulo-4" class="capitulo">
        <h2>Capítulo 4: Uso do Trello para Gestão de Requisitos – Parte II</h2>
      </div>
    
      <div id="modulo-2-capitulo-5" class="capitulo">
        <h2>Capítulo 5: Primeira Aula Interativa – Demonstração de Projeto de Levantamento de Requisitos Arquiteturais</h2>
      </div>
    
      <div id="modulo-2-capitulo-6" class="capitulo">
        <h2>Capítulo 6: Análise de Requisitos Arquiteturais</h2>
        <p>Uma das tarefas mais importantes dos analistas de requisitos é a priorização das funcionalidades, garantindo que o time de desenvolvimento entregue o maior valor possível. Para isso, existem duas abordagens eficazes:</p>
        <p><strong>Kano Model     </strong></p>
        <p>Método que classifica os requisitos com base no impacto que causam na satisfação do usuário. Ele divide as funcionalidades em categorias como:</p>
        <ul>
          <li> <strong>Básicas (Must-have):  </strong>  Essenciais para o funcionamento do sistema.    </li>
          <li> <strong>Desempenho (Performance):   </strong> Quanto melhor forem implementadas, mais satisfeitos os usuários ficarão.      </li>
          <li> <strong> Encantamento (Delighters):  </strong>  Funcionalidades inesperadas que geram alto valor e satisfação.    </li>
        </ul>
        <p><strong> Cost of Delay (Custo do Atraso)   </strong></p>
        <p>Técnica que mede o impacto financeiro ou estratégico de adiar a entrega de uma funcionalidade. Ajuda na decisão sobre quais requisitos devem ser desenvolvidos primeiro, garantindo que o retorno sobre investimento seja maximizado.</P>
        <p>Essas ferramentas auxiliam na tomada de decisão, otimizando o planejamento e execução do backlog para que o projeto alcance seus objetivos com eficiência e impacto máximo.</p>
        <ul>
          <li><strong>6.1. Priorização de Requisitos </strong></li>
          <p>A priorização de requisitos é uma etapa essencial para garantir que o time de desenvolvimento atenda às expectativas do cliente, focando nos itens que geram mais valor. Para isso, dois modelos são amplamente utilizados:</p>
          <p><strong>  Modelo de Kano  </strong></p>
          <p>O Kano Model ajuda a categorizar funcionalidades de acordo com o impacto que têm na satisfação do usuário. Ele analisa as funcionalidades em um gráfico com dois eixos:</p>
          <ul>
            <li> <strong>  Eixo vertical: </strong>  representa a satisfação do usuário.    </li>
            <li> <strong>  Eixo horizontal:  </strong>  representa o investimento feito na funcionalidade (qualidade da implementação).    </li>
          </ul>
          <p>Esse modelo divide os requisitos em três categorias principais:</p>
          <p><strong>  Expectativas Básicas (Basic Expectations):  </strong></p>
          <ul>
            <li>São funcionalidades essenciais que o sistema precisa ter. </li>
            <li>Quando bem implementadas, são percebidas como mínimo necessário. </li>
            <li>Se mal implementadas ou ausentes, impactam negativamente a experiência do usuário. </li>
          </ul>
          <p><strong>Funcionalidades de Satisfação (Satisfiers):    </strong></p>
          <ul>
            <li>Apresentam um comportamento linear: quanto mais investimento, maior a satisfação. </li>
            <li>Se forem bem implementadas, geram alto valor. </li>
            <li>Se forem mal implementadas, prejudicam diretamente a percepção do usuário. </li>
          </ul>
          <p><strong> Funcionalidades de Encantamento (Delighters):   </strong></p>
          <ul>
            <li>São diferenciais inesperados que surpreendem positivamente os usuários. </li>
            <li> Se não existirem, não causam insatisfação, mas se forem bem implementadas, geram um grande impacto positivo.</li>
          </ul>
          <p><strong> Custo de Atraso (Cost of Delay - CoD)   </strong></p>
          <p>O Cost of Delay mede o impacto financeiro e estratégico causado pelo atraso na entrega de uma funcionalidade. Para priorizar tarefas com base nesse modelo, utilizamos a fórmula:</p>
          <p>Índice de Prioridade = Custo de atraso / Duração de implementação</p>
          <ul>
            <li> Quanto maior o custo do atraso, mais prioritária deve ser a funcionalidade.</li>
            <li>Funcionalidades rápidas e de alto impacto devem ser priorizadas. </li>
          </ul>
          <p>Além disso, diferentes tipos de funcionalidades possuem comportamentos distintos em relação ao custo do atraso, podendo variar de acordo com a criticidade para o negócio.</p>
          <p>Conclusão: A priorização eficaz garante que o time foque nos requisitos certos, otimizando tempo e recursos. O Modelo de Kano permite entender como as funcionalidades impactam os usuários, enquanto o Cost of Delay traz uma visão financeira e estratégica para decisões mais assertivas. Com essas abordagens, o desenvolvimento se torna mais eficiente e alinhado às necessidades do negócio.</p>



          <li><strong>6.2. Histórias de Usuários</strong></li>
          <p>Uma história de usuário é uma breve descrição de um requisito do ponto de vista de um usuário do sistema, essencial para promover o entendimento entre a equipe de desenvolvimento e o dono do produto. Cada história descreve o que o usuário precisa e por que isso é importante, geralmente escrita como se fosse o próprio usuário descrevendo sua necessidade.</p>
          <p>Por exemplo: "Eu, gerente, preciso acompanhar as atividades de minha equipe porque preciso garantir que as atividades sejam executadas dentro do prazo."</p>
          <p>O objetivo das histórias de usuário é promover a conversa entre a equipe de desenvolvimento e o dono do produto. Elas são intencionalmente incompletas para incentivar discussões e esclarecimentos constantes. Ao contrário de especificações formais, elas não fornecem todos os detalhes, mas exigem colaboração contínua para resolver dúvidas e esclarecer pontos. </p>
          <p>A analogia com uma foto ajuda a entender como funcionam as histórias de usuário. Inicialmente, a foto (história) pode parecer simples e sem muitos detalhes. Porém, ao contar a história por trás da foto, a imagem ganha mais contexto e significado, assim como as histórias de usuário se tornam mais claras e valiosas à medida que são discutidas com o dono do produto.</p>
          <p>As boas histórias de usuários devem ser escritas de forma que promovam alinhamento de conhecimento e compreensão entre todos os membros da equipe, com ênfase em conversas e negociações. </p>
          <p><strong>  Características de uma Boa História de Usuário  </strong></p>
          <ul>
            <li> <strong> Independência: </strong>  A história deve ser autossuficiente e não depender de outras histórias.    </li>
            <li> <strong>Negociável:  </strong>  Não deve ser vista como um contrato fechado. Deve ser aberta para discussões e ajustes.    </li>
            <li> <strong>Valiosa:  </strong>  A história deve claramente descrever o valor que ela gera para o cliente.    </li>
            <li> <strong>Estimável:  </strong>  Deve fornecer informações suficientes para que o time de desenvolvimento possa elaborar uma estimativa inicial de esforço.    </li>
            <li> <strong>Sob medida:  </strong>  A história deve ser pequena o suficiente para ser concluída em uma iteração ou sprint, considerando a capacidade do time.    </li>
            <li> <strong> Testável: </strong>  A história precisa ser clara o suficiente para permitir a definição de testes que garantam que a funcionalidade foi corretamente implementada.    </li>
          </ul>
          <p>Em resumo, histórias de usuário são uma ferramenta poderosa para entender as necessidades do usuário e garantir que o time de desenvolvimento esteja alinhado com os objetivos do negócio, sendo essencial para o sucesso do projeto.</p>
          <li><strong> 6.3. Débito Técnico </strong></li>
          <p>Durante o processo de desenvolvimento, é comum que o time tome decisões que envolvem comprometer as melhores práticas de codificação, muitas vezes por causa de prazos apertados ou da instabilidade dos requisitos. Essas decisões resultam em dívidas técnicas, que são questões no código que precisarão ser corrigidas no futuro. Embora possam ser necessárias em momentos específicos, essas escolhas podem levar a problemas acumulados, caso não sejam gerenciadas adequadamente.</p>
          <p>A gestão do débito técnico é crucial para garantir que essas questões sejam abordadas ao longo do tempo. Sem essa gestão, o produto pode se tornar cada vez mais complexo e a manutenção se tornará mais cara e difícil. Quando o débito técnico é acompanhado corretamente, o time pode planejar atividades de refatoração e correções dos problemas mais críticos, garantindo a evolução contínua do produto.</p>
          <p>Débito técnico está diretamente associado ao trabalho extra que resulta da escolha de uma solução rápida e fácil, em detrimento de uma abordagem mais eficiente e eficaz. Essas escolhas, embora convenientes no curto prazo, podem resultar em custos elevados de manutenção e desenvolvimento no longo prazo, comprometendo a qualidade do produto.</p>
        </ul>
      </div>
    
      <div id="modulo-2-capitulo-7" class="capitulo">
        <h2>Capítulo 7: Qualidade e Requisitos Arquiteturais</h2>
        <ul>
          <li><strong>7.1. Acessibilidade</strong></li>
          <p>Acessibilidade é a possibilidade de acesso a um lugar ou conjunto de lugar. No caso da web, uma interface com boa acessibilidade provê boa experiência de navegação para qualquer pessoa, independentemente de terem alguma deficiência ou não.</p>
          <p>Há diversos tipos de deficiência que podem atrapalhar a utilização de um site não acessível. A tabela abaixo relaciona algumas dessas deficiências e os potenciais problemas que podem ter</p>
          <p>Por que investir em acessibilidade: Estudos mostram que cerca de 20% da população brasileira possui algum tipo de deficiência. Certamente nem todas essas pessoas possuem incapacidades que as impeçam de utilizar um site não acessível. Mesmo que o percentual de usuário incapazes de utilizar um site não acessível seja 10% ou até 5%, é imprudente para qualquer negócio excluir tal percentual de potenciais clientes. Para uma loja on-line, por exemplo, alcançar 5% a mais de público pode representar mais vendas. Para uma rede social, representa mais usuários. Projetar um site acessível, então, é um investimento que deve ser considerado em projetos web.</p>
          <li><strong>7.2. Desempenho</strong></li>
          <p>As tecnologias de desenvolvimento web tem evoluído muito nos últimos anos. Com isso, estamos tentando fazer mais e mais coisas em nossas aplicações. Consequentemente, as aplicações estão ficando mais robustas e mais pesadas, podendo levar um longo tempo de carregamento e demora para os usuários. Dessa forma um problema tem ficado muito evidente: desempenho. Quanto mais tentamos fazer sistemas robustos, capazes de fazer muitas coisas, mais o desempenho se torna uma questão relevante para desenvolvedores. </p>
          <p>Existe um objetivo primário para se preocupar com desempenho: dar ao nosso usuário uma experiência melhor. Empresas conseguem aumentar consideravelmente a retenção de clientes e a rentabilidade de seus sites ao melhorar o desempenho da aplicação e, consequentemente, a experiência de seus usuários. </p>
          <p>Aplicações são essenciais para cada vez mais atividades fundamentais para as pessoas e o desempenho das aplicações, que não deve ser uma barreira para que elas consigam alcançar seus objetivos. </p>
          <P>Veremos várias formas de melhorar o desempenho das aplicações, mas você não precisa se preocupar em usar todas. Qualquer coisa que você puder fazer para melhorar o desempenho já poderá afetar positivamente a experiência do usuário. </P>
          <p>Os problemas de desempenho se concentram em dois pontos principais da aplicação: no carregamento da página e na renderização na página. O carregamento da página é quando todos os recursos estáticos são carregados no servidor para o navegador. Isso significa que quanto maiores forem os arquivos, maior será o tempo de carregamento. O tempo de renderização diz respeito ao tempo que demora depois que todos os arquivos essenciais foram carregados, e o navegador vai precisar trabalhar para compilar, interpretar tudo e dispor os elementos de uma maneira que seja entendível visualmente.</p>
          <p>Devemos tratar a questão de desempenho como uma questão estratégica para nossa aplicação. Vários estudos mostram que aplicações com melhor desempenho tem melhores resultados. Um site de vendas, por exemplo, poderá perder usuários ou perder vendas por conta de demora na resposta da aplicação. O usuário poderá fazer o cadastro no sistema porque aplicação demora muito, e ele acabou desistindo. Então devemos tratar desempenho como atributo diretamente ligado aos objetivos de negócio, por isso devemos decidir estrategicamente quanto tempo e esforço vamos investir para melhorar o desempenho da aplicação.</p>
          <li><strong>7.3. Usabilidade</strong></li>
          <p>Usabilidade define a facilidade com que as pessoas podem empregar uma ferramenta para realizar uma tarefa específica e importante. Dessa forma, a interface web deve ser construída para ajudar o usuário a realizar seu trabalho e chegar F informação importante de maneira efetiva. Conforme a ISO 9241-11: “Usabilidade é a medida pela qual um produto pode ser usado por usuários específicos para alcançar objetivos específicos com efetividade, eficiência e satisfação em um contexto de uso específico”. </p>
          <p>Para garantir alto grau de usabilidade, as interfaces do sistema devem contemplar os cinco atributos de usabilidade listados abaixo: Aprendizado, Eficiência, Memorização, Robustez, Satisfação</p>
          <p>Um sistema bancário é um exemplo de sistema de difícil aprendizado, mas muito eficiente. Um funcionário do banco deve ter vários treinamentos para entender os conceitos e as funcionalidades do sistema. Um usuário leigo certamente não conseguiria utilizar um software bancário sem treinamento. Entretanto, quando o usuário está familiarizado com o sistema, ele consegue chegar a seu objetivo facilmente. Utilizando apenas o teclado, com poucos comandos o funcionário do banco consegue resolver o problema de um cliente. Apesar de ser de difícil aprendizado, é bastante eficiente.</p>
        </ul>
      </div>
    
      <div id="modulo-2-capitulo-8" class="capitulo">
        <h2>Capítulo 8: Especificação e Validação de Requisitos Arquiteturais (E-book)</h2>
        <p>Como vimos até agora, o principal objetivo de uma equipe — composta por desenvolvedores, líderes, coordenadores e especialistas de negócios — é, antes mesmo de gerar modelos gráficos que representem a realidade do que o sistema deve se tornar, construir modelos de entendimento sobre como o software deve se comportar. Para alcançar o produto desejado com qualidade, dentro do prazo e orçamento, contamos com alguns recursos que auxiliam nesse processo. Assim, a modelagem não é um produto final, mas sim o meio adequado para a construção de um sistema.</p>
        <p><strong> Unified Modeling Language (UML)   </strong></p>
        <ul>
          <li>Unified Modeling Language, ou simplesmente UML, é uma linguagem que visa "permitir a comunicação" ao visualizar, especificar, construir, documentar e entender fluxos e sistemas. Surgiu na década de 1990 com a unificação de métodos no BOOCH (Object Oriented Software Engineering — OOSE) e Object Modeling Technique (OMT), tendo como mentores os renomados Grady Booch, Ivar Jacobson e James Rumbaugh (France; Koryn, 2001). Tornou-se, portanto, uma referência para modelagem de sistemas orientados a objetos e é amplamente utilizado em diversas ferramentas. </li>
          <li>A UML oferece diversos tipos de diagramas para especificar aspectos dinâmicos que descrevem como o sistema deve se comportar. Contudo, a UML não fornece um "caminho das pedras", mas sim formas de visualizar o que precisa ser feito. Podemos dividir a modelagem em dois grandes grupos: modelos comportamentais, que tratam dos aspectos dinâmicos e funcionais, e modelos estruturais. </li>
          <li>Um diagrama, em sua essência, é uma representação gráfica de informações, processos, sistemas e tudo o que pode ser expresso visualmente. Ele é utilizado para ilustrar ou exemplificar contextos, regras de negócios, fluxos de trabalho, entre outros. Diagrams são amplamente usados em diversas áreas, como engenharia, tecnologia e negócios. Como mostrado na ilustração acima, os diagramas podem ser divididos por forma de representação e geralmente possuem uma estrutura hierárquica. Embora muitos diagramas possam compartilhar características, devido à complexidade ou à proximidade hierárquica, cada um possui uma função e finalidade específicas. </li>
        </ul>
        <p><strong>  Diagramas Comportamentais  </strong></p>
        <ul>
          <li> Na modelagem computacional, um sistema é representado pela dinâmica e pelas funcionalidades que ele deve ter, sendo a modelagem comportamental responsável por isso. Os aspectos dinâmicos de um sistema descrevem como ele responderá a estímulos ou eventos vindos de fontes externas. Já os aspectos funcionais estão relacionados ao fluxo de atividades ou operações, como decisões, iterações, desvios, recursividade, entre outros. Em outras palavras, os aspectos dinâmicos descrevem “o que” o sistema deve fazer, enquanto os aspectos funcionais detalham “como” isso deve ser feito. </li>
          <li> A UML apresenta diagramas específicos para ambos os aspectos. Para os aspectos dinâmicos, temos:</li>
          <ul>
            <li> Caso de Uso</li>
            <li> Diagrama de Interação (Sequência e Colaboração)</li>
            <li> Diagrama de Transição de Estados</li>
          </ul>
          <li>Para os aspectos funcionais, destacamos:</li>
          <ul>
            <li>Descrição textual de Caso de Uso </li>
            <li>Diagrama de Atividades </li>
          </ul>
          <li>Entre os diagramas tanto para aspectos dinâmicos quanto funcionais, o diagrama de Caso de Uso é um dos mais utilizados. Ele é uma excelente ferramenta de comunicação entre os envolvidos, podendo especificar outros casos de uso e estabelecer relações diretas entre eles. </li>
          <li>Ao especificarmos a dinâmica de um caso de uso de um sistema, usamos o diagrama de caso de uso com seus respectivos relacionamentos. Por exemplo, no diagrama a seguir, temos uma relação entre "Atende Solicitação Almoxarifado" e os casos de uso específicos "Solicitação de Devolução" e "Atende Solicitação de Fornecimento". O "Atende Solicitação de Fornecimento", por sua vez, está incluído no caso "Verifica Cota". Casos como "Verifica Cota Material" e "V </li>
          <li>Para construir um diagrama de caso de uso eficaz (Booch; Rumbaugh; Jacobson, 1999), deve-se seguir algumas regras:</li>
          <ul>
            <li>O diagrama deve ter um nome. </li>
            <li> Minimizar o cruzamento de linhas.</li>
            <li>Deve apresentar um nível adequado de abstração. </li>
            <li>Relacionar casos próximos, quando houver uma relação. </li>
            <li>Apresentar apenas o agente e seu caso, para facilitar o entendimento. </li>
            <li>Evitar especificações excessivas e garantir que os aspectos importantes sejam detalhados.</li>
            <li>Focar em um aspecto do sistema dentro do seu escopo. </li>
          </ul>
          <li> Os diagramas de interação especificam os relacionamentos entre objetos com base em sua estrutura organizacional, considerando as mensagens enviadas e recebidas entre eles. O diagrama de sequência, por exemplo, além de mostrar as interações, também especifica a sequência em que elas ocorrem. Ele é frequentemente utilizado para ilustrar interações entre usuários e sistemas.</li>
          <li>Principais considerações para a criação de um diagrama de sequência:</li>
          <ul>
            <li>Definir o contexto da interação. </li>
            <li> Informar os parâmetros das mensagens.</li>
            <li>Dividir o diagrama por complexidade. </li>
            <li>A apresentação deve ser da esquerda para a direita. </li>
            <li>Informar as pré e pós-condições das mensagens. </li>
            <li>Representar a ordenação temporal das mensagens. </li>
            <li> Para objetos criados e destruídos, usar as notações apropriadas.</li>
          </ul>
          <li>No diagrama de colaboração, também conhecido como diagrama de comunicação, a interação entre objetos é o foco. Ele exibe a troca de informações e colaboração entre objetos, com a necessidade de uma ordem cronológica para dar sentido completo ao processo. Aspectos importantes:</li>
          <ul>
            <li>Nomear o diagrama. </li>
            <li>Estabelecer o contexto. </li>
            <li>Colocar as classes como vértices em um grafo. </li>
            <li>Desenhar as ligações por onde fluirão as interações. </li>
            <li>Numerar a sequência das interações. </li>
          </ul>
          <p>Por fim, o diagrama de transição de estados mostra a evolução de um sistema através de uma cadeia de estados, cada um representado por um retângulo, com transições indicadas por setas. Este diagrama é especialmente útil para sistemas com comportamento baseado em estados e ajuda a validar o comportamento lógico do sistema.</p>

          <p><strong> Diagramas Estruturais   </strong></p>
          <ul>
            <li>Os diagramas estruturais são utilizados para descrever a estrutura de sistemas ou partes deles, podendo se referir à parte física, como equipamentos, ou à parte lógica, como objetos em orientação a objetos. São frequentemente divididos em diagramas de componentes (representando a parte física), pacotes (representando a estrutura do sistema), objetos (mostrando a relação entre eles durante a execução), entre outros. </li>
            <li> Os diagramas de componentes podem ir além de representar partes físicas, incluindo também unidades funcionais, interfaces entre componentes, e estruturas arquiteturais. Eles são essenciais para identificar problemas e servir como documentação para futuras manutenções. </li>
            <li> Os diagramas de implantação representam os componentes de software e hardware de um sistema, mostrando as relações entre eles. Além disso, esses diagramas podem ilustrar a organização do sistema em pacotes e como as dependências entre pacotes e classes são estabelecidas. </li>
          </ul>

          <p><strong>Modelo Arquitetural 4+1    </strong></p>
          <ul>
            <li> Um modelo arquitetural é uma visão abstrata da realidade. Usamos modelos para capturar os elementos mais importantes, permitindo uma discussão focada e ajudando na tomada de decisões para projetos e produtos. Isso é necessário porque discutir todos os aspectos envolvidos de uma só vez seria muito complexo.</li>
            <li>O Modelo 4+1, proposto por Philippe Kruchten em 1995, organiza a descrição da arquitetura de sistemas complexos em cinco visões: quatro principais (lógica, de desenvolvimento, de processos e física) e uma visão adicional (cenários), que valida as outras quatro.</li>
            <p><strong> As Cinco Visões do Modelo 4+1:   </strong></p>
            <ul>
              <li>Visão Lógica: Foca nos aspectos funcionais do sistema, mostrando como os componentes de software suportam as funcionalidades principais. </li>
              <li>Visão de Desenvolvimento: Trata da organização estática do software, detalhando a estrutura dos arquivos de código, bibliotecas e artefatos. </li>
              <li>Visão de Processos: Foca no comportamento em tempo de execução, como concorrência, threads e processos, mostrando a dinâmica do sistema. </li>
            </ul>
          </ul>
        </ul>
      </div>
    
      <div id="modulo-2-capitulo-9" class="capitulo">
        <h2>Capítulo 9: Introdução ao Azure DevOps</h2>
      </div>
    
      <div id="modulo-2-capitulo-10" class="capitulo">
        <h2>Capítulo 10: Segunda Aula Interativa – Projeto no Azure DevOps</h2>
      </div>
    </div>

    <!-- Conteúdo do módulo 3 -->
    <div id="modulo-3">
      <h2>Módulo 3: Design Patterns, Estilos e Padrões Arquiteturais</h2>

      <div id="modulo-3-capitulo-0" class="capitulo">
        <p><strong>Capítulo 0 - Visão Geral do Módulo</strong></p>
        <ul>
          <li>0.1. Apresentação do Professor</li>
          <li>0.2. Apresentação do Módulo</li>
        </ul>
      </div>

      <div id="modulo-3-capitulo-1" class="capitulo">
        <p><strong>Capítulo 1 – Arquitetura de Software e Qualidade de Código</strong></p>
        <ul>
          <li>1.1. Introdução</li>
          <p>Qualidade de software, boas práticas de engenharia de software, principio desenvolvimento e projeto de software e técnicas e ferramentas para melhoria da qualidade. Catálogo de padrões de projeto, padrões para aplicações corporativas. Estilos e padrões arquiteturais, reconhecimento de características chaves de sistema, padrões arquiteturais e arquiteturas concentradas em domínios.</p>
          <p>A arquitetura de software, conceitos e propriedades fundamentais de um sistema considerando seu ambiente, seus elementos, seus relacionamentos e seus princípios de projeto e evolução. Como arquiteto de se preocupar com as características do sistema no vai ser construído, considerando as três partes muito importante que compõe a arquitetura de um sistema, a primeira delas define quais são as partes ou as estruturas, depois o papel dessas partes e também o relacionamento entre essas partes, e ao ambiente ao qual o software vai ser inserido</p>
          <p>As responsabilidades do arquiteto de softwares, vão muito além das decisões de alto nível do projeto. É muito importante que o arquiteto, apoie a equipe na empresa das melhores práticas de programação, zele pela qualidade e padronização do código fonte.</p>
          <p><strong> Conceitos importantes como:   </strong></p>
          <ul>
            <li> <strong> Clean Code: </strong>  Clean Code, ou "Código Limpo", é uma abordagem que enfatiza a legibilidade, simplicidade e manutenção de código. Um código limpo é fácil de entender, modificar e estender. Ele segue boas práticas de programação, como nomes claros para variáveis e funções, funções pequenas e focadas, e a eliminação de redundâncias. Clean Code busca reduzir a complexidade do código, tornando-o mais intuitivo e sustentável ao longo do tempo.    </li>
            <li> <strong> Object Calisthenics:  </strong> Object Calisthenics são um conjunto de regras e práticas criadas para melhorar a qualidade do código orientado a objetos. Elas foram projetadas para ajudar os desenvolvedores a escreverem código mais simples, mais legível e mais robusto. Alguns exemplos de regras incluem: "Não tenha mais de 2 argumentos em um método", "Evite o uso de loops", "Use apenas um nível de indentação por método" e "Nunca use null". O objetivo é promover uma programação mais limpa e bem estruturada, alinhada com os princípios da orientação a objetos.     </li>
            <li> <strong> TDD (Test-Driven Development): </strong> O TDD, ou Desenvolvimento Orientado a Testes, é uma metodologia de desenvolvimento de software onde os testes são escritos antes do código. O processo segue um ciclo contínuo de três etapas: Red (escrever o teste que falha), Green (escrever código suficiente para passar o teste), e Refactor (melhorar o código sem alterar seu comportamento). O TDD visa garantir que o código funcione como esperado desde o início e facilita a refatoração e manutenção, promovendo uma abordagem mais segura e eficiente para o desenvolvimento.     </li>
            <li> <strong> SOLID: </strong> SOLID é um acrônimo que representa cinco princípios fundamentais de design de software orientado a objetos. Eles são:      </li>
            <ul>
              <li> <strong> S - Single Responsibility Principle (SRP):  </strong>  Cada classe deve ter apenas uma responsabilidade, ou seja, um motivo para mudar.     </li>
              <li> <strong> O - Open/Closed Principle (OCP): </strong>  O software deve ser aberto para extensão, mas fechado para modificação.    </li>
              <li> <strong> L - Liskov Substitution Principle (LSP): </strong>  Objetos de uma classe derivada devem poder substituir objetos da classe base sem alterar a funcionalidade.    </li>
              <li> <strong> I - Interface Segregation Principle (ISP):  </strong>  Os clientes não devem ser forçados a depender de interfaces que não utilizam.    </li>
              <li> <strong> D - Dependency Inversion Principle (DIP):  </strong>  As classes de alto nível não devem depender de classes de baixo nível; ambas devem depender de abstrações.    </li>
            </ul>
          </ul>
          <p><strong> Patterns   </strong></p>
          <ul>
            <li>Design Patterns, ou Padrões de Projeto, são soluções reutilizáveis para problemas comuns de design que ocorrem em sistemas de software. Eles ajudam a estruturar o código de maneira eficiente e com boa manutenção, evitando reinventar a roda. Alguns dos padrões mais conhecidos incluem o Singleton, Factory, Observer, Strategy, entre outros. Os padrões ajudam os desenvolvedores a implementar soluções comprovadas e bem estruturadas para problemas específicos no design de software. </li>
          </ul>
          <p><strong> Code Smells   </strong></p>
          <ul>
            <li>Code Smells (ou "cheiros de código") referem-se a sinais ou indícios de que o código pode ser melhorado. Eles não são erros de sintaxe, mas sim práticas que podem levar a problemas de manutenção e evolução do software. Alguns exemplos de code smells incluem duplicação de código, funções ou classes com muitas responsabilidades, e métodos longos. Identificar e corrigir code smells pode ajudar a melhorar a qualidade do código e facilitar futuras modificações e refatorações. </li>
          </ul>
          <p><strong> Análise Estática de Código   </strong></p>
          <ul>
            <li> A Análise Estática de Código é uma técnica que examina o código fonte sem executá-lo, com o objetivo de encontrar possíveis erros, vulnerabilidades ou padrões que possam comprometer a qualidade do software. Ferramentas de análise estática de código verificam o código em busca de questões como violação de padrões de codificação, código duplicado, complexidade excessiva e possíveis bugs. Ela é essencial para garantir que o código atenda aos requisitos de qualidade e desempenho antes de ser executado em ambientes de produção. </li>
          </ul>
          <p>Esses conceitos formam a base de boas práticas de desenvolvimento e são fundamentais para garantir a qualidade, manutenibilidade e flexibilidade do software ao longo de seu ciclo de vida.</p>
          <p>Conclusão a arquitetura de software é uma disciplina diretamente relacionada com a qualidade final dos produtos de software. Demanda o conhecimento sobre diversas práticas e princípios. Tais princípios são fundamentais para o trabalho das equipes se transforme um trabalho de engenharia.</p>

          <li><strong>1.2. Code Smells </strong></li>
          <p>Alguns softwares possuem uma característica indesejada, entregam o resultado funcional esperado aos usuários, mas possuem problemas em suas estruturas internas. Praticas indevidas e outras funcionalidades vão sendo incorporadas usando como base as, mas definições que foram tomadas nas fases anteriores do projeto. </p>
          <p>Embora não impactem diretamente a execução dos sistemas, eles têm grande potencial de se tornarem efetivamente bugs, comprometerem o entendimento e a manutenção.</p>
          <p><strong>  Bloaters  </strong></p>
          <p>Bloaters (ou "inchaços") são code smells que surgem quando uma parte do código se torna excessivamente grande e difícil de manter. Esses problemas ocorrem quando o código cresce sem controle, tornando-se mais difícil de entender, modificar e testar.</p>
          <ul>
            <li> <strong> Long Method: </strong> Métodos com muitas linhas de código.     </li>
            <li> <strong>  Large Class: </strong>  Classes que acumulam muitas responsabilidades, tornando-se grandes e difíceis de entender.    </li>
            <li> <strong> Long Parameter List:  </strong>  Métodos ou funções com muitos parâmetros, dificultando a compreensão e uso.    </li>
          </ul>
          <p><strong>  Object-Orientation Abusers  </strong></p>
          <p>Os Object-Orientation Abusers são code smells relacionados ao uso incorreto ou inadequado dos conceitos de orientação a objetos. Eles ocorrem quando se faz um uso excessivo ou errado dos princípios da orientação a objetos, prejudicando a estrutura e a flexibilidade do sistema.</p>
          <ul>
            <li> <strong>Data Clumps  </strong> Agrupamento de dados relacionados que poderiam ser encapsulados em uma classe.     </li>
            <li> <strong> Switch Statements: </strong>O uso excessivo de instruções de switch em vez de utilizar o polimorfismo, o que viola o princípio da orientação a objetos e diminui a flexibilidade do código.      </li>
            <li> <strong>Refused Bequest:   </strong>   Quando uma classe filha herda métodos de uma classe pai, mas não os utiliza, violando o princípio da herança.   </li>
          </ul>
          <p><strong> Chance Preventers   </strong></p>
          Os Chance Preventers (ou "impedidores de oportunidades") são code smells que limitam a flexibilidade e a capacidade do sistema de se adaptar a mudanças. Eles restringem o código ao impedir que novas opções e soluções sejam exploradas.
          <ul>
            <li> <strong> Divergent Change: </strong> Quando diferentes partes de um sistema precisam ser alteradas simultaneamente, mas essas partes são modificadas de maneira independente, tornando o código mais propenso a erros.     </li>
            <li> <strong> Shotgun Surgery:  </strong> Quando uma pequena mudança no sistema exige que várias classes ou arquivos sejam alterados, aumentando a complexidade e o risco de introduzir erros.    </li>
            <li> <strong> Feature Envy: </strong> Quando um objeto ou classe precisa de dados de outro objeto de forma excessiva, o que indica que a responsabilidade pode estar mal distribuída entre as classes.     </li>
          </ul>
          <p><strong>  Dispensables  </strong></p>
          <p>Os Dispensables (ou "desnecessários") são code smells que indicam que algum código ou estrutura não tem utilidade ou não está contribuindo para o funcionamento do sistema. Eles aumentam a complexidade sem agregar valor real.</p>
          <ul>
            <li> <strong>Duplicate Code:  </strong>  Quando o código se repete em várias partes do sistema, aumentando a manutenção e o risco de inconsistências.    </li>
            <li> <strong>Dead Code:   </strong> Código que não é mais utilizado, mas que permanece no sistema, ocupando espaço e tornando o código mais difícil de entender.     </li>
            <li> <strong>Commented-out Code:  </strong>Código que foi comentado e não está sendo executado, mas que ocupa espaço no código, prejudicando sua legibilidade.      </li>
          </ul>
          <p>Essas categorias de Code Smells são sinais de que o código pode ser melhorado. Identificar e corrigir essas falhas pode levar a um código mais modular, flexível e fácil de manter. Ao seguir as boas práticas de design, como aplicar os princípios SOLID e refatorar o código regularmente, esses code smells podem ser minimizados, resultando em um software de maior qualidade e longevidade.</p>
          
          <ul>
            <li>1.2.1. Code Smells – Bloaters</li>
            <p>Os code smells do tipo bloaters referem-se a problemas causados pelo crescimento desordenado da estrutura do código, como métodos e classes, o que compromete a manipulação e manutenção do código. Esses problemas geralmente surgem ao longo do tempo, especialmente quando débitos técnicos não são sanados. Os principais exemplos dessa categoria incluem:</p>
            <ul>
              <li> <strong> Long method:  </strong>Métodos com muitas linhas de código.      </li>
              <li> <strong> Large class:  </strong>  Classes com muitos campos, métodos e linhas de código.    </li>
              <li> <strong>	Primitive obsession:  </strong> Uso excessivo de tipos primitivos em vez de objetos pequenos.     </li>
              <li> <strong> Long parameter list:  </strong>  Métodos com muitos parâmetros na assinatura.    </li>
              <li> <strong> Data clumps:  </strong> Agrupamento repetido de variáveis ou atributos em diferentes partes do código.      </li>
            </ul>
            <p>Esses code smells estão relacionados ao crescimento descontrolado do código e tendem a surgir à medida que o sistema evolui, frequentemente como resultado de falta de boas práticas de desenvolvimento ou conhecimento inadequado sobre o software.</p>
            <li>1.2.2. Code Smells – Couplers</li>
            <p>As causas dos code smells desta categoria são: Acoplamento excessivo entre classes e uso excessivo de delegação;</p>
            <ul>
              <li> <strong> Feature envy:  </strong> um método acessa mais dados de outro objeto do que seus próprios dados.     </li>
              <li> <strong> Inappropriated intimacy:  </strong>  uma classe acesso métodos ou atributos internos de outro classe.    </li>
              <li> <strong> Message chains: </strong>  um conjunto de métodos onde a implementação deles apenas chama outro método;    </li>
              <li> <strong> Middle man:  </strong>  uma classe que executa apenas uma ação a delega todos o restante do trabalho para outras classes.     </li>
            </ul>
            <p>Conclusão, os code smells do tipo couplers estão relacionados a violação dos princípios de coesão e acoplamento da O.O. Eles podem acontecer tanto por uso acessivo do acoplamento, quanto por excesso de delegação das responsabilidades para outras classes.</p>
          
          </ul>
          <li>1.3. Análise Estática de Código</li>
          <p>Avaliação do código, durante a análise, é possível aplicar diferentes regras para identificar, por exemplo: </p>
          <ul>
            <li>Presença de erros comuns de programação; </li>
            <li>Violação de política de nomenclatura; </li>
            <li>Códigos candidatos a refatoração; </li>
            <li>Testes de segurança; </li>
          </ul>
          <p><strong> No pipeline de CI/CD:   </strong></p>
          <ul>
            <li>Os benefícios capazes de desempenhar análises, de forma: Sistêmica, Consistente, Eficiente e Antecipada; </li>
            <li>Permite identificar uma vasta gama de deficiências, sintetizar e aplicar conhecimentos de especialistas, extrair e avaliar métricas, aplicar padrões de codificação e fornece feedback imediato; </li>
            <li>Permite algumas métricas representa unidades de tamanho de parte do código fonte como: Lines of code (LOC), Number of attibutes (NOA), Number of methods (NOM). Outras representam características da estrutura e relacionamento das classes: Wighted method per class (WMC), Lack of cohesion in methods (LCOM) e depth of inheritance tree (DIT). </li>
            <li>Threshold é uma abordagem que pode ser adotada e determinadar um threshold. Em uma análise baseada em threshold o resultado permite determinar quando um atributo está acima ou abaixo do valor esperado. Devem ser sempre monitorados e recalibrados. </li>
            <li>A definição de um threshold pode ser feita com base em: Referência (normas, padrões, etc), Benchmarks em um conjunto de sistemas, benchmarks de mercado e experiência profissional; </li>
            <li>Analise estática de código e code smells, diversos code smells estão diretamente relacionados a uma ou mais métricas, como exemplo: Long method, Large class, feature envy; </li>
          </ul>
          <p>Conclusão, a análise estática é uma prática importante para identificar diversos tipos de problemas em sistema, em tempo de compilação. É possível utiliza-la para extrair métricas do cpodigo e identificar code smells.          </p>
 
        </ul>
      </div>

      <div id="modulo-3-capitulo-2" class="capitulo">
        <p><strong>Capítulo 2 – Catálogos de Padrões</strong></p>
        <ul>
          <li>2.1. Introdução aos Catálogos de Padrões</li>
          <p>Arquitetura é uma das principais disciplinas da Engenharia de Software. Os produtos resultantes de seus processos contribuem de forma substancial para a garantia dos atributos de qualidade de um software. Além disso, a arquitetura envolve definições das partes elementares de um sistema e, portanto, espera se que todas sejam fundamentadas em práticas de engenharia. </p> 
          <p>Um arquiteto deve ser capaz de identificar características relevantes dos principais problemas que ocorrem durante o ciclo de vida de um software e propor soluções efetivas. Para auxiliar esse processo existem diversas propostas de padrões. Christopher Alexander define padrões como uma entidade que descreve um problema que ocorre repetidas vezes em um ambiente e apresenta uma essência de solução para esse problema, de tal forma que a solução possa ser replicada milhões de vezes sem nunca produzir resultados idênticos. Padrões são utilizados como templates para solucionar problemas recorrentes que se manifestam ao longo do ciclo de vida de um software. Por se tratarem de propostas amplamente testadas e bem documentadas, os padrões contribuem para garantir a qualidade do produto. Além disso, os padrões colaboram para a redução dos riscos dos projetos e para o estabelecimento de um vocabulário comum entre os profissionais, sejam desenvolvedores, testers, arquitetos, etc. Padrões na Arquitetura de Software têm sido estudados por décadas. Dado o grande número de propostas, eles são frequentemente organizados e divulgados em catálogos. Os catálogos concentram padrões com algum uso em comum, seja pelo tipo de problema ao qual se propõem a resolver ou por características das aplicações ao qual podem ser aplicados. </p>
          <p><strong> A documentação dos padrões frequentemente possui os seguintes elementos:    </strong></p>
          <ul>
            <li>Nome: descreve de forma sucinta o padrão;  </li>
            <li>Problema: define o problema que o padrão se propõe a resolver e quando o padrão deve ser utilizado.  </li>
            <li>Solução: descreve como o padrão propõe resolver o problema.  </li>
            <li> A solução deve ser sempre apresentada de forma genérica para possibilitar que o padrão seja aplicado em diferentes domínios de problemas e de forma independente de tecnologia. É comum a solução descrever os elementos, os relacionamentos entre os elementos e suas responsabilidades.  </li>
            <li>Resultados e consequências: descrevem os benefícios da adoção do padrão e suas consequências de forma a fundamentar a possível utilização ou não do padrão. Podem conter, por exemplo, impactos na flexibilidade, extensibilidade, portabilidade e manutenibilidade.  </li>
            <li> </li>
          </ul>
          <p><strong>  Existem diversos catálogos de padrões na literatura e alguns são enumerados na lista a seguir:   </strong></p>
          <ul>
            <li>GoF: um dos catálogos de padrões mais conheci dos e utilizados. Apresenta vinte e três padrões para solução de problemas frequentemente encontrados no desenho (projeto) de softwares orientados a objetos. Publicado no livro Design Patterns Elements of Reusable Object-Oriented Software de Gama et al.  </li>
            <li>AntiPatterns: catálogo de padrões que usa uma abordagem diferente dos demais. Ele apresenta soluções ruins, que não devem ser utilizadas, para problemas de projeto e codificação de software. Tais soluções podem comprometer a compreensão, a evolução e a manutenção do código fonte. Publicado no livro AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis de Brown et al.  </li>
            <li>Pattern Oriented Software Architecture (POSA): focado em padrões para desenvolvimento de sistemas de missão-crítica, muito utilizados no desenvolvimento de sistemas operacionais, servido res web, middlewares e softwares de plataforma. Publicado no livro Pattern-Oriented Software Architecture Volume 1: A System of Patterns de Buschmann et al.  </li>
            <li>Patterns of Enterprise Application Architecture (POEAA): apresenta diversos padrões para “aplicações corporativas”, com foco nas linguagens .Net e Java. Publicado no livro Patterns of Enterprise Application Architecture de Martin Fowler. 2  </li>
            <li> Design Patterns, Estilos e Padrões Arquiteturais </li>
            <li> DDD Patterns: discute padrões relevantes para equipes que utilizam a metodologia Domain Dri ven Design. Os detalhes de alguns padrões de DDD podem ser consultados no livro Patterns, Principles, and Practices of Domain-Driven Design de Scott Millett e Nick Tune. </li>
            <li> SOA Patterns: o livro Patterns: Service-Oriented Architecture and Web Services de Endrei et al. apresenta um catálogo com diversos padrões para solução de problemas frequentes na implementação de arquiteturas orientadas a serviços (SOA). Os padrões envolvem questões de projeto de arquitetura SOA, implementação de barramento de comunicação, descoberta de serviços, dentre outros. </li>
          </ul>
          <li>2.2. Patterns of Enterprise Application Architecture</li>
          <p>Padrões de Acesso a Dados e Sistemas Distribuídos - Martin Fowler</p>
          <p><strong>  Padrões de Acesso a Dados:  </strong></p>
          <p>Na arquitetura de software, requisitos como persistência de dados têm impacto significativo na qualidade do sistema. Martin Fowler, em seu livro Patterns of Enterprise Application Architecture, descreve vários padrões de acesso a dados que podem ser utilizados para resolver problemas comuns encontrados em diferentes fontes de armazenamento de dados, como bancos de dados relacionais, NoSQL, arquivos, entre outros.</p>
          <ul>
            <li> <strong> Active Record:  </strong> O padrão Active Record é usado quando as regras de persistência de dados são simples. Ele combina dados e comportamentos do negócio em um único objeto, simplificando o acesso à persistência. Nesse modelo, o objeto é responsável por carregar e salvar seus próprios dados no banco.     </li>
            <li> <strong>Data Mapper:   </strong>   O padrão Data Mapper é utilizado para separar os objetos do domínio do código de persistência. Ele atua como uma camada de mapeamento, traduzindo conceitos de orientação a objetos para a linguagem do banco de dados, permitindo que os objetos do domínio e a base de dados evoluam independentemente.    </li>
            <li> <strong> Unit of Work:  </strong>  O padrão Unit of Work gerencia transações, garantindo que todas as operações (inclusões, exclusões e modificações) em objetos afetados por uma transação sejam salvas no banco de dados de forma consistente. Este padrão é amplamente utilizado em aplicações web, onde cada requisição HTTP é tratada como uma transação independente.     </li>
            <li> <strong> Repository:  </strong>  O padrão Repository fornece uma camada intermediária entre o código do domínio e a fonte de persistência. Ele centraliza a lógica de acesso aos dados, oferecendo um local único para montar queries e aplicar regras de persistência. Esse padrão é útil em aplicações com múltiplos domínios ou consultas complexas.    </li>
            <li> <strong>  </strong>      </li>
          </ul>
          <p><strong> Padrões para Sistemas Distribuídos:   </strong></p>
          <p>Em sistemas distribuídos, a comunicação entre componentes e a integração com fontes externas podem ser desafiadoras. Fowler descreve alguns padrões que visam resolver problemas comuns neste tipo de arquitetura.          </p>
          <ul>
            <li> <strong> Gateway: </strong>  O padrão Gateway propõe o encapsulamento de acesso a recursos externos, como bancos de dados ou APIs, por meio de um objeto que remove o acoplamento entre a aplicação e a dependência externa. Isso reduz a complexidade, permitindo que a lógica da aplicação não precise lidar diretamente com os detalhes da fonte externa.    </li>
            <li> <strong>Service Hub:   </strong> O padrão Service Hub ajuda a mitigar problemas de desempenho durante testes, substituindo dependências externas por objetos stub. Isso permite que o teste se concentre na aplicação sem ser impactado por serviços externos lentos ou com falhas, melhorando a eficiência dos testes. </li>
            <li> <strong> Registry: </strong>   O padrão Registry oferece transparência de localização em sistemas distribuídos. Ele permite que clientes descubram a localização de serviços e recursos distribuídos dinamicamente, sem precisar de informações prévias sobre o servidor, tornando o sistema mais flexível e adaptável.    </li>
            <li> <strong> Remote Facade: </strong> No contexto de sistemas distribuídos, a comunicação entre objetos remotos é afetada pela latência da rede. O padrão Remote Facade sugere agrupar várias chamadas granulares em uma única chamada para reduzir o impacto da latência. O Remote Facade atua como um ponto único de acesso para múltiplas operações remotas, melhorando a performance da comunicação.     </li>
          </ul>
          <p> Conclusão: Esses padrões ajudam a enfrentar desafios comuns no desenvolvimento de sistemas corporativos e distribuídos. Ao aplicar os padrões descritos por Fowler, os arquitetos de software podem melhorar a modularidade, a flexibilidade e a escalabilidade dos sistemas, além de garantir maior eficiência e manutenção a longo prazo. </p>
          <li><strong> 2.3. Design Patterns – GoF</strong></li>
          <p>A definição de um threshold pode ser feita com base em: Referência (normas, padrões, etc), Benchmarks em um conjunto de sistemas, benchmarks de mercado e experiência profissional;  </p>
          <li><strong>2.4. Anti Patterns</strong></li>
          <p>A definição de um threshold pode ser feita com base em: Referência (normas, padrões, etc), Benchmarks em um conjunto de sistemas, benchmarks de mercado e experiência profissional;</p>
        </ul>
      </div>

      <div id="modulo-3-capitulo-3" class="capitulo">
        <p><strong>Capítulo 3 – GoF – Padrões de Criação</strong></p>
        <ul>
          <li><strong>3.1. Singleton</strong></li>
          <p>A definição de do padrão singleton ele atua sobre controle de instâncias de um objeto então Imagine que nós temos um determinado recurso vai ter um arquivo de configuração um sócrate de rede onde diversos processos podem consumir esse recurso na primeira execução quando esse recurso foi demandado nós vamos criar uma Instância de um objeto cliente e esse objeto cliente vai fazer o acesso ao recurso compartilhado quando uma nova execução acontecer o padrão final de utilizamos é criar uma nova Instância desse consumidor e essa Nova Instância afeta o recurso compartilhado e assim sucessivamente porém alguns recursos podem apresentar problemas se forem acessados por objetos diferentes consequentemente nas pernas três execuções em um sistema implementado com essa primitiva de comunicação nós vamos ter problemas dos mais diversos por acessar o recurso compartilhado ou três objetos simultaneamente cada um símbolo tem como proposta controlar o acesso a esses recursos quando a primeira execução acontecer nós vamos criar o objeto cliente desse recurso e em seguida quando a segunda ou a terceira execução surgirem elas vão compartilhar o mesmo objeto que existe atualmente e foi criado pela primeira execução dessa forma seja quantos objetos tentarem acessar esse recurso compartilhado todos eles vão utilizar apenas um cliente um consumidor o padrão sington.</p>
          <p>Ele garante que existirá uma única Instância de uma classe e somente uma forma de obter essa distância única E além disso essa Instância vai ser criada sob demanda sem nenhuma execução demandar o acesso àquele recurso compartilhado ela não vai ser criada dentro do sistema Em contrapartida o primeiro fato de existir o padrão siga como sistema pode eventualmente estar mascarando o problema de projeto dentro do sistema então nós precisamos realmente avaliar se aquela implementação do símbolo ela pode ser fatorada ou se ela realmente necessária ele requer tratamentos especiais como nós vimos Principalmente quando existe a possibilidade do alto índice de paralelismo e concorrência e aquelas equipes que usam testes unitários podem encontrar algumas dificuldades para gerar os moques dos objetos que são símbolos uma vez que existe um controle de qual Instância vai ser criada e tem um ponto único baseado métodos estáticos pode ser um pouco mais difícil complementar os testes unitários pelo sistema eu acho que precisamos ponderar os benefícios negativos se aplica as nossas necessidades nessa hora nós vimos que é possível controlar o ciclo de vida de um objeto garantindo que vai existir somente uma distância desse objeto durante toda a execução do sistema e nós podemos fazer uma analogia de que o pai é um síndico ele é uma evolução das variáveis globais que existem nos paradigmas da programação.</p>
          <li><strong>3.2. Builder</strong></li>
          <p>O padrão de criação Builder é utilizado para simplificar a criação de objetos complexos, onde a construção envolve múltiplas etapas, como inicialização de atributos, construção de objetos dependentes e obtenção de recursos compartilhados. Esse padrão permite a criação de diferentes representações de objetos por meio do mesmo construtor, tornando o processo mais flexível e organizado. Ele viabiliza a criação de objetos complexos de forma progressiva, facilitando a compreensão das etapas envolvidas.</p>
          <p>Entre os pontos positivos, destaca-se a flexibilidade na construção de objetos e a possibilidade de reutilizar etapas de criação, permitindo a materialização de diferentes tipos de objetos conforme o contexto. Além disso, o padrão contribui para a coesão das classes, alinhando-se aos princípios de responsabilidade única, ao separar a criação de um objeto de sua funcionalidade. </p>
          <p>Porém, o uso do padrão Builder pode aumentar a complexidade do projeto e das classes, tornando a implementação mais difícil de gerenciar, especialmente quando as etapas de construção se tornam recursivas ou exigem a criação de tipos concretos diferentes. Apesar disso, o padrão oferece uma abordagem consistente para a criação de objetos complexos.          </p>
          <li><strong>3.3. Factory Method </strong></li>
          <P>O padrão de criação é alguns conceitos de muitos sistemas possuem diferentes variações E além disso algumas etapas de criação da inicialização desses conceitos são comuns então nós temos uma árvore de heranças com diferentes níveis a criação aqui é a criação desses diferentes produtos conceitos dessa árvore de herança e dentro delas nós temos etapas comuns de criação de todos os tipos de produtos porém dentro do processo de criação ainda existem algumas etapas que são específicas de acordo com o produto que está sendo criado padrão nessa estrutura ele permite representar esse tipo de problema criando uma solução para ele e qualquer proposta imagine nós temos a necessidade de criar uma fábrica de sorvetes então quando uma classe do nosso sistema tem um papel de consumidor de clientes precisa produzir um sorvete dentro do padrão a inicialização do sorvete para uma fábrica porém o consumidor não vai chegar para fábrica de cria um sorvete de morango ou cria um sorvete de chocolate ou cria um sorvete de baunilha o cliente ele vai acionar a fábrica informar o tipo do sorvete que ele deseja e a fábrica tem um papel de construir o objeto real porém algumas etapas são comuns a todos os tipos de produtos nós temos um produto com diferentes tipos ou seja existem variações a materialização desses produtos Como obter o copinho ou a casquinha e decorar ele com a casinha Em contrapartida o sorvete sim produzido ele é específico de cada tipo de produto Então essa alergia ilustra a proposta do padrão a fábrica ela vai permitir que sejam criados diferentes tipos de produtos nós somos reutilizar as etapas comuns no caso porém conseguindo cumprir as etapas específicas de pegar um sorvete de morango ou chocolate. </P>
          <p>Ele viabiliza a construção de diferentes tipos de objetos em uma estrutura de herança onde cada classe filha pode determinar o comportamento de algumas etapas do processo de inicialização.</p>
          <li>3.4. Abstract Factory</li>
          <p>o padrão de criação abstratica alguns software são classificados como linhas do produtos de software que que significa isso eles demandam combinações diferentes de tipos de produtos e cada contexto de execução pode dominar uma combinação diferente as linhas de produtos de software são aqueles sistemas onde nós temos diferentes requisitos muitas vezes não funcionais como uma certa bancada um mecanismo de autenticação login e para cada um desses requisitos nós temos diferentes implementações eu posso ter o mecanismo de persistência como implementação posso ter um log com diferentes bibliotecas de lá alguém passa ter autenticação com diferentes algoritmos de autenticação e um software que é uma língua de produto eu posso na hora empacotar ele com persistência e autenticação com isso por exemplo e esse mesmo software por um outro contexto eu posso empacotar ele ou executá-lo com persistência no ciclo o log semi-log e autenticação e além do texto essas variações nós precisamos ter na linha de produtos software essa capacidade de combinar todos os tipos de produtos gerando a expectativa do cliente com mais em cada contexto Então esse padrão ele é diferente muitas vezes as pessoas acaba confundindo mas o papel dele é atuar em linha de produtos uma vez nós temos essa necessidade ele pode viabilizar a criação dessas famílias de produtos relacionados de forma que não há necessidades concretas dos objetos ou seja quando eu preciso de um determinado tipo de produto para usá-lo eu vou me basear em Abstrações desse produto sem me preocupar que na hora de execução eu vou ter uma persistência transparente os meus objetos consumidores. Compatibilidade entre objetos criados para cada Factor e ele remove o acoplamento entre os objetos Concretos e os seus consumidores uma vez que ele se baseiam em Abstrações Em contrapartida ele apresenta um nível maior de complexidade porém considerando que nós temos a demanda a necessidade de uma linha de produtos de software é a sua complexidade adicional pode se fazer valer. O padrão abstract Factor flexibiliza a criação de família de objetos garante a compatibilidade entre objeto criados e remove o acoplamento entre cliente e o produto concreto.</p>
        </ul>
      </div>

      <div id="modulo-3-capitulo-4" class="capitulo">
        <p><strong>Capítulo 4 – GoF – Padrões Estruturais</strong></p>
        <ul>
          <li><strong>4.1. Adapter</strong></li>
          <p>A definição de um padrões estruturais do catálogo falando do padrão a tendência que nós temos atualmente é reutilizar cada vez mais aplicação delegadas componentes e outras estruturas que se sentem porém muitas vezes nós nos deparamos com situações onde uma classe legada do sistema que já existe já é utilizada por diferentes pontos do sistema e por algum motivo não pode ser evoluída porque não é Nossa ou porque usa uma tecnologia mais antiga ou porque ainda nós não temos tempo hábil para poder fatorar essa classe e nós precisamos criar um novo código do cliente e vai utilizar porém o código do cliente ele espera um contrato que é distinta do que legal parece o problema é rápido</p>
          <p>Tem como proposta viabilizar a comunicação do cliente com a classe delegada mesmo eles tendo interfaces diferentes a proposta desse padrão É permitir que as classes clientes utilizam diferentes implementações de um conceito de forma Universal nós vimos que a classes podem ter interface diferente mas Além disso podem acontecer cenários onde a classe delegada tem duas implementações distintas é uma só então ele vai gerar uma interface comum estabelecida para que as clientes possa se comunicar com aquelas legais sendo ela uma ou duas ou quantas forem necessárias essa proposta inclui a criação adaptador a implementação incompatível ou seja nós vamos modelar qual é a visão oficial a visão padrão caso alguma classe legada implemente Essa visão padrão ela vai ser transparente com os consumidores porém aquelas que forem compatíveis vão ter adaptadores que traduzem as visões para que a cliente não precise tomar decisões fazer inspeções e qual delegada para tornar mais terrível. </p>
          <p>A proposta de solução do padrão permite definir uma representação padrão para um conceito dentro do sistema e por meio dela utilizar diferentes implementações de forma uniforme.</p>
          <li><strong>4.2. Facade</strong></li>
          <p>Existem no Sistema uma classe complexa ou ainda um componente complexo essa classe ela pode ser uma classe do sistema ou uma classe de terceiros que ela tem uma série de comportamentos e nós temos dentro de nosso sistema uma classe cliente com alguma determinada lógica que alteracionada vai consumir a estrutura dessa classe completa porém muitas vezes o uso dessa classe pode não ser trivial pode demandar várias chamadas a nível de granulares para métodos dessa classe ela pode ter problemas de coesão de acopramento</p>
          <p>E com isso se eu tenho somente uma classe cliente esses possíveis problemas nessa classe podem não ser significativos mas na medida eu começo a ter outras funcionalidades do nosso sistema se comunicando com essa classe eu vou ter efetivamente diferentes pontos do sistema com a replicação dessa lógica complexa de consumo desse método </p>
          <p>Às vezes o Mero o fato de eu conseguir reutilizar confiança com a delegação ou qualquer outro recurso da orientação do projeto resolvem esse problema de duplicidade porém eu posso encontrar limitações onde essas classes não possuem uma representação comum e como nós já sabemos não é interessante eu ter essa regra tem implementada em diferentes pontos principalmente sendo classes do sistema com conhecimento ele fazia de outra classe que pode nem ser do nosso sistema e amanhã eu troco essa classe Porque troquei o fornecedor por exemplo eu vou ter inúmeros pontos do sistema sendo alterados Esses são exemplos de problemas onde o padrão com ele nós vamos criar uma interface de comunicação com essa classe complexa as classes consumidores do nosso sistema sempre que precisarem acessar a classe complexa bom se basear na fachada e a fachada ela vai simplificar o uso da numerações necessárias para cumprir uma única responsabilidade Então ela absorve para ela a necessidade de conhecer essa classe complexa E além disso ela simplifica esse acesso gerando uma representação interna do sistema Ou seja eu consigo representar o negócio com base na Ótica do nosso sistema e não com base na Ótica de fornecedor com essa classe eu preciso apenas escrever a fachada se outra classe do sistema passa a necessidade daquela operação eram três chamadas de métodos todas elas Agora acessar a facada vamos dizer uma demonstração prática de como esse padrão pode ser implementado e as características particularidades. Como nós vimos o padrão permite isolar sistemas de artefatos de terceiros e artefatos complexos ele permite simplificar o uso de objetos complexos ou com problemas de desenho.</p>
          <li><strong>4.3. Flyweight</strong></li>
          <p>o padrão Flyweight não tem execução de sistema uma classe pode dar origem a diversos objetos porém em alguns casos parte do estado ou seja os atributos desses objetos pode ser igual pode ser compartilhada pelas várias instâncias que existem naquele objeto se esses dados não forem compartilhados entre essas instâncias vai haver um consumo desnecessário de memória que pode comprometer a performance do sistema Então esse padrão tem como objetivo atacar o consumo excessivo de memória ele é duplicação de estados de atributos de objetos que tem valores em comuns são iguais porém muitas vezes acabamos gerando referências de memórias duplicadas para guardar o mesmo dado Otimizar o uso de memória por meio do compartilhamento desses estados comuns entre as diferenças distâncias de objetos de uma classe vamos ver como esse padrão pode ser implementado tem como ideia Central reduzir o consumo de memória eliminando a duplicidade de estados de objetos que são comuns as diferentes instâncias que existem durante a execução do sistema a proposta de solução desse padrão contempla a criação de um contexto uma Factor e os n objetos que vão existir que são representados como esses objetos. Essa é a essência na solução do padrão como nós vemos padrão Flyweight torna possível reduzir consideravelmente o consumo de memória quando existe uma quantidade grande de objetos similares que são compartilhados entre diferentes classes de um sistema.</p>
          <li>4.4. Composite</li>
          <p>O padrão serviços e manipulados como uma composição, ou seja, como um todo e uma vez que nós desempenhamos uma ação sobre esse objeto sobre isso conceito todas as partes que formam esse elemento único podem sofrer a relação </p>
          <p>O padrão comparsa ele propõe por árvores de objetos de formas complexas com quantos níveis forem necessários E além disso nós vamos ter a possibilidade de consumir essa estrutura como um único objeto e durante o uso todas as objetos dessa estrutura podem ser acessados individualmente e quando eu desempenhar uma ação com aquele objeto que representa a estrutura todas as partes vão ser acionadas e podem Executar a sua responsabilidade dentro da estrutura. Permite manipular composições complexas e objetos como unidade ele utiliza o conceito polimorfismo para permitir objetos de tipos concretos distintos sejam utilizados e o uso da recursividade viabiliza estruturas de diferentes topologias sendo processadas sendo utilizadas como uma unidade.</p>
          <li><strong>4.5. Decorator</strong></li>
          <p>Nessa aula nós vamos concluir o estudo sobre os padrões estruturais falando em padrão de crédito na orientação pelo objeto uma vez que Nós criamos uma Instância de uma classe o objeto criado nunca muda a sua forma Seu Crime um objeto aluno ele vai ser aluno durante toda a existência desse objeto no sistema por mais que eu consiga visualizar de forma diferente se essa classe aluno tiver uma interface se ela tiver uma classe abstrata e eu consegui ver esse objeto pelas suas características baseadas dessas Abstrações ele sempre na memória vai ser um aluno e essa característica faz com que não seja possível adicionar ou remover comportamentos de um objeto em tempo de execução mas existem cenários onde essa possibilidade pode se tornar necessária e o padrão Decorator ele vai nos ajudar a criar uma solução que permita incluir substituir ou remover comportamentos de um objeto depois que ele foi criado os comportamentos são construídos que vão encapsular o objeto original então se eu quero incluir o comportamento a mais eu vou criar um objeto com esse comportamento a mais e ele vai envolver objeto original sempre que eu desempenhar algo com isso objeto encapsulado ação vai cair primeiro no envelope para depois ser enviada por objeto original e o meu envelope ele vai ter mesmo contrato mesmo interface que o objeto original Então todo mundo que enxerga que usa a classe conseguiria usar o possível.</p> 
          <p>Tem alguns pontos positivos ele permite estender o comportamento do objeto sem a necessidade de alterar a sua classe ou a sua estrutura ele torna possível combinar diferentes comportamentos de um objeto de acordo com o contexto de execução Em contrapartida ele aumenta consideravelmente a complexidade do código então nós precisamos pontuar se a nossa necessidade realmente demanda o uso do padrão Mas se a nossa resposta for afirmativa faz todo sentido nós adotarmos a proposta em alguma implementações pode ser complexo tratar coordenação e remoção da pilha de execução então ele tem que ser usado não tem mais isso afinal de começar a encadear demais comportamentos adicionados envolvidas substituídos pode se tornar difícil prever o Real comportamento vai ter nós ficamos porque permite adicionar substituir e remover comportamentos de um objeto contornando assim a limitação que existe da orientação por objeto. </p>
        </ul>
      </div>

      <div id="modulo-3-capitulo-5" class="capitulo">
        <p><strong>Capítulo 5 – GoF – Padrões Comportamentais</strong></p>
        <ul>
          <li>5.1. Command</li>
          <li>5.2. Template Method</li>
          <li>5.3. State</li>
          <li>5.4. Strategy</li>
        </ul>
      </div>

      <div id="modulo-3-capitulo-6" class="capitulo">
        <p><strong>Atividade de Fixação</strong></p>
      </div>

      <div id="modulo-3-capitulo-7" class="capitulo">
        <p><strong>Primeira Aula Interativa - Capítulo 6 – Princípios SOLID</strong></p>
        <ul>
          <li>6.1. Simple Responsibility Principle</li>
          <li>6.2. Open Closed Principle</li>
          <li>6.3. Liskov Substitution Principle</li>
          <li>6.4. Interface Segregation Principle</li>
          <li>6.5. Dependency Inversion Principle</li>
        </ul>
      </div>

      <div id="modulo-3-capitulo-8" class="capitulo">
        <p><strong>Capítulo 7 – Estilos Arquiteturais</strong></p>
        <ul>
          <li>7.1. Estilos Arquiteturais</li>
          <li>7.2. Estilos Arquiteturais – Structure</li>
          <li>7.3. Estilos Arquiteturais – Message Styles</li>
          <li>7.4. Estilos Arquiteturais – Adaptive Systems</li>
          <li>7.5. Estilos Arquiteturais – Distributed Systems</li>
          <li>7.6. Estilos Arquiteturais – Deployment</li>
        </ul>
      </div>

      <div id="modulo-3-capitulo-9" class="capitulo">
        <p><strong>Capítulo 8 – Padrões Arquiteturais</strong></p>
        <ul>
          <li>8.1. Padrões Arquiteturais</li>
          <li>8.2. Model View Controller (MVC)</li>
          <li>8.3. Model View Presenter (MVP)</li>
          <li>8.4. Model View ViewModel (MVVM)</li>
        </ul>
      </div>

      <div id="modulo-3-capitulo-10" class="capitulo">
        <p><strong>Capítulo 9 – Arquiteturas de Camadas</strong></p>
        <ul>
          <li>9.1. Hexagonal Architecture</li>
          <li>9.2. Onion Architecture</li>
          <li>9.3. Clean Architecture</li>
        </ul>
      </div>

      <div id="modulo-3-capitulo-11" class="capitulo">
        <p><strong>Capítulo 10 – Padrões para Sistemas Distribuídos</strong></p>
        <ul>
          <li>10.1. Padrões para Sistemas Distribuídos</li>
          <li>10.2. Enterprise Application Patterns – Point to Point Channel</li>
          <li>10.3. Enterprise Application Patterns – Publish Subscribe Channel</li>
          <li>10.4. Enterprise Application Patterns – Concurrency</li>
        </ul>
      </div>

      <div id="modulo-3-capitulo-12" class="capitulo">
        <p><strong>Capítulo 11 – Arquiteturas de Sistemas Distribuídos</strong></p>
        <ul>
          <li>11.1. Enterprise Application Integration (EAI)</li>
          <li>11.2. Service Oriented Architecture (SOA)</li>
          <li>11.3. Enterprise Service BUS (ESB)</li>
        </ul>
      </div>

      <div id="modulo-3-capitulo-13" class="capitulo">
        <p><strong>Atividade Modular</strong></p>
      </div>

      <div id="modulo-3-capitulo-14" class="capitulo">
        <p><strong>Segunda aula interativa - Capítulo 12 – Aplicação de Padrões Arquiteturais</strong></p>
        <ul>
          <li>12.1. Aplicação de Padrões Arquiteturais – MVC</li>
          <li>12.2. Aplicação de Padrões Arquiteturais – MVP</li>
        </ul>
      </div>
    </div>






  </div>
</body>
</html>
