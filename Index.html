<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sumário de Requisitos Arquiteturais e Modelagem</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
    }
    h1 {
      text-align: center;
      color: #333;
    }
    .sumario {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #f9f9f9;
    }
    .sumario ul {
      /*list-style-type: none;*/
      padding: 10;
    }
    .sumario li {
      margin: 10px 0;
    }
    .sumario a {
      text-decoration: none;
      color: #007BFF;
    }
    .sumario a:hover {
      text-decoration: underline;
    }
    .capitulo {
      margin-top: 40px;
      border-top: 2px solid #ccc;
      padding-top: 20px;
 
      text-align: justify;
    }
  </style>
</head>
 
<body>
  <div class="sumario">
    <h1>Arquitetura de software</h1>
    <h2>Sumário</h2>
    <ul>
      <li><a href="#modulo-1">Módulo 1: Fundamentos de Arquitetura de Software</a></li>
      <ul>
        <li><a href="#modulo-1-capitulo-0">Capítulo 0: Visão Geral do Módulo</a></li>
        <li><a href="#modulo-1-capitulo-1">Capítulo 1: Introdução à Arquitetura de Software</a></li>
        <li><a href="#modulo-1-capitulo-2">Capítulo 2: O Profissional de Arquitetura de Software</a></li>
        <li><a href="#modulo-1-capitulo-3">Capítulo 3: Arquitetura de Software Moderna</a></li>
        <li><a href="#modulo-1-capitulo-4">Capítulo 4: Estilos Arquiteturais Monolíticos</a></li>
        <li><a href="#modulo-1-capitulo-5">Capítulo 5: Estilos Arquiteturais Distribuídos</a></li>
        <li><a href="#modulo-1-exercicios-fixacao">Exercícios de Fixação</a></li>
        <li><a href="#modulo-1-capitulo-7">Capítulo 7: Conduzindo o Processo Decisório</a></li>
        <li><a href="#modulo-1-capitulo-8">Capítulo 8: Gerenciando Riscos</a></li>
        <li><a href="#modulo-1-capitulo-9">Capítulo 9: Frameworks Arquiteturais</a></li>
        <li><a href="#modulo-1-capitulo-10">Capítulo 10: Engenharia e Arquitetura de Software</a></li>
        <li><a href="#modulo-1-capitulo-11">Capítulo 11: DEVOPS</a></li>
      </ul>
  

      <li><a href="#modulo-2">Módulo 2: Requisitos Arquiteturais e Modelagem Arquitetural</a></li>
      <ul>
        <li><a href="#modulo-2-capitulo-0">Capítulo 0: Introdução à Engenharia de Requisitos</a></li>
        <li><a href="#modulo-2-capitulo-1">Capítulo 1: Fundamentos de Engenharia de Requisitos</a></li>
        <li><a href="#modulo-2-capitulo-2">Capítulo 2: Elicitação de Requisitos Arquiteturais</a></li>
        <li><a href="#modulo-2-capitulo-3">Capítulo 3: Uso do Trello para Gestão de Requisitos – Parte I</a></li>
        <li><a href="#modulo-2-capitulo-4">Capítulo 4: Uso do Trello para Gestão de Requisitos – Parte II</a></li>
        <li><a href="#modulo-2-capitulo-5">Capítulo 5: Primeira Aula Interativa – Demonstração de Projeto de Levantamento de Requisitos Arquiteturais</a></li>
        <li><a href="#modulo-2-capitulo-6">Capítulo 6: Análise de Requisitos Arquiteturais</a></li>
        <li><a href="#modulo-2-capitulo-7">Capítulo 7: Qualidade e Requisitos Arquiteturais</a></li>
        <li><a href="#modulo-2-capitulo-8">Capítulo 8: Especificação e Validação de Requisitos Arquiteturais (E-book)</a></li>
        <li><a href="#modulo-2-capitulo-9">Capítulo 9: Introdução ao Azure DevOps</a></li>
        <li><a href="#modulo-2-capitulo-10">Capítulo 10: Segunda Aula Interativa – Projeto no Azure DevOps</a></li>
        <li><a href="#modulo-2-material-complementar">Material Complementar</a></li>
      </ul>

      <li><a href="#modulo-3">Módulo 3: Design Patterns, Estilos e Padrões Arquiteturais</a></li>
      <ul>
        <li><a href="#modulo-3-capitulo-0">Capítulo 0 - Visão Geral do Módulo</a></li>
        <li><a href="#modulo-3-capitulo-1">Capítulo 1 – Arquitetura de Software e Qualidade de Código</a></li>
        <li><a href="#modulo-3-capitulo-2">Capítulo 2 – Catálogos de Padrões</a></li>
        <li><a href="#modulo-3-capitulo-3">Capítulo 3 – GoF – Padrões de Criação</a></li>
        <li><a href="#modulo-3-capitulo-4">Capítulo 4 – GoF – Padrões Estruturais</a></li>
        <li><a href="#modulo-3-capitulo-5">Capítulo 5 – GoF – Padrões Comportamentais</a></li>
        <li><a href="#modulo-3-capitulo-6">Atividade de Fixação</a></li>
        <li><a href="#modulo-3-capitulo-7">Primeira Aula Interativa - Capítulo 6 – Princípios SOLID</a></li>
        <li><a href="#modulo-3-capitulo-8">Capítulo 7 – Estilos Arquiteturais</a></li>
        <li><a href="#modulo-3-capitulo-9">Capítulo 8 – Padrões Arquiteturais</a></li>
        <li><a href="#modulo-3-capitulo-10">Capítulo 9 – Arquiteturas de Camadas</a></li>
        <li><a href="#modulo-3-capitulo-11">Capítulo 10 – Padrões para Sistemas Distribuídos</a></li>
        <li><a href="#modulo-3-capitulo-12">Capítulo 11 – Arquiteturas de Sistemas Distribuídos</a></li>
        <li><a href="#modulo-3-capitulo-13">Atividade Modular</a></li>
        <li><a href="#modulo-3-capitulo-14">Segunda aula interativa - Capítulo 12 – Aplicação de Padrões Arquiteturais</a></li>
      </ul>

      <li><a href="#modulo-4">Módulo 4: Principais Arquiteturas de Software da Atualidade</a></li>
      <ul>
        <li><a href="#modulo-4-capitulo-0">Capítulo 0: Visão Geral do Módulo</a></li>
        <li><a href="#modulo-4-capitulo-1">Capítulo 1: Introdução a Arquiteturas de Sistemas Web</a></li>
        <li><a href="#modulo-4-capitulo-2">Capítulo 2: Frameworks SPA para Desenvolvimento WEB</a></li>
        <li><a href="#modulo-4-capitulo-3">Capítulo 3: Introdução às APIs e Arquiteturas REST e GraphQL</a></li>
        <li><a href="#modulo-4-capitulo-4">Capítulo 4: Documentação de APIs com SWAGGER</a></li>
        <li><a href="#modulo-4-capitulo-5">Capítulo 5: Demonstração de Arquiteturas de Microsserviços</a></li>
        <li><a href="#modulo-4-capitulo-6">Capítulo 6: Arquiteturas Orientadas a Eventos</a></li>
        <li><a href="#modulo-4-capitulo-7">Capítulo 7: Introdução às Arquiteturas de Sistemas Mobile</a></li>
        <li><a href="#modulo-4-capitulo-8">Capítulo 8: Arquiteturas Cloud Native e Serverless</a></li>
        <li><a href="#modulo-4-capitulo-9">Capítulo 9: Introdução às FaaS (AWS Lambda e Azure Functions)</a></li>
        <li><a href="#modulo-4-capitulo-10">Capítulo 10: Demonstração Prática da Arquitetura FaaS</a></li>
      </ul>
       
    </ul>
  </div>

  <div class="content">

    <h1>Arquitetura de software</h1>

    <!-- Conteúdo do módulo 1 -->
    <div id="modulo-1">
      <h2>Módulo 1: Fundamentos de Arquitetura de Software</h2>
      
      <div id="modulo-1-capitulo-0" class="capitulo">
        <h3>Capítulo 0: Visão Geral do Módulo</h3>
        <ul>
          <li>0.1. Apresentação</li>
          <li>0.2. Apresentação do Módulo</li>
        </ul>
      </div>
      
      <div id="modulo-1-capitulo-1" class="capitulo">
        <h2>Capítulo 1: Introdução à Arquitetura de Software</h2>
        <ul>
          <li><strong>1.1. Introdução à Arquitetura</strong></li>




            <p>Vamos falar um pouco sobre o que é arquitetura de software, proporcionando uma visão geral e um entendimento sobre essa disciplina e o conteúdo que será abordado.</p>
            <p>Mas vejam essa representação simplificada: acho que todo mundo aqui, mesmo sem gostar de futebol, já viu em algum momento uma transmissão em que aparece no início um desenho na tela mostrando o esquema tático do time. Algo como "o time vai jogar em 4-3-3" ou "o time vai jogar em 3-5-2". Esse desenho dentro de um campo de futebol indica a posição dos jogadores. Além disso, essa representação simplificada permite entender o estilo do time: se joga mais ofensivamente ou defensivamente.</p>
            <p>A arquitetura de software é algo semelhante. Criamos um desenho, uma representação simplificada, uma modelagem do que precisa ser feito para que o produto seja entregue no final. Quando olhamos um diagrama arquitetural, podemos visualizar o fluxo de dados, da mesma forma que no futebol vemos a sequência de uma jogada. Assim como um time tem 11 jogadores representados simbolicamente, uma arquitetura apresenta módulos, suas responsabilidades e atribuições.</p>
            <p>Arquitetura, então, é isso: a construção de uma representação simplificada, uma decomposição de alto nível, como um retrato falado do que precisa ser feito. Se um cliente chega e diz: "Quero um sistema que faça isso, isso e aquilo", o que você faz? Você representa, cria um modelo, uma referência, um desenho de alto nível para entregar esse produto.</p>
            <p>Um ponto importante: a representação inicial da arquitetura de software normalmente é de alto nível, ou seja, você não detalha tudo, apenas o essencial para aquele momento. Existe um princípio no Lean que diz que devemos postergar decisões sempre que possível. Em outras palavras, se não for necessário decidir algo agora, adie a decisão. Afinal, de hoje até a próxima semana, pode acontecer algo que mude a representação ideal.</p>
            <p>No início da arquitetura, algumas decisões precisam ser tomadas: será um sistema de entrega única ou incremental? Qual será a linguagem utilizada? Em certos momentos, pode ser necessário definir desde cedo se será usado Java e quais bibliotecas matemáticas farão parte do projeto.</p>
            <p>Resumindo, a arquitetura é uma representação de alto nível do sistema, incluindo decisões que, uma vez tomadas, não podem ser alteradas facilmente. Por exemplo, se você define a linguagem de programação no início do projeto, mudar depois de seis meses de desenvolvimento não será algo trivial e pode ser extremamente custoso.</p>
            <p>Na construção de uma arquitetura, é necessário criar um modelo ou abstração que atenda às características desejadas. Se um cliente pede um sistema para emergências, como incêndios, que deve responder rapidamente, a arquitetura precisará priorizar alto desempenho e resposta imediata. Assim, trabalhamos para modelar uma solução que garanta as características desejadas, como disponibilidade, escalabilidade, tolerância a falhas, desempenho, elasticidade, segurança e confiabilidade.</p>
            <p>As características arquiteturais estão diretamente relacionadas aos requisitos do sistema, principalmente os não funcionais. Por exemplo, um requisito de tempo de resposta está ligado ao desempenho, enquanto um requisito de autenticação por senha está relacionado à segurança.</p>
            <p>Na prática, tomar decisões arquiteturais nem sempre é simples. Muitas vezes, há trocas a serem feitas: um código mais limpo e enxuto pode ser mais eficiente, mas com menos camadas de segurança. O arquiteto precisa equilibrar esses fatores para criar uma solução que atenda aos requisitos iniciais.</p>
            <p>Quando falamos de arquitetura, lidamos com componentes e módulos. Esses componentes podem ser agrupados por funcionalidades ou por tecnologia, formando camadas, como as de regras de negócio e de visualização. Além disso, os componentes precisam se comunicar, o que envolve definir padrões como REST, gRPC, entre outros.</p>
            <p>Se estamos projetando um sistema que exige alta confiabilidade, podemos sugerir abordagens específicas de engenharia para garantir essa robustez. No entanto, tudo depende dos elementos centrais da arquitetura.</p>
            <p>Decisões arquiteturais são aquelas difíceis de mudar. Por exemplo, se no início optamos por uma arquitetura monolítica e depois precisamos migrar para microserviços, esse processo será demorado e caro. Por isso, essas decisões precisam ser bem planejadas desde o início.</p>
            <p>Outro ponto crucial: nem sempre tomamos a melhor decisão geral, mas sim a melhor decisão dentro dos recursos disponíveis. Se uma equipe só tem experiência com microserviços, pode ser mais viável seguir por esse caminho, mesmo que outra abordagem fosse tecnicamente superior.</p>
            <p>Chegamos, então, à reta final. O trabalho do arquiteto é construir um design de sistema. O cliente pode passar horas explicando o que deseja, e o papel do arquiteto é transformar essa informação em um modelo compreensível para os desenvolvedores. Se colocarmos o cliente para conversar diretamente com os programadores, pode haver uma desconexão, pois falam linguagens diferentes. O arquiteto atua como um intermediário técnico, traduzindo requisitos em um desenho que a equipe possa seguir.</p>
            <p>Por fim, arquitetos não reinventam a roda: utilizamos padrões já estabelecidos para tomar decisões mais seguras e eficientes.

       
            <P> O que é arquitetura de software? É uma modelagem do produto deve ser fito no final, o estudo do fluxo dos dados, especificação das atribuições dos módulos, composição de alto nível, um retrato do que deve ser construído, somente é detalhado o que é extremamente importante, não precisa adiantar uma decisão que não será feito hoje, pelo motivo de mudar a arquitetura, conclusão design do sistema, difícil de mudar e apoiada em padrões, baseado em padrões;</P>
            <p>Arquitetura de software, se refere à estrutura fundamental de um software. Cada estrutura compreende elementos do software, a relação entre eles e também suas propriedades. É de extrema importância pensar na arquitetura desde o primeiro dia da criação de um software, pois cada escolha tem um impacto, especialmente no crescimento do projeto. Escolhas erradas podem resultar em custos mais altos, lentidão nos processos e muito retrabalho.</p>
            <p>O termo "arquitetura de software" é relativamente novo. Seus princípios fundamentais começaram a ser aplicados esporadicamente pelos pioneiros da engenharia de software a partir da metade dos anos 80, mas seu uso mais generalizado só ocorreu a partir dos anos 90. No entanto, o conceito de arquitetura de software tem origem em pesquisas de Edsger Dijkstra em 1968 e de David Parnas no início dos anos 1990. Esses dois cientistas já sabiam que a estrutura de um software é fundamental e que implementar essa estrutura corretamente é essencial. Antes disso, era uma verdadeira bagunça—imagina só quanta gambiarra eles já viram por aí!</p>
            <p>Muita gente costuma confundir arquitetura de software com design de software, e isso é comum, sem problema algum. Apesar de haver uma interseção entre ambos, eles têm focos distintos: arquitetura de software trata de como os componentes de um sistema interagem entre si, enquanto design de software se concentra na implementação desses componentes, abordando detalhes como padrões de projeto, uso de algoritmos, estruturas de dados etc.</p>
            <p>A arquitetura de software está relacionada à estruturação de sistemas, incluindo a escolha de componentes tecnológicos e a definição de como eles interagem para formar um sistema coeso. Trata-se de decisões de alto nível que estabelecem a base do sistema, priorizando aspectos como escalabilidade, disponibilidade, confiabilidade, manutenibilidade, portabilidade e segurança.</p>
            <p>O principal objetivo da arquitetura de software é garantir que o sistema seja estruturado de forma a atender tanto os requisitos funcionais quanto os não funcionais. Além disso, ele deve ser fácil de manter e expandir ao longo do tempo.</p>
            
            <p><strong>Arquitetura de Software x Design de Código x Engenharia de Software</strong></p>
            <p> O design de código é frequentemente considerado parte da arquitetura de software, mas ele se concentra mais nos detalhes de implementação dos módulos e componentes do sistema. O design de código envolve a organização do código-fonte, escolha de padrões de codificação e uso de boas práticas, como design patterns.</p>
            <p> A qualidade do design de código afeta diretamente a legibilidade, reutilização e testabilidade do software. Por isso, a arquitetura e o design estão profundamente interligados. </p>
            <p> Já a engenharia de software é um conceito mais amplo, englobando tanto a arquitetura quanto o design de código. Ela abrange todo o processo de desenvolvimento de software, desde a concepção e definição de requisitos até a manutenção e evolução contínua do sistema. Entre suas práticas estão a gestão de projetos, análise de requisitos, desenvolvimento, testes e suporte. Agora que esclarecemos esses conceitos, vamos entender o que um arquiteto de software faz no dia a dia.</p>

            <p><strong>O Papel do Arquiteto de Software na Prática</strong></p>
            <p> Um bom arquiteto de software precisa ser, antes de tudo, um desenvolvedor experiente. Ele deve ter profundo conhecimento do código, mesmo que sua principal função não seja programar diariamente. Suas decisões arquiteturais impactam diretamente a implementação do código, e é comum que um arquiteto revise e refatore trechos para garantir sua conformidade com as diretrizes estabelecidas. </p>
            <p> Se você quer evoluir na carreira de desenvolvimento, estudar arquitetura de software é essencial. Conceitos como SOLID, DRY, YAGNI, orientação a objetos e práticas de DevOps são fundamentais para o crescimento profissional. Grandes projetos exigem uma cultura forte de testes e refatoração constante, e entender arquitetura é imprescindível para atuar com eficiência. </p>
            <p>Em times grandes, pode não haver um arquiteto formalmente designado. Nesses casos, esse papel pode ser assumido por um desenvolvedor sênior ou um tech lead. Ainda assim, todos os membros da equipe devem ter um bom entendimento sobre arquitetura para garantir o sucesso do projeto. </p>


            <p><strong>Responsabilidades do Arquiteto de Software:</strong></p>
            <ul>
              <li><strong>Definir a arquitetura e os padrões de codificação:</strong> garantindo que a estrutura do sistema atenda às necessidades do negócio e seja escalável.</li>
              <li><strong>Mentoria e orientação técnica:</strong> ajudando desenvolvedores a aprimorarem suas habilidades em padrões de design, melhores práticas e técnicas avançadas de programação.</li>
              <li><strong>Facilitar a colaboração entre equipes:</strong> promovendo alinhamento entre desenvolvedores, engenheiros, DevOps e stakeholders.</li>
              <li><strong>Conduzir revisões de código:</strong> assegurando que as implementações estejam de acordo com a arquitetura planejada. </li>
              <li><strong>Gerenciar riscos técnicos:</strong> identificando e mitigando problemas que possam afetar a qualidade e entrega do software.</li>
              <li><strong>Garantir a cobertura de testes:</strong> implementando testes de unidade, integração e desempenho para evitar regressões e problemas futuros.</li>
              <li><strong>Promover inovação:</strong> explorando novas tecnologias e metodologias para melhorar a eficiência do desenvolvimento. </li>
              <li><strong>Planejar e documentar o sistema:</strong> criando e atualizando documentações acessíveis, essenciais para a continuidade do projeto e integração de novos membros. </li>
            </ul>
            <p>O arquiteto de software desempenha um papel fundamental na concepção, evolução e manutenção dos sistemas. Suas decisões têm um impacto direto na qualidade do software e na eficiência da equipe, tornando essa posição uma das mais valorizadas e bem remuneradas no mercado de tecnologia.</p>
  
            
            <p><strong>Principais componentes da arquitetura:</strong></p>
            <ul>
              <li>Componentes do sistema;</li>
              <li>Camadas;</li>
              <li>Comunicação;</li>
              <li>Tecnologias;</li>
              <li>Práticas de desenvolvimento;</li>
            </ul>
            <p><strong>Decisões arquiteturais:</strong> </p>
              <ul>
                <li>Decisões estratégicas;</li>
                <li>Monólito</li>
                <li>Micro serviços</li>
                <li>Decisões de longo prazo; </li>
                <li>Mostram quais características estarão presentes ou ausentes na solução</li>
                <li>Impactada pela disponibilidade de recursos;</li>
              </ul>
          </p>
          <p>A arquitetura de software é fundamental para o desenvolvimento de sistemas robustos e escaláveis, neste capítulo exploramos três níveis principais.   A arquitetura de software que foca na estrutura interna dos sistemas e na organização dos componentes, para garantir desempenho e manutenibilidade. </p>
          <p>A arquitetura de soluções que trata da integração de múltiplos sistemas e aplicações dentro de uma organização para resolver problemas específicos.  A arquitetura corporativa que alinha a tecnologia, aos objetivos estratégicos de longo prazo da empresa. </p>
          <p>O arquiteto de softwares deve ter uma combinação de hard skills, como design patterns e clean cold e soft skills, como comunicação e liderança. Além disso, atua como um elo de comunicação entre diferentes equipes garantindo que as soluções atendam tanto as necessidades técnicas quanto empresariais.</p>

          <li><strong>1.2. Princípios Gerais de uma boa Arquitetura </strong></li>
            <p>Vamos dar sequência à nossa disciplina de Fundamentos de Arquitetura de Software. Nesta aula, falaremos sobre os princípios gerais aplicados para construir boas arquiteturas, garantindo sistemas e produtos de qualidade.</p>
            <p>Quais serão nossos tópicos? Vamos abordar alguns princípios fundamentais que devem ser utilizados. Embora essa seja uma aula teórica, talvez seja uma das mais importantes do curso. Esses conceitos básicos, quando bem aplicados, resultam em um produto de qualidade. Não significa que apenas isso seja suficiente, mas é o essencial.</p>
            <p>Falando sobre princípios, naturalmente, não trataremos de outra coisa senão princípios. Ao estabelecer uma arquitetura, alguns princípios gerais devem estar presentes. Por exemplo, modularizar os componentes é essencial. Quando falamos em modularização, significa que não construímos um sistema inteiro como um grande bloco, mas sim dividimos em pequenas partes que trabalham integradas. Cada módulo deve ter uma função específica. Se estamos desenvolvendo um sistema de compras online, teremos um módulo para pagamentos, outro para controle de pedidos e assim por diante. Esse conceito de "dividir para conquistar" é fundamental.</p>
            <p>Além de definir esses componentes, é essencial estabelecer as interfaces entre eles. Se um sistema possui cinco módulos, é necessário determinar claramente quais deles interagem entre si e como essa interação ocorre. Um módulo de pagamento, por exemplo, precisa se comunicar com o de pedidos, mas talvez não precise interagir diretamente com o de estoque. Essa interface deve ser bem definida, especificando métodos disponíveis, tipos de parâmetros e retornos esperados.</p>
            <p>Outro aspecto essencial é a escalabilidade. Inicialmente, um sistema pode atender um pequeno número de usuários, mas e se, em poucos meses, esse número aumentar para 5.000? A arquitetura precisa permitir expansão de forma eficiente. Quando estruturamos bem os módulos e interfaces, conseguimos maior flexibilidade para adaptações. Isso permite que mudanças sejam realizadas sem necessidade de alterar todo o sistema.</p>
            <p>A utilização de padrões também é um ponto-chave. A ideia não é reinventar soluções para problemas já resolvidos. Se já existem padrões eficientes validados pelo mercado, faz sentido utilizá-los em vez de tentar criar algo do zero. Soluções recorrentes devem ser aplicadas para garantir segurança e eficiência no desenvolvimento.</p>
            <p>Além dos princípios gerais, existem princípios específicos que se aplicam a diferentes contextos. Por exemplo, desenvolver um sistema de pagamento online é diferente de construir um software de gestão de estoque. No entanto, alguns princípios são universais e sempre aplicáveis.</p>
            <p>Entre esses princípios, destacamos o de responsabilidade única. Ele garante que cada elemento do sistema tenha uma função bem definida. Se uma classe no código está lidando com diferentes responsabilidades, talvez seja necessário dividi-la. Se a definição do nome de uma classe é difícil, pode ser um indicativo de que ela está abrangendo muitas funções diferentes.</p>
            <p>Outros princípios, como o de segregacão de interfaces, também são importantes para manter a clareza e manutenção do sistema. Construir componentes modulares e bem definidos facilita a evolução do sistema ao longo do tempo, permitindo a inclusão de novas funcionalidades sem grandes impactos.</p>
            <p>Outro aspecto relevante é o custo de oportunidade. Se um sistema possui vários módulos e um deles é uma inovação do produto, pode fazer sentido priorizar o desenvolvimento desse módulo primeiro. Se, por outro lado, existe um módulo que já tem soluções estabelecidas no mercado, talvez seja mais vantajoso utilizá-las e focar os esforços no diferencial do produto.</p>
            <p>Atrasos também devem ser considerados na priorização de entregas. Se uma nova legislação entrará em vigor no próximo ano e um módulo precisa estar em conformidade, ele deve ser priorizado para evitar problemas futuros.</p>
            <p>A ideia aqui não é decorar todos os princípios, mas compreender sua importância e aplicação. Devemos modularizar bem os sistemas, dividir componentes de forma lógica e definir interfaces claras para comunicação eficiente. O uso de princípios nos ajuda a manter o sistema escalável, flexível e de fácil manutenção.</p>
            <p>O desenvolvimento arquitetural deve sempre considerar padrões e soluções validadas, evitando a necessidade de criar tudo do zero. O uso de soluções recorrentes traz confiabilidade ao processo de desenvolvimento.</p>
            <p>Encerramos nossa aula sobre princípios, que são fundamentais para garantir qualidade na arquitetura de software. Na próxima aula, falaremos sobre o conceito de trade-offs e como eles impactam as decisões arquiteturais.</p>
            <p><strong> Princípios fundamentais </strong></p>
            <ul>
              <li>Modularidade:	É utilização de separação por módulos a divisão das suas responsabilidades;</li>
              <li>Separação de preocupações;</li>
              <li>Interfaces bem definidas: Validação da necessidade de um modulo de pagamento precisa ter comunicação com o módulo de estoque, é saber a necessidade dos processos;</li>
              <li>Escalabilidade; </li>
              <li>Flexibilidade e adaptação;  </li>
              <li>Uso de padrões; </li>
            </ul>

            <p><strong> SOLID   </strong></p>
            <ul>
              <li>Responsabilidade única: Garantir que um elemento faça o algo específico, regra com método especifico da classe; </li>
              <li>Open/Closed: Derivação das classes, quando posso criar novos métodos ou alterar; </li>
              <li>Liskov:  </li>
              <li>Segregação de interface: </li>
              <li>Inversão de dependência: </li>
            </ul>
      
            <p><strong> Outros   </strong></p>
            <ul>
              <li>Princípio da menor surpresa; </li>
              <li>Princípio do menos estorço (Lei de Zipf) </li>
              <li>Princípio do custo de oportunidade; </li>
              <li>Princípio do custo do atraso; </li>
            </ul>
            <p></p>

          <li><strong>1.3. Trade-Offs Arquiteturais</strong></li>
            <p>Basicamente, temos uma definição de trade-off: o ato de equilibrar ou fazer concessões entre dois ou mais atributos de qualidade e características do sistema. Mas para entender isso na prática, pensem em uma balança: se aumentamos um lado, o outro tende a cair. Esse equilíbrio é essencial para tomar decisões que envolvem características importantes.
            <p>Por exemplo, quero dirigir com rapidez e segurança. Quanto mais rápido eu dirijo, menos seguro fico, até certo limite. No contexto de sistemas, se quero aumentar muito o desempenho, talvez precise sacrificar um pouco de segurança. Se busco uma resposta extremamente rápida em um sistema, posso comprometer a proteção dos dados.
            <p><strong> Os trade-offs arquiteturais envolvem diversos atributos de qualidade, como:  </strong></p>
            <ul>
              <li> Confiabilidade</li>
              <li>Desempenho </li>
              <li>Segurança </li>
              <li>Estabilidade </li>
              <li>Elasticidade </li>
              <li>Agilidade </li>
              <li>Escalabilidade </li>
              <li>Disponibilidade </li>
            </ul>
            <p>Além disso, fatores como habilidades da equipe também afetam decisões. Por exemplo, se minha equipe só trabalha com determinada linguagem de programação, pode ser necessário equilibrar essa escolha com outras questões de segurança e eficiência.</p>
            <p> Exemplos de Trade-Offs Arquiteturais</p>
            <p> Monolito vs. Microserviços: Se optamos por microserviços, temos um software dividido em várias partes, muitas vezes distribuídas geograficamente. Isso pode afetar o desempenho, pois a comunicação não é local, mas ocorre através da rede. Se desempenho for um fator crítico, talvez um monolito seja mais adequado.</p>
            <p>Banco de Dados Relacional vs. NoSQ: Se escolhemos um banco de dados NoSQL, ganhamos flexibilidade para lidar com grandes volumes de dados diversos, mas sacrificamos estrutura e consistência transacional. Já um banco de dados relacional oferece maior consistência, mas pode não ser tão eficiente para consultas distribuídas e dados não estruturados.</p>
            <p> Sistema de Pagamento Online: Um cliente solicita um sistema de pagamento online, e precisamos equilibrar desempenho, segurança e interoperabilidade. Podemos armazenar dados de cartões em memória para acesso rápido, melhorando o desempenho, mas isso pode comprometer a segurança. Por outro lado, criptografar e adicionar autenticação multifator melhora a segurança, mas pode tornar o sistema mais lento.</p>
            <p>Interoperabilidade vs. Desempenho: Se um sistema precisa rodar em vários dispositivos e navegadores diferentes, podemos comprometer a eficiência. Uma solução altamente otimizada para um navegador específico pode ter melhor desempenho, mas ser menos compatível com outros ambientes.</p>
            <p>No dia a dia do arquiteto de software, as decisões envolvem balançar trade-offs para atender requisitos do cliente e restrições do projeto. Nem sempre escolheremos a solução tecnologicamente mais avançada, mas sim aquela que melhor equilibra qualidade, custo e prazo.</p>
            <p> Trade-off refere-se ao ato de equilibrar ou fazer concessões entre dois ou mais atributos de qualidade ou características de um sistema, onde a melhoria de um atributo geralmente leva à degradação de outro. Isso ocorre porque os recursos (como tempo, custo, desempenho, etc) são limitados e as decisões arquiteturais impactam múltiplos aspectos do sistema. </p>
 
        </ul>
      </div>
    
      <div id="modulo-1-capitulo-2" class="capitulo">
        <h2>Capítulo 2: O Profissional de Arquitetura de Software</h2>
        <P>Gerindo o processo de arquitetura, neste capitulo o foco está na gestão do processo de arquitetura. Um arquiteto precisa conhecer ferramentas como a matriz de decisão que ajuda a escolher em diferentes soluções e a análise de premissas e restrições, que garante que a arquitetura esteja de acordo com os limites do projeto. Além disso, frameworks como Hackman e o togas fornecem estruturas para desenvolver arquiteturas corporativas que atentam às necessidades de negócios. </P>
        
        <ul>
            <li><strong>2.1. Arquitetura de Software x Soluções x Corporativa </strong></li>
              <p>Nesta seção, exploraremos três pilares essenciais da engenharia de sistemas: arquitetura de software, arquitetura de soluções e arquitetura corporativa. A arquitetura de soluções expande esse conceito ao nível da integração de múltiplos sistemas, abordando como diferentes aplicações e serviços se conectam para resolver problemas específicos de negócios. Por fim, a arquitetura corporativa fornece uma visão holística e estratégica, alinhando a tecnologia com os objetivos empresariais e garantindo que todas as solu ções tecnológicas suportem a visão e as metas de longo prazo da organização. Juntos, esses níveis de arquitetu ra formam uma base sólida para a criação de sistemas eficientes, adaptáveis e alinhados com as necessidades dinâmicas do mercado. </p>
              
              <p><strong>  Arquitetura de Software  </strong></p>
              <p>A arquitetura de software se concentra na estrutura in terna e na organização dos componentes de um siste ma, garantindo que ele seja robusto, escalável e manu tenível. Esta área é a responsável pela organização da solução em um nível mais próximo do código e dos de senvolvedores. Algumas decisões e atividades que são responsabilidade deste profissional, por exemplo:</p>
              <ul>
                <li>Participação de revisões de código </li>
                <li>Direcionar a implantação de paradigmas de de senvolvimento (ex: TDD, BDD...) </li>
                <li>Desenvolver modelos e design de componen tes (diagrama de classes, componentes...) de arquiteturas para soluções específicas. </li>
                <li>Apoiar o processo decisório da equipe de de senvolvimento na construção de soluções es pecíficas. Os profissionais que atuam como arquiteto de softwares normalmente têm grande bagagem técnica e experiên cia profissional no contexto do desenvolvimento do sis tema, relativamente habitual termos desenvolvedores experientes que se tornaram arquitetos. Esses profissionais eventualmente atuam como respon sáveis técnicos ou tech lead, apoiando diretamente a equipe de desenvolvimento em dúvidas relacionadas à arquitetura emergente ao longo do projeto de construção da solução. </li>
              </ul>

              <p><strong> Arquitetura de Soluções   </strong></p>
              <p> Um arquiteto de soluções se concentra na integração de múltiplos sistemas e aplicações dentro de uma organização. Isso inclui definir como diferentes sistemas (por exemplo, ERP, CRM, e-commerce) se comunicam e trabalham juntos, utilizando middleware, APIs e outras tecnologias de integração para garantir que todas as partes funcionem de maneira coesa e eficiente. </p>
    
              <p><strong>Arquitetura Corporativa </strong> </p>
              <p> Um arquiteto corporativo é responsável por alinhar as estratégias de TI com os objetivos de negócios da organização. Isso envolve a criação de roadmaps tecnológicos, definição de políticas e padrões de arquitetura, e a garantia de que todas as iniciativas de TI suportem a visão e os objetivos de longo prazo da empresa, promovendo a agilidade e a inovação dentro da organização. Esse profissional normalmente tem uma atuação mais estratégica/gerencial e menos técnica</p>

            <li><strong>2.2. Soft e Hard Skills</strong></li>
              <p>Um arquiteto (a) de software deve ter habilidades (skills) diversas. Durante muito tempo valorizou-se apenas as skills técnicas relacionadas à área de arqui tetura de software, tais como modelagem. Contudo, cada vez mais o mercado demanda de um profissional que também tenha soft skills que vão permitir a este profissional ter habilidades comportamentais para li dar, influenciar, persuadir e conquistar o apoio dos mais diversos públicos relacionados a sua atividade.   </strong></p>
              <ul>
                <li>Programação Orientada a Objetos.</li>
                <li>SOLID </li>
                <li>Design Patterns </li>
                <li>DDD, BDD, TDD </li>
                <li>Clean Code </li>
                <li> </li>
              </ul>
              <p><strong>  Soft Skills  </strong></p>
              <p> Hard Skills São as habilidades técnicas adquiridas ao longo do tempo, sejam por processos educacionais, leitura de livros e artigos, estudo de novas tecnologias, experiên cia prática... Estas atividades normalmente podem ser medidas e comprovadas (ex: experiência profissional comprovada, certificados, diplomas...). São as habilidades relacionadas aos aspectos compor tamentais, que devem ser desenvolvidas ao longo do tempo e que normalmente não são comprovadas de forma quantitativa ou através de certificados, o que não quer dizer que não devam ser largamente estuda das. Dentre as principais soft skills esperadas de um arquiteto podemos citar: </p>
        
              <ul>
                <li>Inovação </li>
                <li>Comunicação </li>
                <li>Capacidade de Persuasão </li>
                <li>Capacidade de Influência </li>
                <li>Aprendizado contínuo </li>
                <li>Liderança </li>
              </ul>
              <p></p>



            <li><strong>2.3. Papel do Arquiteto</strong></li>
            <p> Nesta seção iremos estudar sobre diversas atividades e funções que devem ser desempenhadas por um arqui teto de software no dia a dia profissional. O que seria o Papel do Arquiteto? Um arquiteto de software é um profissional essencial no desenvolvimento de sistemas complexos, atuando como o responsável por definir a estrutura e os padrões de uma aplicação. Suas atividades incluem a criação de modelos de arquitetura, que descrevem a estrutura ge ral do sistema e detalham como seus componentes in teragem. Isso envolve escolher tecnologias adequadas, determinar a configuração de servidores e estabelecer padrões de codificação. Além disso, o arquiteto de sof tware deve garantir que a solução seja escalável, sus tentável e de fácil manutenção, considerando aspectos como desempenho, segurança e integração com outros sistemas. Outra função crucial do arquiteto de software é servir como um elo de comunicação entre diferentes equipes de desenvolvimento. Ele trabalha estreitamente com desenvolvedores, gerentes de projeto, analistas de ne gócios e outras partes interessadas para garantir que os requisitos técnicos e funcionais sejam compreendi dos e implementados corretamente. Isso pode envol ver a elaboração de documentação técnica detalhada, a realização de reuniões e workshops para alinhar expec tativas e resolver conflitos, além de orientar e revisar o trabalho das equipes de desenvolvimento para assegu rar a conformidade com os padrões estabelecidos. Além de suas responsabilidades técnicas e de comu nicação, o arquiteto de software também desempenha um papel estratégico dentro da organização. Ele contri bui para a visão de longo prazo da empresa, ajudando a definir a direção tecnológica e garantindo que as so luções arquitetônicas suportem os objetivos de negó cios. Isso inclui a avaliação e a adoção de novas tecno logias e tendências, a realização de análises de risco e a garantia de que a arquitetura proposta possa evoluir conforme as necessidades do mercado e da organiza ção mudem. Assim, o arquiteto de software não só ga rante a robustez e a eficiência dos sistemas atuais, mas também prepara a empresa para desafios futuros </p>
            
            <li><strong>2.4. A arquitetura dentro das grandes organizações</strong></li>
              <p> As principais atividades de um arquiteto de software abrangem uma ampla gama de responsabilidades téc nicas e de gestão. Essas atividades podem ser agrupa das em diversas categorias, citando algumas delas: </p>
                
              <p><strong> 1. Definição da Arquitetura do Sistema:   </strong></p>
              <ul>
                <li>Documentação Técnica: Criar e manter documen tação detalhada sobre a arquitetura do sistema, in cluindo diagramas, especificações e manuais de re ferência.</li>
                <li>Orientação e Mentoria: Fornecer orientação técnica e mentoria para os membros da equipe de desenvol vimento, ajudando a resolver problemas complexos e garantindo a adesão aos padrões arquitetônicos.  </li>
              </ul>

              <p><strong> 2. Coordenação e Comunicação:  </strong></p>
              <ul>
                <li>Análise e Avaliação de Riscos: Identificar potenciais riscos técnicos e de projeto, propondo soluções para mitigá-los e garantir a robustez do sistema.</li>
                <li>Adaptação e Evolução da Arquitetura: Monitorar novas tendências tecnológicas e incorporar inova ções relevantes à arquitetura existente para manter a competitividade e a eficiência do sistema.  </li>
                <li> Adaptação e Evolução da Arquitetura: Monitorar novas tendências tecnológicas e incorporar inova ções relevantes à arquitetura existente para manter a competitividade e a eficiência do sistema.  </li>
                <li>Revisão e Otimização do Desempenho: Realizar re visões periódicas do desempenho do sistema, identi f icando áreas para otimização e melhorias contínuas.  </li>
              </ul>    
              
              <p><strong> 3. Avaliação e Melhoria Contínua:   </strong></p>
              <ul>
                <li>Criação de Modelos Arquitetônicos: Desenvolver diagramas e modelos que representem a estrutura do sistema, detalhando como os componentes interagem entre si. </li>
                <li>Escolha de Tecnologias e Ferramentas: Selecionar as tecnologias e ferramentas adequadas para a implementação do sistema, considerando aspectos como escalabilidade, desempenho e manutenção. </li>
                <li>Definição de Padrões e Práticas: Estabelecer padrões de codificação, práticas de desenvolvimento e diretrizes que a equipe deve seguir para garantir a consistência e qualidade do software. </li>
              </ul>

              <p><strong>  4. Análise de trade-off e visibilidade:  </strong></p>
              <ul>
                <li>Colaboração com as Partes Interessadas: Trabalhar com desenvolvedores, gerentes de projeto, analistas de negócios e outras partes interessadas para entender os requisitos do projeto e garantir que a ar quitetura atenda às necessidades do negócio. </li>
                <li>Análise de trade-off: Ato de escolher alguma coisa em detrimento de outra e vai consistir em uma análise de pontos positivos e negativos de cada uma das escolhas que faremos. Isto significa ba sicamente que escolhendo uma opção estaremos carregando os pontos negativos e positivos dela e estaremos perdendo os pontos positivos e negati vos da outra opção. Na engenharia de software existe um método que ajuda nesse processo de decisão, o ATAM (Architecture Tradeo f f Analysis Method). Seu objetivo é ajudar a escolher uma arquitetura adequada para um sistema de software, des cobrindo compensações e pontos de sensibilidade. </li>
                <li>Apresentar ATAM – Apresentar o conceito de ATAM aos stakeholders e esclarecer dúvidas sobre o processo.  </li>
                <ul>
                  <li>Representantes da área de negócio – todos no processo apresentam e avaliam os motivadores de negócios para o sistema em questão. </li>
                  <li>Apresente a arquitetura - o arquiteto apresenta a arquitetura de alto nível para a equipe, com um ‘nível de detalhe apropriado’  </li>
                  <li>Identifique as abordagens arquitetônicas – dife rentes abordagens arquitetônicas do sistema são apresentadas pela equipe e discutidas. </li>
                  <li>Gerar árvore de utilitários de atributos de qua lidade - definir o negócio principal e os requisitos técnicos do sistema e mapeá-los para uma pro priedade arquitetônica apropriada. Apresente um cenário para este determinado requisito. • Análise das abordagens arquitetônicas – anali se cada cenário, classificando-os por prioridade. A arquitetura é então avaliada em relação a cada cenário.  </li>
                  <li>Faça um brainstorming e priorize cenários – en tre o grupo maior de partes interessadas, apresen te os cenários atuais e expanda. </li>
                  <li>Analise as abordagens arquitetônicas – execute a etapa 6 novamente com o conhecimento agre gado da comunidade mais ampla de partes inte ressadas. </li>
                  <li>Apresentar resultados – fornece toda a documen tação às partes interessadas. Durante todo o processo do ATAM, as soluções encon tradas serão sabatinadas e analisada a viabilidade, até que se defina o modelo arquitetural do projeto.  </li>
                </ul>
              </ul>
              <p><strong> 5. Liderança técnica:   </strong></p>
              <ul>
                <li> Direcionar as equipes de desenvolvimento na esco lha, especificação e implantação de tecnologias, as sim como a definição e evolução de padrões de de senvolvimento. Poderíamos citar diversas outras atividades (ex: mo nitoração, prototipação....), o grande ponto no mo mento é compreender que as hard e soft skills com binadas ajudam o arquiteto a desempenhar suas funções com excelência </li>
              </ul>
        </ul>
      </div>
    
      <div id="modulo-1-capitulo-3" class="capitulo">
        <h2>Capítulo 3: Arquitetura de Software Moderna</h2>
        <p>Governança da arquitetura, a governança da arquitetura envolve garantir que as soluções arquiteturais estejam sendo implementadas corretamente e que as decisões sigam padrões estabelecidos. O arquiteto deve garantir a conformidade das soluções através de revisões periódicas e assegurar que as decisões sejam documentadas adequadamente, contribuindo para a evolução da arquitetura. </p>
        
        
        <ul>
          <li><strong>3.1. Arquitetura Intencional</strong></li>
            <p> Se estamos falando de Arquitetura de Software Moderna, já conseguimos imaginar que essa arquitetura mudou ao longo do tempo, e é justamente sobre isso que vamos abordar neste capítulo, voltada principalmente ao conceito de Arquitetura Intencional.</p>
            <p> Quando vocês vão projetar um sistema, criam um desenho ou um diagrama de componentes para mapear os módulos do sistema. Por exemplo, ao utilizar UML, temos diferentes tipos de modelagem: comportamental, estrutural, diagrama de caso de uso, diagrama de classe, diagrama de componente, entre outros. Esses diagramas são criados antes do desenvolvimento do software. A Arquitetura Intencional trata exatamente dessas decisões e determinações tomadas antes do início do desenvolvimento.</p>
            <p> Ao iniciar um novo sistema, como um sistema de pagamentos online, a primeira coisa a determinar é a forma de distribuição do sistema: será monolítico, microserviços ou serverless? Como serão as conexões? A Arquitetura Intencional envolve essas grandes decisões arquiteturais tomadas antes do desenvolvimento.</p>
            <p> Esse conceito enfatiza a importância de decisões arquiteturais deliberadas e conscientes, alinhadas aos objetivos do negócio. A partir dos requisitos, tomamos decisões que impactam todo o desenvolvimento. A Arquitetura Intencional é uma representação de alto nível do sistema e não define todos os detalhes, mas cria uma visão clara para que a equipe de desenvolvimento tenha um direcionamento. </p>
            <p> Uma boa Arquitetura Intencional se baseia em padrões previamente utilizados para replicar boas decisões. O ideal é criar arquiteturas adaptáveis e flexíveis. Como conseguimos isso? Aplicando princípios fundamentais, como modularização, separação de responsabilidades e interfaces bem definidas. Devemos maximizar a comunicação dentro de cada módulo e minimizar a comunicação entre módulos. </p>
            <p> Seguindo essa abordagem, criamos uma boa Arquitetura Intencional, o que reduz riscos e garante que decisões essenciais sejam tomadas no início do processo. Isso facilita a vida da equipe de desenvolvimento, que não precisa perder tempo decidindo como construir o software, apenas seguir um plano bem definido. Com foco na qualidade, a satisfação do cliente também aumenta. </p>
            <p> No ciclo de vida clássico do desenvolvimento de software, como o modelo Waterfall (cascata), a Arquitetura Intencional se concentra nas fases iniciais. Baseando-se nas necessidades do cliente, criamos uma representação que serve como referência para a equipe de desenvolvimento. </p>
            <p> No passado, a Arquitetura Intencional era o principal foco do arquiteto, mas hoje isso mudou. O trabalho do arquiteto continua ao longo de todo o processo de desenvolvimento, teste e implantação. Portanto, a Arquitetura Intencional é essencial, mas não é a única disciplina do trabalho arquitetural. </p>
            <p> Em resumo, a Arquitetura Intencional trata do design inicial do sistema. Uma boa análise e planejamento no início evitam problemas futuros. Para isso, utilizamos padrões consolidados, tomamos decisões embasadas e documentamos bem todo o processo. Essa documentação é essencial para garantir que a equipe de desenvolvimento tenha uma referência confiável. </p>
            <p> Arquiteturas Intencionais englobam decisões estruturais que são difíceis de mudar ao longo do tempo. No modelo tradicional, o arquiteto projetava e entregava para o desenvolvimento, sem mais envolvimento. Hoje, essa abordagem mudou. O arquiteto precisa acompanhar todo o ciclo de vida do software, garantindo que a arquitetura continue alinhada aos objetivos do negócio.</p>
            <p> É a visão inicial determinando o fluxo do início do sistema, são as ideias gerais do sistema, análise de requisitos e projeto, é composta pelas decisões estruturais antes do desenvolvimento do sistema, conceito que enfatiza a importância de tomar decisões arquiteturais e conscientes, com o objetivo de alinhar a arquitetura do sistema com os objetivos e requisitos do negócio.  </p>
            <p>Visão clara e compartilhada;</p>
            <ul>
              <li>Foco em qualidade; </li>
              <li>	Uso de padrões e melhores práticas; </li>
              <li>Adaptabilidade e flexibilidade; </li>
            </ul>
            <p> Importância arquitetura intencional </p>
            <ul>
              <li> Redução de riscos </li>
              <li> Eficiência no desenvolvimento  </li>
              <li>Satisfação do cliente </li>
            </ul>
            <p></p>

          <li><strong>3.2. Engenharia de Software Ágil</strong></li>

            <p>É importante lembrar do Manifesto Ágil, criado por volta dos anos 2000 e 2001. Foram cerca de 20 signatários que se reuniram e chegaram a um consenso: desenvolver software não é a mesma coisa que construir um prédio. Sendo assim, projetos de software devem ser conduzidos de maneira diferente de outros tipos de projetos. Eles estabeleceram valores e princípios para guiar esse processo.</p>
            <p>Não vamos passar por tudo isso agora, mas, por exemplo, independentemente do modelo que você adote, é fundamental entender que: devemos valorizar mais os indivíduos e as interações do que os processos e as ferramentas. Trazendo isso para o contexto da engenharia e arquitetura de software, o que isso quer dizer? Antes de pensar apenas em ferramentas para melhorar a qualidade do código da sua equipe, talvez seja mais interessante desenvolver as habilidades e capacidades das pessoas que produzem esse código.</p>
            <p>O Manifesto Ágil representou uma ruptura na forma como os projetos de software eram conduzidos. Antes, o planejamento era rígido e linear: criava-se um cronograma do início ao fim e ele era seguido à risca, com a entrega final acontecendo apenas no final do projeto. O Manifesto Ágil trouxe uma nova abordagem: ciclos curtos de trabalho, nos quais pequenas partes do sistema são entregues continuamente.</p>
            <p>Ao invés de passar meses desenvolvendo um sistema para só então entregá-lo ao cliente, agora trabalhamos de forma iterativa. A cada ciclo (que pode ser, por exemplo, de um mês), uma parte funcional do produto é entregue. O cliente dá seu feedback, que é incorporado nas próximas iterações. Assim, evitamos grandes desperdícios de tempo e dinheiro, pois qualquer necessidade de mudança é identificada rapidamente.</p>
            <p>Esse conceito está representado no esquema visual ao lado: primeiro, entregamos a essência do produto, garantindo que ele já tenha valor para o cliente. Depois, aprimoramos continuamente, adicionando novos recursos e melhorando a experiência. Isso transformou completamente o processo de engenharia de software, tornando-o mais dinâmico e adaptável.</p>
            <p>Hoje, a maior parte das empresas trabalha com ciclos de entrega contínuos, muitas vezes de dois em dois meses. Se algo não agradar ao cliente, rapidamente podemos ajustar e adaptar. Essa abordagem evolutiva tornou o conceito de MVP (Minimum Viable Product) essencial: primeiro criamos uma versão simples, testamos no mercado e, só depois de validar a ideia, aprofundamos o desenvolvimento.</p>
            <p>Essa mudança na engenharia impactou diretamente a arquitetura de software. Antes, a arquitetura intencional era predominante: todas as decisões arquiteturais eram tomadas antes do início do desenvolvimento. Agora, a abordagem é mais flexível: tomamos algumas decisões iniciais, mas deixamos outras para serem ajustadas ao longo do projeto, conforme recebemos feedback.</p>
            <p>Isso significa que modularizar o sistema tornou-se ainda mais essencial. Precisamos estruturar nossos módulos de forma inteligente, garantindo alta coesão e baixo acoplamento. Quanto mais independentes forem os módulos, mais fácil será adaptar </p>
            <p>No esquema visual ao lado, podemos observar dois cenários: no primeiro, os módulos se comunicam de forma controlada e eficiente; no segundo, todos os módulos se comunicam indiscriminadamente. O segundo cenário não é ideal, pois um alto nível de comunicação entre módulos pode comprometer o desempenho e dificultar a manutenção. O ideal é maximizar a comunicação dentro dos módulos e minimizar a comunicação entre módulos.</p>
            <li><strong>Portanto, os impactos da engenharia ágil na arquitetura de software são claros:</strong></li>
            <ul>
              <li>Os produtos são mais modularizados. </li>
              <li>A arquitetura intencional se tornou menos rígida. </li>
              <li> A necessidade de arquiteturas flexíveis e adaptáveis aumentou. </li>
              <li>Mudanças contínuas e incrementais fazem parte do processo. </li>
              <li>Interfaces bem definidas são essenciais para garantir a evolução do sistema sem comprometer sua integridade. </li>
              <li> Por fim, um dos grandes aprendizados da agilidade é abraçar as mudanças. A mudança não é um problema, mas sim uma oportunidade de aprimorar o produto. Dessa forma, a arquitetura também precisa ser flexível e adaptável, permitindo evolução contínua ao longo do tempo. </li>
            </ul>
            <li><strong>Manifesto Ágil:</strong></li>
            <ul>
              <li>Princípios e Valores, indivíduos e interações, software em funcionamento, responder a mudanças, colaboração com o cliente; </li>
              <li>Não trabalha com planejamento total se trabalha em pequenos ciclos; </li>
              <li>Características métodos ágeis:  Ciclos de entrega, incremental, adaptável, evolutivo; </li>
              <li>Impactos na arquitetura de software: Menor intencionalidade, modulação, necessidade de flexibilidade, necessidade de sustentação, interfaces; </li>
            </ul>
            <p></p>
 
          <li><strong>3.3. Arquitetura Evolutiva</strong></li>

            <p>Na disciplina Fundamentos de Arquitetura de Software, agora, vamos falar sobre arquitetura de software evolutiva.</p>
            <p>Primeiro ponto: acho que vale a pena a gente destacar um conceito muito presente na literatura, o conceito de arquitetura evolutiva. Para nós, aqui, ele será simbolicamente o mesmo conceito do que estamos chamando de arquitetura evolutiva. Podemos entender que ambas se referem a uma arquitetura que, inicialmente, é representada, mas, com o tempo, ela vai evoluindo, se adaptando. Vamos explorar alguns conceitos dessa aula, como o conceito de "big design upfront" (BDUF), especificar o que é arquitetura evolutiva e falar um pouco sobre as características inerentes à arquitetura evolutiva.</p>
            <p>O que acontece é o seguinte: basicamente, temos dois tipos de arquitetura. A primeira é a arquitetura que é planejada antes do projeto, e a segunda é a arquitetura que se desenvolve ao longo de todo o processo de desenvolvimento. A arquitetura planejada no início é chamada de arquitetura intencional, enquanto a arquitetura que se desenvolve ao longo do projeto é chamada de arquitetura emergente. Quando falamos de BDUF, não estamos trabalhando com arquitetura emergente, mas sim com uma arquitetura intensamente intencional, ou seja, definindo tudo desde o início do projeto. O problema disso é que, como vimos, não conseguimos prever tudo no começo. Assim, você vai fazer um trabalho inicial pesado, com muitas decisões tomadas logo de cara, mas depois terá um alto custo de mudança ao longo do tempo para garantir que o que você entrega ao cliente esteja alinhado com o que ele espera. Esse trabalho inicial, que depois vai gerar custos de mudança, é um problema. No contexto de sistemas críticos, como por exemplo, sistemas embarcados ou de controle de voo, pode até fazer sentido definir tudo desde o início. No entanto, para produtos como um aplicativo de banco digital, que evolui ao longo do tempo, o melhor é adotar uma arquitetura evolutiva.</p>
            <p>Então, como garantir que uma arquitetura intencional aceite a evolução ao longo do tempo? A resposta está em construir uma arquitetura geral do sistema, que seja composta por decisões arquiteturais intencionais e emergentes. A ideia é permitir que a arquitetura evolua, mas de forma controlada. Nesse sentido, utilizamos o conceito de arquitetura evolutiva: um projeto de arquitetura de software que é flexível e acomoda mudanças de forma contínua e incremental.</p>
            <p>Quando trabalhamos com arquitetura evolutiva, devemos adotar algumas práticas, como o design incremental e modular, especificando quais módulos serão trabalhados e minimizando a comunicação entre eles. O objetivo é reduzir ao máximo o impacto da complexidade e do débito técnico, entregando o sistema de forma iterativa, em ciclos. A cada entrega, podemos refinar o código e corrigir problemas técnicos, mantendo o foco em entregas satisfatórias para o cliente, e não perfeitas de início. Isso implica que o débito técnico será algo a ser gerido ao longo do tempo, mas que também pode ser uma oportunidade de aprimorar a qualidade.</p>
            <p>As vantagens de adotar uma arquitetura evolutiva são muitas. Primeiramente, ela permite que a arquitetura se adapte às mudanças do contexto, respondendo rapidamente às necessidades emergentes. Além disso, ela possibilita uma maior valorização da interação entre os componentes e uma entrega incremental, com foco no desenvolvimento de funcionalidades de forma interativa, reduzindo o risco de mudanças imprevistas.</p>
            <p>Com a arquitetura evolutiva, a equipe de desenvolvimento pode ser mais ágil, pois as mudanças são localizadas e as falhas são mais fáceis de corrigir. A arquitetura se torna resiliente, pois é composta por módulos independentes, e um erro em um módulo não comprometerá o sistema como um todo. Além disso, o processo de modernização e evolução da arquitetura é facilitado, já que você pode entregar aos poucos e ajustar o design conforme o projeto avança.</p>
            <p>Em resumo, para implementar uma arquitetura evolutiva de sucesso, é essencial adotar uma abordagem de modularização, focar em coesão dentro dos módulos e minimizar o acoplamento entre eles. Isso, combinado com uma boa definição de interfaces e a utilização de conceitos exploratórios, garante que a arquitetura evolua de forma eficient.e O débito técnico, se bem gerido, pode se tornar uma ferramenta útil, pois permite entregar versões funcionais e satisfatórias para o cliente, enquanto o refinamento ocorre ao longo do tempo.</p>
            <p>Esses são os conceitos e práticas que fazem a arquitetura evolutiva ser uma estratégia eficaz, especialmente em um contexto de desenvolvimento ágil e produtos que precisam evoluir de forma contínua.
            <p>Definição do projeto arquitetura de software voltada para ser flexível e acomodar mudanças de forma contínua e incremental. Escopos pequenos e modularizando com o tempo, não faz o melhor código de primeira, faz conforme o teste e feedback do cliente.</p>
            <ul>
              <li>Design incremental; </li>
              <li>Modularidade </li>
              <li>Iteratividade </li>
              <li>Refatoração contínua;  </li>
              <li>Gestão de débitos técnicos; </li>
              <li>Uso de conceitos exploratórios; </li>
            </ul>
            <p>BDUF - É você tomar muitas decisões no início do seu projeto, o problema disso é fazer muito trabalho no início vai ter determinado muitas coisas e depois você vai ter um alto custo de mudanças ao longo do tempo para garantir que isso aqui, que o que você vai entregar para o cliente seja associado ao que o cliente espera.</p>
            <ul>
              <li>Desalinhamento projeto X executado; </li>
              <li>	Surgimento de Bugs; </li>
              <li>Documentação desatualizada; </li>
              <li> Desperdício;</li>
              <li> 	Custo de mudanças;</li>
            </ul>
            <p>Exemplo de uso: Software embargado para um avião ou maquina, neste caso todas as especificações são obrigatórias;</p>
          
          <li><strong>3.4. Arquitetura Emergente</strong></li>

            <p>Dando sequência à nossa disciplina Fundamentos de Arquitetura de Software, abordando arquitetura de software moderna. A ênfase aqui não é só na arquitetura intencional, que vimos anteriormente, mas também na arquitetura que vamos desenvolver ao longo do processo de desenvolvimento. É sobre essa arquitetura que quero falar com vocês nesta aula: arquitetura de software emergente.</p>
            <p>Vamos entender um pouco esse conceito de arquitetura de software emergente. Nesta aula, falaremos sobre como ela funciona, os princípios dessa arquitetura, algumas práticas, desafios e, ao final, vamos concluir a respeito desse tema.</p>
            <p>Se pegarmos a definição literária, a arquitetura emergente é a estrutura de um sistema que evolui de forma orgânica, a partir das decisões de design que são tomadas ao longo do desenvolvimento, baseadas em feedbacks e aprendizado constante.</p>
            <p>Agora, vamos conversar sobre isso. A arquitetura emergente é o oposto da arquitetura intencional, onde o arquiteto toma decisões centralizadas antes de começar o desenvolvimento. Na arquitetura emergente, as decisões são tomadas pela equipe de desenvolvimento ao longo do processo. Ou seja, ao invés de planejar tudo de uma vez, as decisões vão surgindo conforme os problemas vão sendo encontrados. Por exemplo, na arquitetura intencional, você poderia decidir usar uma linguagem como Java desde o início, mas no processo de desenvolvimento, ao identificar problemas, pode ser necessário mudar para uma biblioteca diferente. Esse tipo de decisão também faz parte da arquitetura. O arquiteto ainda participa, mas o processo é mais colaborativo, com a equipe tomando decisões conforme o desenvolvimento avança.</p>
            <p>Então, quais são as características dessa arquitetura que vai surgindo ao longo do caminho? Como estamos entregando software de forma interativa e incremental, o planejamento deve ser constante e evolutivo. Em vez de grandes decisões arquiteturais, buscamos soluções menores e mais simples, de forma contínua. A equipe de desenvolvimento participa ativamente da tomada dessas decisões.</p>
            <p>Muitas vezes, a equipe pode decidir o caminho a seguir. Por exemplo, se uma equipe tem dois membros com 15 anos de experiência em um produto específico, eles podem sugerir soluções mais eficazes do que o arquiteto, que não tem tanta experiência prática. O arquiteto pode guiar o processo, mas não é o único responsável pelas decisões. A utilização de padrões e práticas consolidadas, como o DDD (Domain-Driven Design), também ajuda a melhorar a qualidade do código, permitindo que a equipe corrija problemas e aumente a qualidade ao longo do tempo.</p>
            <p>Uma prática muito importante para a arquitetura emergente é a arquitetura modular, que já discutimos anteriormente. A arquitetura modular envolve princípios como alta coesão, baixo acoplamento e segregação de responsabilidades. Essas práticas são fundamentais para que o sistema seja flexível e capaz de evoluir conforme as necessidades do projeto.</p>
            <p>Agora, para fechar, vamos representar a arquitetura de um sistema. Essa arquitetura será composta por duas partes: a arquitetura intencional e a arquitetura emergente. O que buscamos aqui é garantir que essa arquitetura como um todo seja evolutiva. Ao trabalhar com modularização, segregação de responsabilidades e mantendo alta coesão e baixo acoplamento, conseguimos garantir que o sistema evolua de forma eficiente.</p>
            <p>Sempre será necessário equilibrar a quantidade de arquitetura intencional com a de arquitetura emergente. Se você está desenvolvendo um sistema crítico, a arquitetura intencional será mais predominante. Porém, em sistemas novos ou produtos em constante evolução, a arquitetura emergente será mais relevante. Essa linha vai variar conforme o contexto, e entender quando tomar decisões intencionais e quando deixar a equipe decidir ao longo do processo é essencial.</p>
            <p>Em resumo, a arquitetura de software evolutiva depende do equilíbrio entre as duas abordagens. Não existe uma regra rígida, mas é importante saber quando aplicar mais de uma e como balanceá-las conforme o contexto. A ideia é construir uma arquitetura que seja adaptável e capaz de evoluir ao longo do tempo.</p>
            <p>Então, pessoal, o importante é entender que tanto a arquitetura intencional quanto a emergente têm seu papel no desenvolvimento de software. À medida que o projeto avança, você vai aplicando uma ou outra conforme as necessidades surgem. Com isso, fechamos este capítulo. No próximo, vamos falar um pouco sobre tendências atuais e entrar nas questões dos rádios, que são extremamente importantes para o seu aprendizado.</p>
            <p>É a estrutura de um sistema que evolui organicamente a partir de práticas e decisões de design contínuas, baseadas em feedback e aprendizado constante ao longo do ciclo de desenvolvimento. Resumindo os problemas que vão surgindo no meio do caminho, a equipe toma decisões junto com o arquiteto;</p>
            <ul>
              <li>Iteratividade e incrementalidade; </li>
              <li>Design simples;  </li>
              <li>Influenciada pela equipe;</li>
              <li>Decisões não centralizadas; </li>
              <li>Uso de padrões; </li>
            </ul>
            <p> <strong> associadas:</strong> </p>
              <ul>
                <li>TDD, BDD; </li>
                <li>Programação em PAR; </li>
                <li>Continous integration; </li>
                <li>Refatoração;  </li>
                <li>Arquitetura modular; </li>
              </ul>
            <p> <strong>Desafios: </strong></p>
            <ul>
              <li> Tomada de decisões coletivas;</li>
              <li> Experiência profissional; </li>
              <li> Conhecimento de padrões; </li>
              <li> Liderança técnica;</li>
              <li> Soft skill’s;</li>
              <li> </li>
            </ul>
            <p> Arquitetura tradicional/convencional: define a estrutura do sistema do início do projeto, com pouca flexibilidade para mudanças.
              Arquitetura emergente: evolui a estrutura do sistema de forma incremental e adaptativa, permitindo mudanças contínuas e respondendo ao feedback;
              Resumo - Foca na conformidade e documentação das soluções, com revisões periódicas para garantir padrões e evolução arquitetural.
            </p>
        </ul>
      </div>
    
      <div id="modulo-1-capitulo-4" class="capitulo">
        <h2>Capítulo 4: Estilos Arquiteturais Monolíticos</h2>
        <p>Evoluções e tendências da arquitetura, neste capitulo o foco é na evolução da arquitetura e nas novas tendências tecnológicas. O arquiteto de software precisa estar atendo às mudanças e inovações para adaptar e melhorar as soluções atuais. Isso inclui a adoção de práticas como DevOps, cloud computing e arquiteturas evolutivas que são essenciais para manter a competividade e atender as demandas dinâmicas do mercado. </p>
        <ul>
          <li><strong>4.1. Conceitos Gerais</strong></li>

          <p><strong>Estilos arquiteturais:</strong></p>
          <ul>
            <li>Design patterns de alto nível; </li>
            <li>Estrutura ou organização geral para um sistema de software; </li>
            <li>Integração entre componente do sistema e com o ambiente externo; </li>
            <li>Componentes </li>
            <li>Conectores </li>
            <li>Configuração/Topologia;  </li>
            <li>Princípios e restrições  </li>
          </ul>


          <p><strong> Importancia: Estilos arquiteturais   </strong></p>
          <ul>
            <li>Reutilização </li>
            <li>Comunicação eficiente </li>
            <li>Facilidade de manutenção e evolução; </li>
            <li>Melhoria da qualidade de software; </li>
          </ul>

          <p><strong> Critérios de comparação: Estilos arquiteturais   </strong></p>
          <ul>
            <li>	Centralização ou distribuição; </li>
            <li> 	Entrega única ou incremental;</li>
            <li> Características arquiteturais;</li>
            <li> 	Skills Equipe;  </li>
          </ul>
          </br>

          
          <li><strong>4.2. Arquitetura em Camadas</strong></li>
            <p><strong>Monolítico </strong> </p>
            <p> É uma arquitetura que você entrega ele para o cliente, através de um deployment único e esse é o conceito literário; 
              Arquitetura em camada, o estilo arquitetural em camada organiza o sistema em níveis distintos, onde cada camada tem uma responsabilidade específica e interage om as camadas adjacentes de forma controlada; </p>
            
              <p><strong> Camadas comuns:   </strong></p>
              <ul>
                <li>Camada de apresentação UI; </li>
                <li>Camada de aplicação/negócio;</li>
                <li>Camada de serviços/integração; </li>
                <li>Camada de persistência/dados; </li>
              </ul>
              
              <p><strong>Vantagens:    </strong></p>
              <ul>
                <li>Separação de responsabilidades; </li>
                <li>Simplicidade;  </li>
                <li>Desenvolvimento paralelo; </li>
                <li>	Independência entre camadas; </li>
                <li>	Reutilização;  </li>
        
              </ul>
    
              <p><strong>Desvantagens:    </strong></p>
              <ul>
                <li>Comunicação </li>
                <li>Desempenho </li>
                <li>Disponibilidade </li>
                <li>Escalabilidade </li>
                <li>Evolução </li>
              </ul>

              <p><strong>Boas práticas:    </strong></p>
              <ul>
                <li>Definição clara de interfaces;  </li>
                <li>Adaptação a realidade do projeto; </li>
                <li>Subdivisão de camadas; </li>
              </ul>
            </br>

          <li><strong>4.3. Arquitetura Pipeline</strong></li>
            <p> Organiza o processamento de dados ou tarefas em uma sequência de estágios, onde cada estágio realiza uma operação específica e passa o resultado para o próximo estágio; </p>
            <p><strong>Estrutura:    </strong></p>
              <ul>
                <li> Pipes</li>
                <li>Filters </li>
              </ul>
              <p> Exemplo: Compiladores, processamento de dados, processamento de imagens; </p>
            
              <p><strong> Vantagens:   </strong></p>
              <ul>
                <li>Separação de responsabilidades; </li>
                <li>Reutilização; </li>
                <li>Escalabilidade; </li>
                <li>Desempenho; </li>
              </ul>
              <p><strong> Desvantagens:   </strong></p>
              <ul>
                <li>Dependência sequencial; </li>
                <li>Dificuldade na reversão; </li>
                <li>Manutenção da integração; </li>
                <li>Evolução funcional;  </li>
                <li>Flexibilidade; </li>
              </ul>
              <p><strong> Boas práticas:    </strong></p>
              <ul>
                <li>Definição clara de interfaces; </li>
                <li>Minimizar acoplamento; </li>
                <li>Monitoramento e logs; </li>
              </ul>
            </br>

          <li><strong>4.4. Arquitetura Microkernel</strong></li>
            <p> Também conhecida como Plug-in, é um estilo onde o sistema central (Microkernel) fornece funcionalidades mínimas e essenciais, enquanto as funcionalidades adicionais são implementadas como módulos ou plug-in que podem ser acoplados ou desacoplados conforme necessário. </p>
            
            <p><strong>Estrutura:    </strong></p>
            <ul>
              <li>Core/Kernel; </li>
              <li>Plug-ins; </li>
              <li>Exemplos: Navegadores, IDEs; </li>
            </ul>
            
            <p><strong>Vantagens    </strong></p>
            <ul>
              <li>Extensibilidade; </li>
              <li>Robustez e estabilidade; </li>
              <li>Disponibilidade;  </li>
              <li>Simplicidade;  </li>
              <li>Evolução funcional;  </li>
            </ul>

            <p><strong> Desvantagens:   </strong></p>
            <ul>
              <li> Dificuldade de integração; </li>
              <li> Sobrecarga devido a comunicação;</li>
              <li> Gerenciamento de plug-in;</li>
              <li> Ponto central;</li>
              <li>Teste de integração;  </li>
            </ul>

            <p><strong>  Boas práticas:  </strong></p>
            <ul>
              <li>Design do núcleo;  </li>
              <li> Design plug-in;</li>
              <li>Ampla cobertura de teste; </li>
            </ul>
        </ul>
      </div>
      
      <div id="modulo-1-capitulo-5" class="capitulo">
        <h2>Capítulo 5: Estilos Arquiteturais Distribuídos</h2>
        <ul>
          <li><strong>5.1. Conceitos Gerais</strong></li>
          <p>Arquiteturas utilizadas para projetar e implementar sistemas em que os componentes estão distribuídos em diferentes nós de uma rede. A distribuição dos componentes pode ocorrer por várias razões, como escalabilidade, resiliência, alta disponibilidade ou par aproveitar recursos geograficamente distribuídos; </p>
          <p><strong> Características:  </strong></p>
          <ul>
            <li>Distribuição de componentes; </li>
            <li>Descentralização;</li>
            <li>Comunicação de componentes; </li>
            <li>Tolerância a falhas; </li>
            <li>Escalabilidade;</li>
            <li>Heterogeneidade;  </li>
          </ul>
          <p><strong> Desafios:   </strong></p>
          <ul>
            <li>Segurança;</li>
            <li>Latência e desempenho;</li>
            <li>Coordenação e sincronização; </li>
            <li>Complexidade operacional; </li>
            <li>Escalabilidade e balanceamento de carga; </li>
          </ul>
          <p><strong>Aplicações:    </strong></p>
          <ul>
            <li>Amazon web service; </li>
            <li>Netflix; </li>
            <li>Google; </li>
            <li>Uber; </li>
            <li>Spotify;</li>
          </ul>
          <p><strong>  Tendências:  </strong></p>
          <ul>
            <li>Arquiteturas serveless; </li>
            <li> Edge Computing;</li>
            <li> Arquiteturas multi-cloud;</li>
            <li>Arquitetura federada; </li>

          </ul>
        </br>
          <li><strong>5.2. Arquitetura Orientada a Serviços (SOA)</strong></li>
          <p>É um estilo de arquitetura de software que organiza e estrutura um sistema em torno de serviços, que são componentes modulares e autônomos que realizam funções especificas. Esses serviços se comunicam entre si através de protocolos de rede para realizar tarefas complexas e fornecer funcionalidades empresariais.</p>
          <p>Serviços: unidade ou conjunto de funcionalidades de software independente, desenvolvido para concluir uma tarefa especifica, como recuperar determinadas informações ou executar uma operação. Ele contém as integrações de dados e o código necessários para executar uma função de negócio completa. Esses serviços podem ser acessados remotamente é possível interagir com eles e atualizá-los de maneira independente;</p>
          
          <p><strong>  Estrutura  </strong></p>
          <ul>
            <li>Provedor de serviços; </li>
            <li>Broker ou registro de serviços (contratos); </li>
            <li>Solicitante de serviços; </li>
          </ul>

          <p><strong>  Vantagens:  </strong></p>
          <ul>
            <li>Flexibilidade e time to Market; </li>
            <li>Reutilização de software;</li>
            <li>Evolução; </li>
            <li>Manutenção </li>
            <li>Escalabilidade; </li>
          </ul>

          <p><strong> Desvantagens:   </strong></p>
          <ul>
            <li>Complexidade na implantação/evolução; </li>
            <li>Latência; </li>
            <li>Sobrecarga devido a comunicação; </li>
            <li>Segurança; </li>
            <li>Dependências de padrão; </li>
            <li>Gerenciamento; </li>
          </ul>


          <p><strong>Boas práticas:    </strong></p>
          <ul>
            <li>Definição clara dos serviços; </li>
            <li>Monitoramento e gestão do desempenho; </li>
            <li>Reutilização; </li>
            <li>Padronize a comunicação (Ex. rest); </li>
            <li>Evolui integrando arquiteturas modernas (microserviços e apis) </li>
          </ul>
          </br>

          <li><strong>5.3. Arquitetura Microserviços</strong></li>
          <p>Estilo de arquitetura de software em que uma aplicação é estruturada como um conjunto de serviços pequenos e independentes, que se comunicam entre si através de APIs bem definidas. Cada microserviços é responsável por uma funcionalidade especifica do sistema e pode ser desenvolvido, implantando e escalado de forma independente dos outros;</p>
          <p>API’s application programming interface, interface que permite a comunicação entre microsserviços, serviços ou cliente externos.</p>
          <p><strong>  Vantagens:  </strong></p>
          <ul>
            <li>Flexibilidade e time to Market; </li>
            <li>Reutilização de software;</li>
            <li>Evolução; </li>
            <li>Manutenção; </li>
            <li>Escalabilidade; </li>
            <li>Comunicação por API; </li>
            <li>Resiliência;</li>
          </ul>
          <p><strong>  Desvantagens:  </strong></p>
          <ul>
            <li>Gestão dos microsserviços; </li>
            <li>Complexidades ACID; </li>
            <li>Despafronização; </li>
          </ul>
          <p><strong> Boas práticas:   </strong></p>
          <ul>
            <li>Descentralização dos dados; </li>
            <li>Comunicação assíncrona sempre que possível; </li>
            <li>Versionamento de APIs;</li>
            <li>Automatização CI/CD;</li>
            <li>Monitoramento e logging centralizado; </li>
            <li>Cultura de DevOps;</li>
          </ul>

          <li>5.4. Arquitetura Orientada a Eventos</li>
          <p>Estilo de arquitetura de software em que os componentes do sistema se comunicam e interagem entre si através da troca de eventos. Um evento é uma notificação de que algo significativo aconteceu dentro do sistema, como uma mudança de estado, uma ação do usuário ou a ocorrência de uma condição especifica;</p>
          <p>Exemplo: Uma mensagem que descreve algo que aconteceu no sistema. Por exemplo, pedido realizado ou pagamento aprovado ou usuário logado ou rastreio de correio, envio de promoção. Os eventos são geralmente representados como mensagens contendo dados relevantes, como o tipo de eventos e os detalhes associados.</p>
          <p>Na arquitetura orientada a eventos é necessário um sistema e mensageria, que utiliza algum padrão de comunicação como inscrição e publicação;</p>
        
          <p><strong> Vantagens:   </strong></p>
          <ul>
            <li> Desacoplamento;</li>
            <li> Desempenho;</li>
            <li> Escalabilidade;</li>
            <li> Comunicação assíncrona;</li>
          </ul>
          <p><strong>  Desvantagens:  </strong></p>
          <ul>
            <li>Complexidade; </li>
            <li>Adequação funcional; </li>
            <li>Gerenciamento de estado/eventual consistency; </li>
            <li>Depuração e rastreamento; </li>
          </ul>
          <p><strong> Boas práticas:   </strong></p>
          <ul>
            <li>Definição clara dos eventos;</li>
            <li>Modelos claro de gerenciamento de eventos; </li>
            <li>Desacoplamento entre produtores e consumidores; </li>
            <li>Confirmação de entrega de eventos; </li>
            <li>Segurança na comunicação;</li>
          </ul>
        
        
        </ul>
      </div>
      
      <div id="modulo-1-exercicios-fixacao" class="capitulo">
        <h2>Exercícios de Fixação</h2>
        <ul>
          <li>Primeira Aula Interativa - Trabalhando Estilos Arquiteturais</li>
        </ul>
      </div>
      
      <div id="modulo-1-capitulo-7" class="capitulo">
        <h2>Capítulo 7: Conduzindo o Processo Decisório</h2>
        <p>Neste capítulo, falaremos de atividades essenciais que o profissional de arquitetura de software precisa conhe cer e aplicar para desempenhar suas atividades com excelência, atividades tais como: como conduzir o pro cesso decisório, saber utilizar frameworks arquiteturais e gerenciamento de riscos. Gerindo o processo de Arquitetura Como líder do processo decisório, o arquiteto precisa conhecer práticas e ferramentas que vão lhe apoiar a guiar este processo. É importante frisar que o arquiteto não deve decidir de forma individual, em vários momentos este profissional deve guiar o processo de análise de toma de decisões que podem resultar em decisões dife rentes da que o arquiteto tomaria inicialmente. “O arquiteto não é dono da verdade, mas quem guia o processo de descoberta da mesma”. Vamos falar de algumas ferramentas: </p>
        
        <ul>
          <li>7.1. Matriz de Decisão</li>
          <p>Uma matriz de decisão é uma ferramenta analítica usada para avaliar e comparar diversas opções ou soluções com base em múltiplos critérios ponderados. Cada opção é avaliada contra esses critérios, e as pontuações resultantes são somadas para identificar a opção mais adequada. Um arquiteto de software pode utilizar a ma triz de decisão para selecionar tecnologias, frameworks, ou arquiteturas apropriadas para um projeto específico.  </p>
          <p>Ao definir critérios como desempenho, escalabilidade, custo, facilidade de integração e manutenção, o arqui teto pode atribuir pesos a cada critério de acordo com sua importância relativa. As diferentes opções são então avaliadas e pontuadas, permitindo ao arquiteto tomar uma decisão informada e justificada sobre a melhor so lução para atender aos requisitos do projeto e aos objetivos estratégicos da organização.</p>
          
          <li>7.2. Análise de Premissas e Restrições</li>
          <p>A análise de premissas e restrições é um processo de identificação e avaliação de suposições (premissas) e limitações (restrições) que influenciam o desenvolvimento de um projeto. Premissas são condições consideradas verdadeiras para planejamento, como a disponibilidade de determinada tecnologia, enquanto restrições são limitações que o projeto deve respeitar, como orçamento, prazo ou conformidade com regulamentações. Um arquiteto de software utiliza essa análise para assegurar que a arquitetura proposta esteja alinhada com as condições reais do projeto e as expectativas das partes interessadas. Ao identificar claramente as premissas e restrições, o arquiteto pode antecipar desafios, mitigar riscos e tomar decisões mais precisas, garantindo que a solução seja viável, eficiente e esteja dentro dos limites estabelecidos</p>

          <li>7.3. Análise de Custo da Solução</li>
          <p> A análise de custo e solução é um processo que envolve a avaliação detalhada dos custos associados a diferentes opções de solução para um projeto, considerando tanto os custos iniciais quanto os custos recorrentes, como manutenção e operação. O objetivo é comparar essas opções para determinar a mais econômica e eficaz em termos de retorno sobre investimento (ROI) e alinhamento com os objetivos de negócio. Um arquiteto de software utiliza essa análise para tomar decisões informadas sobre quais tecnologias, frameworks e arquiteturas adotar, assegurando que a solução escolhida não só atenda aos requisitos técnicos, mas também seja financeiramente viável. Isso ajuda a evitar custos excessivos, maximizar os recursos disponíveis e garantir que a solução possa ser sustentada a longo prazo dentro do orçamento da organização</p>

        </ul>
      </div>
      
      <div id="modulo-1-capitulo-8" class="capitulo">
        <h2>Capítulo 8: Gerenciando Riscos</h2>
        <ul>
          <li>8.1. Conceitos de Riscos</li>
          <p> É a possibilidade de um evento ou condição que, se ocorrer, pode afetar negativamente o projeto ou o sistema. Ex. Alteração do escopo, não renovação de uma licença, falta de recursos; </p>
          <p>Oportunidade é a possibilidade de um evento ou condição que, se ocorrer, pode afetar positivamente o projeto ou o sistema; </p>
          <p><strong> Tipos de riscos:   </strong></p>
          <ul>
            <li>Riscos técnicos. Ex. atualização de uma biblioteca; </li>
            <li>Riscos de projeto: Ex. mudança de requisitos; </li>
            <li>Riscos organizacionais. Ex. mudança na estratégia;</li>
          </ul>
          <p><strong>Gerenciar riscos:   </strong></p>
          <ul>
            <li>Identificação de riscos; </li>
            <li>Avaliação de análise de riscos; </li>
            <li>Mitigação e resposta e riscos; </li>
            <li>Monitoramento e revisão de riscos; </li>
          </ul>
          <p> Prever o desenho de uma arquitetura prover, uma estrutura para o sistema que garanta a entrega dos requisitos não funcionais, se eu tenho um risco que pode impactar de forma que o meu requisito não funcional não seja atendido, eu sou o guardião tenho que atual de forma proativa para evitar isso. </p>
          
          <li>8.2. Como identificar Riscos</li>

          <ul>
            <li>Brainstorming e análise de causas; </li>
            <li>Entrevistas e questionários com stakeholders; </li>
            <li> Análise de documentação e requisitos;</li>
            <li>Ferramenta de identificação SWOT </li>
            <li>Garantir transações ACID; </li>
            <li> Ferramenta de identificação:</li>
            <ul>
              <li> Diagrama de fluxo e casos de uso;</li>
              <li>Threat modeling; </li>
            </ul>
          </ul>



          <li>8.3. Como classificar Riscos</li>
          <p>Classificando riscos: Fatores a se considerar</p>
          <ul>
            <li>Probabilidade de ocorrência; </li>
            <li>Impacto ou consequência;</li>
            <li>Urgência e necessidade de resposta; </li>
          </ul>
          <p>Matriz de risco </p>
          <p>ROAM</p>
          <p>5W2H (Plano de ação)</p>

          <li>8.4. Prática Riscos</li>
          <p>Fluxo de Ishikawa (Diagrama de peixe)</p>


        </ul>
      </div>
      
      <div id="modulo-1-capitulo-9" class="capitulo">
        <h2>Capítulo 9: Frameworks Arquiteturais</h2>
        <p> Frameworks arquiteturais são estruturas de referência que oferecem uma base organizada para o desenvolvimento e a implementação de sistemas de software complexos. Eles proporcionam um conjunto de ferramentas, padrões e práticas que facilitam a criação de arquiteturas robustas, escaláveis e eficientes. Entre os exemplos mais conhecidos estão o TOGAF (The Open Group Architecture Framework), que foca na metodologia de desenvolvimento e governança de arquiteturas empresariais, e o Zachman Framework, que fornece uma visão multidimensional da arquitetura organizacional, abordando diferentes perspectivas e preocupações dos stakeholders. Esses frameworks ajudam a garantir que os sistemas atendam às necessidades do negócio, sejam consistentes e alinhados com os objetivos estratégicos da organização.</p>
        <ul>
          <li><strong>9.1. ZACHMAN </strong></li>
          <p> O Zachman Framework é uma estrutura conceitual desenvolvida por John Zachman na década de 1980, oferecem uma abordagem sistemática para compreender, documentar e gerenciar a arquitetura de uma organização. Esta estrutura é composta por seis dimensões fundamentais: “O quê”, “Como”, “Onde”, “Quem”, “Quando” e “Por quê”, cada uma representando uma perspectiva única sobre a organização. Em sua forma atual, o framework de Zachman consiste em uma matriz de 6 colunas por 6 linhas. As colunas correspondem às clássicas perguntas 5W1H (What/ Who/Where/When/Why/How) aplicadas à organização. As colunas, portanto, referem-se aos diferentes aspectos sobre a organização que precisam ser conhecidos: </p>
          <ul>
            <li> What: sobre o que a organização precisa de infor mação? De que ela trata? Normalmente, essa coluna representa dados mantidos pela organização; </li>
            <li> How: Como a organização funciona? Como ela processa seus dados? Esta coluna normalmente refere-se a processos e funções da organização.  </li>
            <li> Where: Onde as coisas acontecem? Aqui vão informações geográficas, de localização etc.  </li>
            <li> Who: Quem está na organização e quem faz o quê? Informações sobre pessoas e estruturas organizacionais estão aqui.  </li>
            <li> When: Quando as coisas acontecem? Questões relativas ao tempo aparecem aqui.  </li>
            <li> Why: Por que as coisas acontecem? Aqui vão as in formações relativas às motivações da organização, incluindo seus planos estratégicos de negócio. As linhas da matriz referem-se aos diferentes pontos de vista e níveis de detalhe relativos à informação que descreve a organização: A primeira linha contém o escopo e o contexto, e representa o ponto de vista do estrategista como teorizador sobre a organização. Normalmente, contém in formação relevante para o planejamento estratégico de alto nível e, é claro, o próprio conteúdo da Estratégia da organização. A segunda linha contém os conceitos de negócio, representando a visão da liderança executiva (vistos como proprietários dos processos de negócio e informações relacionadas). Contém tipicamente descrição detalhada da organização no nível de processos de negócio. A terceira linha contém informações sobre os sistemas de informação (nível lógico), com a visão dos arquitetos de sistemas (designers). A quarta linha contém informações sobre a infraestrutura tecnológica (nível físico) da organização, sendo o ponto de vista dos engenheiros enquanto construtores. A quinta linha refere-se à descrição dos componentes que a organização utiliza para operar, sendo a visão dos técnicos-implementadores. A sexta e última linha representa as operações propriamente ditas da organização, instanciadas pelos seus colaboradores participantes. O framework Zachman é uma excelente referência literária sobre o assunto, apesar de ter sua aplicabilidade limitada devido a não ser tão prático e dinâmico, assim como o fato de ser um framework mais geral e que não aborda de forma específica o contexto de arquitetura de software </li>
          </ul>
        </br>
          <li><strong> 9.2. TOGAF </strong></li>
          <p> O The Open Group Architecture Framework (TOGAF) é uma estrutura de arquitetura corporativa amplamente adotada, desenvolvida pelo The Open Group, que fornece uma abordagem abrangente e estruturada para planejar, projetar, implementar e gerenciar a arquitetura de uma organização. Esta estrutura é baseada em um conjunto de melhores práticas e padrões de arquitetura, destinados a promover a consistência, a eficiência e o alinhamento estratégico em toda a empresa. O TOGAF é amplamente reconhecido por sua flexibilidade e adaptabilidade, podendo ser personalizado e ajustado de acordo com as necessidades específicas de cada organização. Ele fornece uma estrutura sólida para a gestão e evolução da arquitetura empresarial, ajudando as empresas a alinhar seus sistemas de informação com seus objetivos estratégicos, reduzir a complexidade e promover a inovação. O TOGAF divide a arquitetura corporativa em quatro pilares básicos:  </p>
          <ul>
            <li> Business Architecture (Arquitetura de Negócio): define a estratégia de negócio, governança, organização e os processos chaves do negócio. </li>
            <li> Data Archtecture (Arquitetura de Dados): descreve a estrutura física e lógica dos ativos de dados da organização, bem como os recursos a serem gerenciados. </li>
            <li> Application Architecture (Arquitetura de Aplicação): provisiona um blueprint para que as aplicações individuais sejam publicadas, as interações e o relacionamento delas com os principais processos de negócio da organização. </li>
            <li> Technology Archiitecture (Arquitetura Técnica): descreve todo o hardware, software e infraestrutu ra de TI necessários para desenvolver e implantar aplicativos de negócios </li>
            <li> Fase Preliminar: é aquela na qual “colocamos em pé” o esforço de arquitetura, estabelecendo a equipe de arquitetura e definindo o método e metamodelo customizados a serem usados em nosso esforço de arquitetura. É aqui também que escolhemos ferramentas de repositório, definimos os processos de Governança da Arquitetura e obtemos o Patrocínio necessário para forço de arquitetura. </li>
            <li> Fase A – Visão Arquitetural: Trata-se de estabelecer uma visão de como deve ser nossa arquitetura futura para atender às metas estratégicas de negócio, que são a principal entrada para esta fase. O resultado desta fase é um Documento de Visão da Arquitetura, que documenta onde a organização quer chegar com sua arquitetura para viabilizar o cumprimento das metas estratégicas, e um Plano de Projeto para a execução desta “rodada” do ADM s </li>
            <li> Fase B – Arquitetura de Negócio: Desenvolver e documentar a Arquitetura de Negócio desejada (alvo), que irá descrever o que a organização necessita para operacionalizar os objetivos de negócio e responder aos direcionamentos definidos na Visão Arquitetural. O resultado da fase é o detalhamento das necessidades em termos de processos de negócio para atender às metas estratégicas, bem como um gap analysis que nos diz qual é a distância entre nossa situação atual (AS-IS) e a arquitetura em que queremos chegar (TO-BE).  </li>
            <li> Fase C – Arquiteturas de Sistemas de Informação: Nesta fase, identificamos os sistemas e dados necessários para atender à situação futura de processos de negócio desenhada na fase anterior, bem como nossa situação atual e a distância a ser percorrida (gap analysis). </li>
            <li> Fase D – Arquitetura de Tecnologia: Esta fase se ocupa de documentar as necessidades futuras em termos de infraestrutura tecnológica para atender às necessidades de sistemas e dados identificados na fase anterior. Mais uma vez, identificamos também nossa situação atual e a distância a ser percorrida.  </li>
            <li> Fase E – Oportunidades e Soluções: Nesta fase será gerado a versão inicial completa do Roadmap de Ar quitetura, baseado nos gaps identificados nas fases B, C e D. Identificaremos também projetos e ativida des que deverão ser realizados para atingir os obje tivos definidos no Roadmap. O resultado é um por tfólio de projetos para atingir a arquitetura desejada.  </li>
            <li> Fase F – Migration Planning: Aborda o planejamento detalhado da migração, ou seja, como passar do estado atual para a Arquitetura Alvo, certificando que o valor do negócio e o custo dos pacotes de trabalho e arquiteturas de transição são entendidos pelos stakeholders.  </li>
            <li> Fase G – Governança de Implementação: Nesta etapa o principal é a realização de revisões de conformidade com o objetivo de garantir que as ativida des definidas no portfólio estão sendo executadas de acordo com a arquitetura proposta.  </li>
            <li> Fase H – Gestão de Mudanças na Arquitetura: Trata-se de acompanhar no dia a dia a continuidade da relevância da arquitetura implantada na Fase G às necessidades estratégicas da organização. Mudanças no Ambiente de Negócios e na Estratégia exi girão mudanças na arquitetura, e o processo usado nesta fase deve ser capaz de separar pequenas de grandes mudanças. As grandes mudanças, tipicamente, exigirão a reentrada no ciclo do ADM, ou seja, o estabelecimento de um novo projeto, a ser iniciado novamente na Fase A.    </li>
            <li> Gestão dos Requisitos: Esta atividade encontra-se – literalmente – no “centro” do ADM, significando que cada uma das demais fases do ADM ao mesmo tempo gera novos requisitos de arquitetura e utiliza como entrada os requisitos de arquitetura previa mente identificados.  </li>
          </ul>
          <p>Entre os atrativos de utilização do TOGAF podemos citar sua flexibilidade, visto que as fases não devem ser seguidas como uma receita fixa, sendo assim cada organização pode adotar um processo adaptado conforme suas necessidades. Sendo este framework mais usual tanto pela sua flexibilidade, quanto pelo fato de ser um framework derivado de open groups - o que facilita sua utilização e proporciona uma maior rede de apoio durante o processo de uso.</p>

        </ul>
      </div>
      
      <div id="modulo-1-capitulo-10" class="capitulo">
        <h2>Capítulo 10: Engenharia e Arquitetura de Software</h2>
        <ul>
          <li>10.1. Ciclo de Vida de Software</li>
          <p>São fases que um sistema passa desde a sua concepção até o seu desligamento;</p>
          <p><strong> Modelo Cascata   </strong></p>
          <ul>
            <li>Comunicação: Iniciação do projeto, levantmento de requisitos </li>
            <li>Planejmento: Estimativas, cronogramas e monitoração; </li>
            <li>Modelagem: Análise e projeto; </li>
            <li>Construção: Codificação e teste; </li>
            <li>Implantação: Entrega, manutenção e feedback; </li>
          </ul>
          <p><strong> Modelo interativo:   </strong></p>
          <p><strong> Modelo incremental:   </strong></p>
          <p><strong> Modelo de ciclo de vida ágil:   </strong></p>


          <li>10.2. Arquiteturas Monolíticas, Deploy Único e Desenvolvimento Cascata</li>
          <p><strong>    </strong></p>
              <ul>
                <li> </li>
                <li> </li>
                <li> </li>
                <li> </li>
                <li> </li>
                <li> </li>
              </ul>
          
          
          <li>10.3. Arquiteturas Evolucionárias, Deploy e Desenvolvimento Incremental</li>
          <p><strong>    </strong></p>
              <ul>
                <li> </li>
                <li> </li>
                <li> </li>
                <li> </li>
                <li> </li>
                <li> </li>
              </ul>
          
          <li>10.4. Engenharia e Arquiteturas Software Considerações</li>
          <p><strong>    </strong></p>
          <ul>
            <li> </li>
            <li> </li>
            <li> </li>
            <li> </li>
            <li> </li>
            <li> </li>
          </ul>
        
        
        </ul>
      </div>
      
      <div id="modulo-1-capitulo-11" class="capitulo">
        <h2>Capítulo 11: DEVOPS</h2>
        <ul>

          <li><strong>11.1. Princípios DevOps</strong></li>
          <p>Devops é uma abordagem que integra práticas de desenvolvimento de software (Dev) e operações (Ops) para melhorar a colaboração, aumentar a eficiência e acelerar a entrega de software;</p>
          <p><strong>  Princípio fundamentais:  </strong></p>
          <ul>
            <li> Colaboração; </li>
            <li> Automação; </li>
            <li> Entrega e integração contínua (CI/CD) </li>
            <li> Feedback rápido e iteração;</li>
            <li> Melhoria contínua; </li>
          </ul>
          <p><strong> Benefícios:    </strong></p>
          <ul>
            <li>Qualidade e confiabilidade das entregas; </li>
            <li>Aumento da colaboração entre equipes; </li>
            <li>Viabilidade fluxo contínuo de entrega de valor; </li>
            <li>Velocidade de entrega;</li>
            <li>Redução de custo e riscos;</li>
          </ul>
          <p><strong>CALMS: dimensões fundamentais:   </strong></p>
          <ul>
            <li>Cultura </li>
            <li>Automação</li>
            <li>Lean (processos enxutos) </li>
            <li>Medição </li>
            <li>Sharing (compartilhamento)</li>
          </ul>

          <li><strong>11.2. Pilares DevOps</strong></li>
          <p><strong> Pilares da mudança cultural:   </strong></p>
          <ul>
            <li>Automação: Uso de ferramentas e scripts para automatizar tarefas repetitivas, como builds, testes e deploy. Ferramentas comuns: Selenium, Junit, Gitlab, Ansible; </li>
            <li>Integração contínua (CI): Prática de manter o código pronto para deploy a qualquer momento.  </li>
            <li>Entrega contínua (CD) </li>
            <li>Monitoramento e feedback: Monitoramento contínuo do sistema para garantir os requisitos não funcionais ao longo do tempo. Ferramentas: Phrometeus, Grafana, Elasticsearch; </li>
            <li>Segurança: DevSecOps: é a prática de integrar a segurança no processo de devops desde o início do ciclo de vida;</li>
          </ul>

          <li>11.3. Ferramentas e Práticas Comuns em DevOps</li>
          
          <li>11.4. Integrando DevOps e Arquitetura de Software</li>
          <p>Arquitetura evolutiva e devops, arquitetura evolutiva é a prática de construção sistemas que podem evoluir ao longo do tempo em resposta a mudanças nos requisitos e tecnologias;  </p>
          <p>Como devops pode contribuir para isto? Princípios de arquitetura evolutiva: Desacoplamento, feedback contínua, governança mínima, Exemplo: Mocrisserviços; </p>
          <p>Design para DevOps: Envolver práticas de design de software que facilitam a automação continua, entrega contínua e monitoramento. Elementos chave: Automação e Observabilidade; </p>
          <ul>
            <li>Imutabilidade de infraestrutura; </li>
            <li>Descentralização das decisões arquiteturais;</li>
            <li>Resiliência; </li>
            <li>Exemplo: Circuit Breakers e IaC; </li>
          </ul>


        </ul>
      </div>
      
    </div>

   <!-- Conteúdo do módulo 2 -->
    <div id="modulo-2">
      <h2>Módulo 2: Requisitos Arquiteturais e Modelagem Arquitetural</h2>

      <div id="modulo-2-capitulo-0" class="capitulo">
        <p><strong>Capítulo 0: Introdução à Engenharia de Requisitos</strong></p>
        <ul>
          <li>0.1. Apresentação</li>
          <li>0.2. Trajetória</li>
          <li>0.3. Redes Sociais</li>
          <li>0.4. Apresentação do Módulo</li>
        </ul>
      </div>
      
      <div id="modulo-2-capitulo-1" class="capitulo">
        <p><strong>Capítulo 1: Fundamentos de Engenharia de Requisitos</strong></p>
        <ul>

          <li><strong>1.1. Requisitos Arquiteturais e Funcionais</strong></a></li>
          <p>Sabemos que as maiores causas de falha em projetos de software se dão por definição errônea de requisitos. Estima-se que quase 85% dos efeitos em sistemas tem origem em requisitos mal levantados (Young, 2001/2002);</p>
          <p>A definição ou descrição de um requisito pode ser facilmente encontrado em muitos livros de engenharia de software. Em linhas gerais é aquilo ou algo que é desejado, ou requisitado pelo seu cliente/usuário que será utilizado para que alguma tarefa seja realizada. Um requisito de sistema é uma especificação de uma função ou característica que um sistema de software.</p>
          <p>O levantamento de requisitos é um processo essencial para o desenvolvimento de um sistema e pode ser realizado de diversas formas, como análise do ponto de vista dos envolvidos, pesquisa etnográfica, grupos de trabalho, versões de teste e desenvolvimento compartilhado.</p>
          <p><strong>Como realizar um levantamento de requisitos?    </strong></p>
          <ul>
            <li>Requisitos Funcionais: Os requisitos funcionais definem as funcionalidades específicas do sistema, representando tudo o que envolve interação direta com o usuário. São aspectos tangíveis e geralmente os mais perceptíveis para o cliente. Esses requisitos podem surgir a partir de problemas do dia a dia, melhorias em sistemas existentes ou demandas por novas funcionalidades. Exemplo: "O sistema deve permitir que usuários autenticados criem seus perfis e adicionem informações pessoais". </li>
            <li>Requisitos Não Funcionais: Os requisitos não funcionais estão relacionados a características como desempenho, usabilidade, confiabilidade, segurança, disponibilidade e manutenibilidade. Embora fundamentais para a qualidade do sistema, muitas vezes são negligenciados, deixados apenas para o time técnico ou considerados implícitos nos requisitos funcionais. Exemplo: "O sistema deve ter um tempo de resposta de no máximo 2 segundos para todos os processos de busca". </li>
          </ul>
          <p> O sucesso de um projeto de software depende de um bom levantamento de requisitos, pois cerca de 85% das falhas ocorrem nessa fase inicial. Compreender os requisitos é essencial para evitar problemas na modelagem arquitetural e garantir um sistema eficiente.</p>
          <p><strong>  Tipos de Requisitos  </strong></p>
          <ul>
            <li> Requisitos Funcionais: Relacionam-se diretamente com as funcionalidades do sistema, como telas e processos interativos para os usuários. Exemplos incluem cadastro de usuários e geração de relatórios.</li>
            <li> Requisitos Não Funcionais: Dizem respeito a aspectos como performance, segurança e escalabilidade, garantindo qualidade e eficiência. Exemplos incluem tempo de resposta inferior a 1 segundo e alta disponibilidade. </li>
          </ul>
          <p><strong>  Tríade dos Requisitos, Para um requisito ser validado, ele deve conter:  </strong></p>
          <ul>
            <li>Motivo: Justificativa da necessidade. </li>
            <li>Origem: Quem ou o que demandou o requisito (usuário, cliente, stakeholders). </li>
            <li>Objetivo: O que se espera alcançar. </li>
          </ul>
          <p><strong>Método, Processo e Ferramenta    </strong></p>
          <ul>
            <li>Método: Forma de execução. </li>
            <li>Processo: Passo a passo para realizar a tarefa. </li>
            <li>Ferramenta: Recursos utilizados para implementar o processo. </li>
          </ul>
          <p><strong>  Levantamento de Requisitos, Pode ser realizado de diversas formas:  </strong></p>
          <ul>
            <li>Entrevistas e pesquisas: Coleta direta ou coletiva de informações com usuários. </li>
            <li>Análise de sistemas legados: Identificação de melhorias e evoluções </li>
            <li>Ideação: Geração de ideias e definição de MVPs (Produtos Mínimos Viáveis). </li>
            <li>Testes empíricos: Avaliação de versões de teste em cenários reais </li>
          </ul>
          <P>Requisitos na Era da Computação em Nuvem: Com o avanço da computação em nuvem, a preocupação com hardware diminuiu, mas surgiram novos desafios, como controle de custos e escalabilidade. Hoje, requisitos não funcionais desempenham um papel crucial na otimização de desempenho e segurança. Esse panorama destaca a importância de documentar e compreender bem os requisitos, garantindo que o sistema atenda tanto às necessidades funcionais quanto à experiência do usuário e à eficiência operacional.</P>
          <p>Conclusão: Os requisitos não funcionais são menos tangíveis e frequentemente mal gerenciados, sendo deixados para a equipe técnica sem um planejamento adequado. Entretanto, são essenciais para garantir a qualidade e a experiência do usuário no sistema.</p>
          
          <li><strong>1.2. Arquitetura Mínima Viável</strong></li>
          <p>MVP – Produto mínimo viável, pensar no mínimo para ser entregue</p>
          <p>Conclusão: É melhor as postergar as decisões quando a incerteza é grande. A cada ciclo, fazer o mínimo necessário; </p>
          
          <li><strong>1.3. Padrões Arquiteturais</strong></li>
          <p>Padrões Arquiteturais e Metodologias de Desenvolvimento de Software, O desenvolvimento de software evoluiu ao longo dos anos, resultando em diferentes abordagens para planejamento e implementação de sistemas. Essas abordagens podem ser divididas em modelos tradicionais e metodologias ágeis.</p>
          <p><strong>  Modelos Tradicionais  </strong></p>
          <P>Os métodos tradicionais foram amplamente utilizados nas fases iniciais da engenharia de software e incluem:</P>
          <ul>
            <li><strong>Modelo Cascata: </strong>Processo sequencial com fases bem definidas (análise, projeto, codificação, testes e entrega). É rígido e pouco flexível para mudanças. </li>
            <li><strong>Modelo Espiral:</strong> Iterativo, permitindo entregas contínuas e aprimoramento progressivo. </li>
            <li><strong>Modelo Incremental:</strong> Desenvolvimento por partes, entregando funcionalidades em etapas. </li>
            <li><strong>Prototipação:</strong> Criação rápida de protótipos para validar requisitos com os usuários </li>
            <li><strong>RUP (Rational Unified Process):</strong> Processo iterativo baseado em fases, combinando planejamento e desenvolvimento contínuo </li>
          </ul>
          <p>Esses modelos são eficazes quando há requisitos bem definidos desde o início, mas apresentam dificuldades para lidar com mudanças constantes.</p>
          <p><strong>  Metodologias Ágeis  </strong></p>
          <p>Para responder à necessidade de maior flexibilidade e adaptação, surgiram as metodologias ágeis, que se destacam por:          </p>
          <ul>
            <li><strong>Iterações curtas:</strong> Desenvolvimento em ciclos pequenos, com entregas frequentes.</li>
            <li><strong>Times multidisciplinares:</strong> Equipes colaborativas atuando simultaneamente.</li>
            <li><strong>Feedback contínuo:</strong> Ajustes rápidos com base no retorno dos usuários.</li>
          </ul>
          <p><strong> Os métodos ágeis mais populares são:   </strong></p>
          <ul>
            <li><strong>Scrum: </strong>Baseado em sprints curtas, com papéis definidos (Scrum Master, Product Owner) e entregas incrementais.</li>
            <li><strong>Kanban:</strong>Utiliza quadros visuais para monitorar e otimizar o fluxo de trabalho. </li>
          </ul>
          <p>Conclusão: A transição dos modelos tradicionais para metodologias ágeis reflete a evolução das necessidades do mercado. O foco deixou de ser um processo rígido e linear para um desenvolvimento mais dinâmico, adaptável e colaborativo, garantindo entregas mais rápidas e alinhadas às expectativas dos clientes.</p>


          <li><strong>1.4. Desenvolvimento Ágil</strong></li>
          <p>O Desenvolvimento Ágil é baseado em metodologias que priorizam entregas rápidas, flexibilidade e colaboração entre as equipes. Ele se fundamenta nos seguintes princípios:</p>
          <ul>
            <li> Valor: Funcionalidades devem gerar valor ao usuário.</li>
            <li> Frequência: Desenvolvimento contínuo com entregas regulares.</li>
            <li> Flexibilidade: Capacidade de reavaliar prioridades.</li>
            <li>União: Uso combinado de diferentes tecnologias. </li>
            <li>Motivação: Equipe engajada melhora os resultados. </li>
            <li> Comunicação: Clareza sobre objetivos e execução.</li>
            <li> Simplicidade, Revisão e Sustentabilidade: Código limpo e sustentável. </li>
            <li>Organização: Coordenação entre múltiplas equipes.  </li>
            <li> Autoavaliação: Revisão constante para melhorias </li>
          </ul>
          <p><strong> Vantagens do Desenvolvimento Ágil   </strong></p>
          <ul>
            <li>Maior produtividade. </li>
            <li>Entregas contínuas e incrementais. </li>
          </ul>
          <p><strong>  Scrum Framework  </strong></p>
          <p>O Scrum é um dos principais frameworks ágeis, estruturado em ciclos curtos chamados sprints. Suas etapas incluem:</p>
          <ul>
            <li> Backlog – Lista de funcionalidades a serem desenvolvidas.</li>
            <li> Planning Meeting – Definição das prioridades da sprint.</li>
            <li> Sprint Backlog – Seleção das tarefas da sprint</li>
            <li> Task – Unidade mínima de uma funcionalidade</li>
            <li>Daily – Reuniões diárias de alinhamento. </li>
            <li>Review – Apresentação dos recursos desenvolvidos. </li>
            <li> Increment – Entrega das novas funcionalidades.</li>
            <li>Retrospectiva – Reflexão para melhorias futuras. </li>
          </ul>
          <p><strong> Papéis no Scrum   </strong></p>
          <ul>
            <li>Product Owner – Define requisitos e prioridades. </li>
            <li> Scrum Master – Facilita o processo e remove impedimentos.</li>
            <li>Equipe de Desenvolvimento – Responsável pela implementação. </li>
          </ul>
          <p> O Kanban também é utilizado como um método visual para gerenciar o fluxo de trabalho. </p>
          <P> Conclusão: O Desenvolvimento Ágil traz maior eficiência e qualidade para projetos, promovendo entregas frequentes, colaboração e adaptação rápida às mudanças. </P>

          <li><strong>1.5. Sistemas Legados</strong></li>
          <p> Os sistemas legados são aplicações desenvolvidas em tecnologias antigas, muitas vezes consideradas ultrapassadas, mas que ainda são amplamente utilizadas em diversas organizações. Apesar de serem essenciais para o funcionamento de muitos negócios, sua manutenção é desafiadora, devido à falta de suporte, dificuldades de integração com novas tecnologias e escassez de profissionais qualificados.</p>
          <p><strong> Desafios dos Sistemas Legados   </strong></p>
          <ul>
            <li>Utilizam linguagens e frameworks desatualizados. </li>
            <li>Dificuldade em encontrar especialistas para suporte e manutenção. </li>
            <li> Alto custo para modernização ou substituição.</li>
            <li> Possível incompatibilidade com tecnologias mais recentes.</li>
          </ul>
          <p><strong> Estratégias para Modernização   </strong></p>
          <p>A decisão sobre o que fazer com um sistema legado envolve diferentes abordagens, como:</p>
          <ul>
            <li>Evoluir o sistema atual – Melhorando partes do código, migrando gradualmente para tecnologias modernas. </li>
            <li>Criar um sistema novo do zero – Substituir completamente o legado por uma nova solução. </li>
            <li>Combinar ambas as estratégias – Atualizar funcionalidades críticas enquanto desenvolve um novo sistema em paralelo. </li>
          </ul>
          <p> Conclusão: A modernização de sistemas legados exige um planejamento estratégico, considerando custos, riscos e impactos para o negócio. Escolher entre evolução gradual ou reestruturação completa depende da complexidade do sistema, tempo disponível e recursos da empresa. </p>
          
          
          <li>1.6. Responsabilidades de Times</li>
          <p> A organização dos times dentro de uma empresa varia conforme o porte da empresa e a quantidade de colaboradores disponíveis.</p>
          <p> Empresas de grande porte possuem equipes especializadas, com divisão clara de responsabilidades, processos bem definidos e maior burocracia, exigindo metodologias ágeis para alinhamento e colaboração eficiente.</p>
          <p> Empresas menores contam com equipes multifuncionais, onde os profissionais assumem diversas responsabilidades. Esse modelo proporciona maior flexibilidade e agilidade, mas exige um alto grau de maturidade e capacitação para evitar sobrecarga.</p>
          <p> Independentemente do tamanho da empresa, o sucesso dos times depende de uma boa distribuição de tarefas, comunicação eficiente e processos estruturados, garantindo produtividade e eficiência.</p>

        </ul>
      </div>

      <div id="modulo-2-capitulo-2" class="capitulo">
        <h2>Capítulo 2: Elicitação de Requisitos Arquiteturais</h2>
        <ul>
          <li>2.1. O que é Engenharia de Requisitos</li>
          <p> A Engenharia de Requisitos é um processo essencial no desenvolvimento de sistemas, garantindo que as necessidades dos usuários sejam corretamente compreendidas e implementadas.</p>
          <p><strong>  Principais Etapas do Processo: </strong></p>
          <ul>
            <li>Elicitação de Requisitos – Entender o que deve ser desenvolvido, identificando as dores do cliente e mapeando fontes de requisitos. </li>
            <li>Análise de Requisitos – Classificar requisitos, resolver conflitos, realizar análise de custo-benefício e modelagem conceitual. </li>
            <li>Especificação – Documentação detalhada das funcionalidades e criação de tarefas.</li>
            <li>Validação – Garantir que os requisitos atendem às expectativas antes da entrega final. </li>
          </ul>
          <p><strong> Tipos de Requisitos:   </strong></p>
          <ul>
            <li><trong> Funcionais: </trong> Definem o que o sistema deve fazer. </li>
            <li><trong> Não funcionais:</trong>Requisitos de desempenho, segurança e usabilidade. </li>
          </ul>
          <p><strong> Ferramentas e Métodos:   </strong></p>
          <ul>
            <li>Uso de entrevistas e questionários para levantamento de requisitos. </li>
            <li>Métodos ágeis (Scrum, Kanban) para organização e acompanhamento de tarefas. </li>
            <li>Definition of Ready (DoR) e Definition of Done (DoD) para garantir clareza nas entregas. </li>
          </ul>
          <p> O sucesso da engenharia de requisitos depende da colaboração entre Product Owners, desenvolvedores, testadores e stakeholders, garantindo qualidade e alinhamento com as expectativas do cliente.</p>
          
          
          <li><strong> 2.2. Gestão de Produtos</strong></li>
          <p>A Gestão de Produtos envolve a criação, desenvolvimento e evolução de um produto, equilibrando design, tecnologia e negócios para atender às necessidades dos usuários e do mercado.</p>
          <p><strong> Arquitetura e o Mundo VUCA   </strong></p>
          <p>A arquitetura de um produto não deve considerar apenas a parte técnica, mas sim a resolução de problemas reais. O conceito de Mundo VUCA nos desafia a lidar com um ambiente:</p>
          <ul>
            <li> <strong> Volátil: </strong> Mudanças rápidas e inesperadas no mercado.     </li>
            <li> <strong> Incremental:  </strong> Evolução contínua, melhorando o produto ao longo do tempo.     </li>
            <li> <strong> Complexo: </strong>  Muitos fatores interligados influenciam as decisões.    </li>
            <li> <strong> Ambíguo : </strong> Nem sempre há uma única resposta correta.     </li>
          </ul>
          <p><strong> Sistema Finalizado: O Equilíbrio Essencial   </strong></p>
          <p>Um produto bem-sucedido precisa balancear três pilares:</p>
          <ul>
            <li> <strong>Design:  </strong>  Foco na experiência do usuário, usabilidade e estética.    </li>
            <li> <strong>Tecnologia: </strong>  Infraestrutura eficiente, escalabilidade e desempenho.    </li>
            <li> <strong>Negócios : </strong> Alinhamento com objetivos estratégicos, monetização e impacto no mercado.     </li>
          </ul>
          <p><strong>  Ciclo de Gestão de Produtos  </strong></p>
          <p>A gestão eficaz de um produto envolve um ciclo contínuo de melhoria e validação:</p>
          <ul>
            <li> <strong>Definir os próximos passos:  </strong> Planejar evoluções e melhorias.      </li>
            <li> <strong>Acompanhar a construção:  </strong>  Garantir que o desenvolvimento siga o plano.    </li>
            <li> <strong>Validar o que foi feito:  </strong>  Testar e verificar se as soluções atendem aos objetivos.    </li>
            <li> <strong>Definir objetivos:  </strong> Traçar metas claras para direcionar o crescimento do produto.     </li>
          </ul>
          <p><strong>  Entendendo o Problema  </strong></p>
          <p>Antes de desenvolver soluções, é essencial entender o problema que o produto visa resolver:</p>
          <ul>
            <li> <strong> Pesquisa: </strong>  Coleta de dados, feedbacks e análise de mercado.    </li>
            <li> <strong> Definição: </strong> Identificação do problema central e das necessidades dos usuários.     </li>
            <li> <strong> Desenvolvimento: </strong>   Implementação de funcionalidades para resolver os problemas identificados.   </li>
            <li> <strong>Liberação:   </strong>  Entrega do produto ou novas funcionalidades para os usuários.      </li>
            <li> <strong>Solução:  </strong> Ajustes e melhorias contínuas baseadas em testes e feedback.     </li>
          </ul>
          <p>A Gestão de Produtos exige visão estratégica, adaptação e colaboração entre equipes, garantindo que o produto evolua e continue relevante no mercado.</p>



          <li><strong>2.3. Tipos de Conhecimento</strong></li>
          <p> Para garantir o sucesso de um projeto, é essencial identificar os conhecimentos necessários e preencher lacunas de requisitos. Falhas nesse processo podem comprometer a entrega e a qualidade do produto. Além disso, a expertise no domínio do problema pode levar à omissão de conhecimento tácito, dificultando sua documentação e comunicação.</p>
          <p><strong> Impacto da Falta de Requisitos   </strong></p>
          <p>Requisitos ausentes ou mal definidos podem:</p>
          <ul>
            <li>Introduzir retrabalho e atrasos no projeto. </li>
            <li>Gerar funcionalidades incompletas ou incompatíveis com as necessidades reais. </li>
            <li>Comprometer a experiência do usuário e a qualidade do produto final. </li>
          </ul>
          <p><strong>  Conhecimento Tácito  </strong></p>
          <p>O conhecimento tácito é aquele adquirido ao longo da vida por meio da experiência. Ele não está formalmente documentado e, muitas vezes, é difícil de ser transmitido. Para lidar com esse tipo de conhecimento, é necessário:</p>
          <ul>
            <li><strong>Identificar: </strong>Reconhecer quais informações não estão explícitas. </li>
            <li><strong>Selecionar o que é relevante: </strong> Determinar quais conhecimentos devem ser compartilhados.</li>
            <li><strong>Articular no contexto certo: </strong> Tornar esse conhecimento acessível e compreensível para os stakeholders. </li>
          </ul>
          <p><strong>  Tipos de Conhecimento  </strong></p>
          <p>No contexto de desenvolvimento de produtos e projetos, o conhecimento pode ser categorizado em quatro tipos: </p>
          <ul>
            <li> <strong> Não sabe que sabe: </strong>  O indivíduo possui conhecimento, mas não tem consciência disso até ser desafiado ou questionado.     </li>
            <li> <strong> Sabe que sabe: </strong> Conhecimento consolidado e reconhecido, podendo ser facilmente aplicado ou compartilhado.     </li>
            <li> <strong> Não sabe que não sabe: </strong> Desconhecimento de algo essencial, representando um risco ao projeto.     </li>
            <li> <strong> Sabe que não sabe: </strong> Reconhece-se a falta de conhecimento sobre um assunto, permitindo buscar aprendizado ou apoio de especialistas.     </li>
          </ul>
          <p> A gestão do conhecimento exige estratégia e comunicação eficaz para garantir que as informações críticas sejam identificadas, compartilhadas e aplicadas corretamente no desenvolvimento do projeto. </p>



          <li>2.4. Desafios da Elicitação de Requisitos</li>
          <p>A elicitação de requisitos é um processo fundamental para o desenvolvimento de um sistema, pois define o que precisa ser construído e quais são as necessidades reais dos usuários e da empresa. No entanto, esse processo apresenta diversos desafios que podem comprometer o sucesso do projeto se não forem bem gerenciados.</p>
          <p><strong> Critérios de Sucesso do Projeto  </strong></p>
          <p>O sucesso de um projeto depende de três fatores principais:</p>
          <ul>
            <li> <strong> Custo : </strong>O orçamento deve ser bem planejado e controlado.      </li>
            <li> <strong>Tempo :  </strong>O cronograma precisa ser cumprido para evitar atrasos e impactos financeiros.      </li>
            <li> <strong>Satisfação :  </strong> O produto final deve atender às expectativas dos stakeholders e usuários.     </li>
          </ul>
          <p>Já o sucesso no gerenciamento do projeto envolve um equilíbrio entre:</p>
          <ul>
            <li> <strong>Custo :  </strong> Garantia de que os recursos financeiros sejam bem utilizados.     </li>
            <li> <strong>Tempo :  </strong> Cumprimento dos prazos estabelecidos.     </li>
            <li> <strong>Escopo :  </strong>Entrega das funcionalidades esperadas sem desvio nos objetivos do projeto.      </li>
          </ul>
          <p><strong> Desafios na Definição de Requisitos   </strong></p>
          <ul>
            <li> <strong> Requisitos arquiteturais: </strong> Garantir que a estrutura do sistema suporte crescimento, desempenho e escalabilidade.     </li>
            <li> <strong> Identificação de stakeholders: </strong>Encontrar as pessoas certas para fornecer informações e tomar decisões estratégicas.      </li>
            <li> <strong> Funcionalidades que ninguém usa:  </strong> Evitar desperdício de tempo e recursos em funcionalidades que não geram valor para o usuário final.     </li>
          </ul>
          <p><strong> Identificação de Stakeholders   </strong></p>
          <p>Os stakeholders são essenciais para definir os requisitos corretos. Eles podem ser:</p>
          <ul>
            <li>Líderes e gestores com influência na empresa e no projeto. </li>
            <li>Tomadores de decisão que aprovam mudanças e funcionalidades.  </li>
            <li> Especialistas no problema, que conhecem a fundo as necessidades do sistema.  </li>
            <li>Usuários finais, que interagem diretamente com o sistema e conhecem seus desafios.   </li>
            <li> Influenciadores da aceitação do sistema, que podem apoiar ou dificultar sua adoção.   </li>
            <li>Pessoas com objetivos pessoais ligados ao sucesso do projeto, como gerentes que precisam de bons resultados para sua carreira.   </li>
          </ul>
          <p>Para garantir o sucesso do projeto, é essencial envolver os stakeholders desde o início, definir requisitos claros e manter uma comunicação eficaz ao longo do desenvolvimento.</p>
        </ul>
      </div>

      <div id="modulo-2-capitulo-3" class="capitulo">
        <h2>Capítulo 3: Uso do Trello para Gestão de Requisitos – Parte I</h2>
        <p>O Trello é uma ferramenta de gerenciamento de projetos baseada no conceito de Quadro Kanban, que permite organizar tarefas de forma visual e colaborativa. Ele é amplamente utilizado para acompanhar requisitos e modelagem arquitetural, garantindo que todas as etapas do desenvolvimento sejam bem estruturadas e rastreáveis.</p>
        <p><strong>  Quadro Kanban no Trello  </strong></p>
        <p>O Quadro Kanban no Trello é composto por listas que representam diferentes fases do fluxo de trabalho. Cada tarefa é representada por um cartão, que pode ser movido entre as listas à medida que avança no processo. Um exemplo de estrutura eficiente inclui:</p>
        <ul>
          <li> <strong>Para Fazer:  </strong> Reúne todas as tarefas pendentes que precisam ser executadas.     </li>
          <li> <strong>Planejar :  </strong> Definição de escopo, levantamento de requisitos e modelagem da solução.     </li>
          <li> <strong>Executar:  </strong> Desenvolvimento e implementação das funcionalidades.    </li>
          <li> <strong>Revisar :  </strong>  Validação do que foi desenvolvido, incluindo testes e homologação.    </li>
          <li> <strong>Ajustar:  </strong> Correção de problemas e refinamentos necessários antes da entrega final.     </li>
          <li> <strong>Feito:  </strong>  Tarefas concluídas e aprovadas, garantindo rastreabilidade do progresso.    </li>
        </ul>
        <p><strong>  Benefícios do Trello na Gestão de Projetos  </strong></p>
        <ul>
          <li> Visualização clara do fluxo de trabalho e do progresso das tarefas.</li>
          <li> Colaboração eficiente entre equipes, permitindo comentários, atribuição de responsáveis e anexação de documentos.</li>
          <li>Flexibilidade para adaptar os quadros às necessidades do projeto. </li>
          <li>Facilidade na priorização de tarefas e acompanhamento do backlog. </li>
        </ul>
        <p>Ao integrar o Trello no processo de desenvolvimento, as equipes conseguem organizar melhor as demandas, otimizar a produtividade e garantir a entrega eficiente das funcionalidades.</p>
      </div>
    
      <div id="modulo-2-capitulo-4" class="capitulo">
        <h2>Capítulo 4: Uso do Trello para Gestão de Requisitos – Parte II</h2>
      </div>
    
      <div id="modulo-2-capitulo-5" class="capitulo">
        <h2>Capítulo 5: Primeira Aula Interativa – Demonstração de Projeto de Levantamento de Requisitos Arquiteturais</h2>
      </div>
    
      <div id="modulo-2-capitulo-6" class="capitulo">
        <h2>Capítulo 6: Análise de Requisitos Arquiteturais</h2>
        <p>Uma das tarefas mais importantes dos analistas de requisitos é a priorização das funcionalidades, garantindo que o time de desenvolvimento entregue o maior valor possível. Para isso, existem duas abordagens eficazes:</p>
        <p><strong>Kano Model     </strong></p>
        <p>Método que classifica os requisitos com base no impacto que causam na satisfação do usuário. Ele divide as funcionalidades em categorias como:</p>
        <ul>
          <li> <strong>Básicas (Must-have):  </strong>  Essenciais para o funcionamento do sistema.    </li>
          <li> <strong>Desempenho (Performance):   </strong> Quanto melhor forem implementadas, mais satisfeitos os usuários ficarão.      </li>
          <li> <strong> Encantamento (Delighters):  </strong>  Funcionalidades inesperadas que geram alto valor e satisfação.    </li>
        </ul>
        <p><strong> Cost of Delay (Custo do Atraso)   </strong></p>
        <p>Técnica que mede o impacto financeiro ou estratégico de adiar a entrega de uma funcionalidade. Ajuda na decisão sobre quais requisitos devem ser desenvolvidos primeiro, garantindo que o retorno sobre investimento seja maximizado.</P>
        <p>Essas ferramentas auxiliam na tomada de decisão, otimizando o planejamento e execução do backlog para que o projeto alcance seus objetivos com eficiência e impacto máximo.</p>
        <ul>
          <li><strong>6.1. Priorização de Requisitos </strong></li>
          <p>A priorização de requisitos é uma etapa essencial para garantir que o time de desenvolvimento atenda às expectativas do cliente, focando nos itens que geram mais valor. Para isso, dois modelos são amplamente utilizados:</p>
          <p><strong>  Modelo de Kano  </strong></p>
          <p>O Kano Model ajuda a categorizar funcionalidades de acordo com o impacto que têm na satisfação do usuário. Ele analisa as funcionalidades em um gráfico com dois eixos:</p>
          <ul>
            <li> <strong>  Eixo vertical: </strong>  representa a satisfação do usuário.    </li>
            <li> <strong>  Eixo horizontal:  </strong>  representa o investimento feito na funcionalidade (qualidade da implementação).    </li>
          </ul>
          <p>Esse modelo divide os requisitos em três categorias principais:</p>
          <p><strong>  Expectativas Básicas (Basic Expectations):  </strong></p>
          <ul>
            <li>São funcionalidades essenciais que o sistema precisa ter. </li>
            <li>Quando bem implementadas, são percebidas como mínimo necessário. </li>
            <li>Se mal implementadas ou ausentes, impactam negativamente a experiência do usuário. </li>
          </ul>
          <p><strong>Funcionalidades de Satisfação (Satisfiers):    </strong></p>
          <ul>
            <li>Apresentam um comportamento linear: quanto mais investimento, maior a satisfação. </li>
            <li>Se forem bem implementadas, geram alto valor. </li>
            <li>Se forem mal implementadas, prejudicam diretamente a percepção do usuário. </li>
          </ul>
          <p><strong> Funcionalidades de Encantamento (Delighters):   </strong></p>
          <ul>
            <li>São diferenciais inesperados que surpreendem positivamente os usuários. </li>
            <li> Se não existirem, não causam insatisfação, mas se forem bem implementadas, geram um grande impacto positivo.</li>
          </ul>
          <p><strong> Custo de Atraso (Cost of Delay - CoD)   </strong></p>
          <p>O Cost of Delay mede o impacto financeiro e estratégico causado pelo atraso na entrega de uma funcionalidade. Para priorizar tarefas com base nesse modelo, utilizamos a fórmula:</p>
          <p>Índice de Prioridade = Custo de atraso / Duração de implementação</p>
          <ul>
            <li> Quanto maior o custo do atraso, mais prioritária deve ser a funcionalidade.</li>
            <li>Funcionalidades rápidas e de alto impacto devem ser priorizadas. </li>
          </ul>
          <p>Além disso, diferentes tipos de funcionalidades possuem comportamentos distintos em relação ao custo do atraso, podendo variar de acordo com a criticidade para o negócio.</p>
          <p>Conclusão: A priorização eficaz garante que o time foque nos requisitos certos, otimizando tempo e recursos. O Modelo de Kano permite entender como as funcionalidades impactam os usuários, enquanto o Cost of Delay traz uma visão financeira e estratégica para decisões mais assertivas. Com essas abordagens, o desenvolvimento se torna mais eficiente e alinhado às necessidades do negócio.</p>



          <li><strong>6.2. Histórias de Usuários</strong></li>
          <p>Uma história de usuário é uma breve descrição de um requisito do ponto de vista de um usuário do sistema, essencial para promover o entendimento entre a equipe de desenvolvimento e o dono do produto. Cada história descreve o que o usuário precisa e por que isso é importante, geralmente escrita como se fosse o próprio usuário descrevendo sua necessidade.</p>
          <p>Por exemplo: "Eu, gerente, preciso acompanhar as atividades de minha equipe porque preciso garantir que as atividades sejam executadas dentro do prazo."</p>
          <p>O objetivo das histórias de usuário é promover a conversa entre a equipe de desenvolvimento e o dono do produto. Elas são intencionalmente incompletas para incentivar discussões e esclarecimentos constantes. Ao contrário de especificações formais, elas não fornecem todos os detalhes, mas exigem colaboração contínua para resolver dúvidas e esclarecer pontos. </p>
          <p>A analogia com uma foto ajuda a entender como funcionam as histórias de usuário. Inicialmente, a foto (história) pode parecer simples e sem muitos detalhes. Porém, ao contar a história por trás da foto, a imagem ganha mais contexto e significado, assim como as histórias de usuário se tornam mais claras e valiosas à medida que são discutidas com o dono do produto.</p>
          <p>As boas histórias de usuários devem ser escritas de forma que promovam alinhamento de conhecimento e compreensão entre todos os membros da equipe, com ênfase em conversas e negociações. </p>
          <p><strong>  Características de uma Boa História de Usuário  </strong></p>
          <ul>
            <li> <strong> Independência: </strong>  A história deve ser autossuficiente e não depender de outras histórias.    </li>
            <li> <strong>Negociável:  </strong>  Não deve ser vista como um contrato fechado. Deve ser aberta para discussões e ajustes.    </li>
            <li> <strong>Valiosa:  </strong>  A história deve claramente descrever o valor que ela gera para o cliente.    </li>
            <li> <strong>Estimável:  </strong>  Deve fornecer informações suficientes para que o time de desenvolvimento possa elaborar uma estimativa inicial de esforço.    </li>
            <li> <strong>Sob medida:  </strong>  A história deve ser pequena o suficiente para ser concluída em uma iteração ou sprint, considerando a capacidade do time.    </li>
            <li> <strong> Testável: </strong>  A história precisa ser clara o suficiente para permitir a definição de testes que garantam que a funcionalidade foi corretamente implementada.    </li>
          </ul>
          <p>Em resumo, histórias de usuário são uma ferramenta poderosa para entender as necessidades do usuário e garantir que o time de desenvolvimento esteja alinhado com os objetivos do negócio, sendo essencial para o sucesso do projeto.</p>
          <li><strong> 6.3. Débito Técnico </strong></li>
          <p>Durante o processo de desenvolvimento, é comum que o time tome decisões que envolvem comprometer as melhores práticas de codificação, muitas vezes por causa de prazos apertados ou da instabilidade dos requisitos. Essas decisões resultam em dívidas técnicas, que são questões no código que precisarão ser corrigidas no futuro. Embora possam ser necessárias em momentos específicos, essas escolhas podem levar a problemas acumulados, caso não sejam gerenciadas adequadamente.</p>
          <p>A gestão do débito técnico é crucial para garantir que essas questões sejam abordadas ao longo do tempo. Sem essa gestão, o produto pode se tornar cada vez mais complexo e a manutenção se tornará mais cara e difícil. Quando o débito técnico é acompanhado corretamente, o time pode planejar atividades de refatoração e correções dos problemas mais críticos, garantindo a evolução contínua do produto.</p>
          <p>Débito técnico está diretamente associado ao trabalho extra que resulta da escolha de uma solução rápida e fácil, em detrimento de uma abordagem mais eficiente e eficaz. Essas escolhas, embora convenientes no curto prazo, podem resultar em custos elevados de manutenção e desenvolvimento no longo prazo, comprometendo a qualidade do produto.</p>
        </ul>
      </div>
    
      <div id="modulo-2-capitulo-7" class="capitulo">
        <h2>Capítulo 7: Qualidade e Requisitos Arquiteturais</h2>
        <ul>
          <li><strong>7.1. Acessibilidade</strong></li>
          <p>Acessibilidade é a possibilidade de acesso a um lugar ou conjunto de lugar. No caso da web, uma interface com boa acessibilidade provê boa experiência de navegação para qualquer pessoa, independentemente de terem alguma deficiência ou não.</p>
          <p>Há diversos tipos de deficiência que podem atrapalhar a utilização de um site não acessível. A tabela abaixo relaciona algumas dessas deficiências e os potenciais problemas que podem ter</p>
          <p>Por que investir em acessibilidade: Estudos mostram que cerca de 20% da população brasileira possui algum tipo de deficiência. Certamente nem todas essas pessoas possuem incapacidades que as impeçam de utilizar um site não acessível. Mesmo que o percentual de usuário incapazes de utilizar um site não acessível seja 10% ou até 5%, é imprudente para qualquer negócio excluir tal percentual de potenciais clientes. Para uma loja on-line, por exemplo, alcançar 5% a mais de público pode representar mais vendas. Para uma rede social, representa mais usuários. Projetar um site acessível, então, é um investimento que deve ser considerado em projetos web.</p>
          <li><strong>7.2. Desempenho</strong></li>
          <p>As tecnologias de desenvolvimento web tem evoluído muito nos últimos anos. Com isso, estamos tentando fazer mais e mais coisas em nossas aplicações. Consequentemente, as aplicações estão ficando mais robustas e mais pesadas, podendo levar um longo tempo de carregamento e demora para os usuários. Dessa forma um problema tem ficado muito evidente: desempenho. Quanto mais tentamos fazer sistemas robustos, capazes de fazer muitas coisas, mais o desempenho se torna uma questão relevante para desenvolvedores. </p>
          <p>Existe um objetivo primário para se preocupar com desempenho: dar ao nosso usuário uma experiência melhor. Empresas conseguem aumentar consideravelmente a retenção de clientes e a rentabilidade de seus sites ao melhorar o desempenho da aplicação e, consequentemente, a experiência de seus usuários. </p>
          <p>Aplicações são essenciais para cada vez mais atividades fundamentais para as pessoas e o desempenho das aplicações, que não deve ser uma barreira para que elas consigam alcançar seus objetivos. </p>
          <P>Veremos várias formas de melhorar o desempenho das aplicações, mas você não precisa se preocupar em usar todas. Qualquer coisa que você puder fazer para melhorar o desempenho já poderá afetar positivamente a experiência do usuário. </P>
          <p>Os problemas de desempenho se concentram em dois pontos principais da aplicação: no carregamento da página e na renderização na página. O carregamento da página é quando todos os recursos estáticos são carregados no servidor para o navegador. Isso significa que quanto maiores forem os arquivos, maior será o tempo de carregamento. O tempo de renderização diz respeito ao tempo que demora depois que todos os arquivos essenciais foram carregados, e o navegador vai precisar trabalhar para compilar, interpretar tudo e dispor os elementos de uma maneira que seja entendível visualmente.</p>
          <p>Devemos tratar a questão de desempenho como uma questão estratégica para nossa aplicação. Vários estudos mostram que aplicações com melhor desempenho tem melhores resultados. Um site de vendas, por exemplo, poderá perder usuários ou perder vendas por conta de demora na resposta da aplicação. O usuário poderá fazer o cadastro no sistema porque aplicação demora muito, e ele acabou desistindo. Então devemos tratar desempenho como atributo diretamente ligado aos objetivos de negócio, por isso devemos decidir estrategicamente quanto tempo e esforço vamos investir para melhorar o desempenho da aplicação.</p>
          <li><strong>7.3. Usabilidade</strong></li>
          <p>Usabilidade define a facilidade com que as pessoas podem empregar uma ferramenta para realizar uma tarefa específica e importante. Dessa forma, a interface web deve ser construída para ajudar o usuário a realizar seu trabalho e chegar F informação importante de maneira efetiva. Conforme a ISO 9241-11: “Usabilidade é a medida pela qual um produto pode ser usado por usuários específicos para alcançar objetivos específicos com efetividade, eficiência e satisfação em um contexto de uso específico”. </p>
          <p>Para garantir alto grau de usabilidade, as interfaces do sistema devem contemplar os cinco atributos de usabilidade listados abaixo: Aprendizado, Eficiência, Memorização, Robustez, Satisfação</p>
          <p>Um sistema bancário é um exemplo de sistema de difícil aprendizado, mas muito eficiente. Um funcionário do banco deve ter vários treinamentos para entender os conceitos e as funcionalidades do sistema. Um usuário leigo certamente não conseguiria utilizar um software bancário sem treinamento. Entretanto, quando o usuário está familiarizado com o sistema, ele consegue chegar a seu objetivo facilmente. Utilizando apenas o teclado, com poucos comandos o funcionário do banco consegue resolver o problema de um cliente. Apesar de ser de difícil aprendizado, é bastante eficiente.</p>
        </ul>
      </div>
    
      <div id="modulo-2-capitulo-8" class="capitulo">
        <h2>Capítulo 8: Especificação e Validação de Requisitos Arquiteturais (E-book)</h2>
        <p>Como vimos até agora, o principal objetivo de uma equipe — composta por desenvolvedores, líderes, coordenadores e especialistas de negócios — é, antes mesmo de gerar modelos gráficos que representem a realidade do que o sistema deve se tornar, construir modelos de entendimento sobre como o software deve se comportar. Para alcançar o produto desejado com qualidade, dentro do prazo e orçamento, contamos com alguns recursos que auxiliam nesse processo. Assim, a modelagem não é um produto final, mas sim o meio adequado para a construção de um sistema.</p>
        <p><strong> Unified Modeling Language (UML)   </strong></p>
        <ul>
          <li>Unified Modeling Language, ou simplesmente UML, é uma linguagem que visa "permitir a comunicação" ao visualizar, especificar, construir, documentar e entender fluxos e sistemas. Surgiu na década de 1990 com a unificação de métodos no BOOCH (Object Oriented Software Engineering — OOSE) e Object Modeling Technique (OMT), tendo como mentores os renomados Grady Booch, Ivar Jacobson e James Rumbaugh (France; Koryn, 2001). Tornou-se, portanto, uma referência para modelagem de sistemas orientados a objetos e é amplamente utilizado em diversas ferramentas. </li>
          <li>A UML oferece diversos tipos de diagramas para especificar aspectos dinâmicos que descrevem como o sistema deve se comportar. Contudo, a UML não fornece um "caminho das pedras", mas sim formas de visualizar o que precisa ser feito. Podemos dividir a modelagem em dois grandes grupos: modelos comportamentais, que tratam dos aspectos dinâmicos e funcionais, e modelos estruturais. </li>
          <li>Um diagrama, em sua essência, é uma representação gráfica de informações, processos, sistemas e tudo o que pode ser expresso visualmente. Ele é utilizado para ilustrar ou exemplificar contextos, regras de negócios, fluxos de trabalho, entre outros. Diagrams são amplamente usados em diversas áreas, como engenharia, tecnologia e negócios. Como mostrado na ilustração acima, os diagramas podem ser divididos por forma de representação e geralmente possuem uma estrutura hierárquica. Embora muitos diagramas possam compartilhar características, devido à complexidade ou à proximidade hierárquica, cada um possui uma função e finalidade específicas. </li>
        </ul>
        <p><strong>  Diagramas Comportamentais  </strong></p>
        <ul>
          <li> Na modelagem computacional, um sistema é representado pela dinâmica e pelas funcionalidades que ele deve ter, sendo a modelagem comportamental responsável por isso. Os aspectos dinâmicos de um sistema descrevem como ele responderá a estímulos ou eventos vindos de fontes externas. Já os aspectos funcionais estão relacionados ao fluxo de atividades ou operações, como decisões, iterações, desvios, recursividade, entre outros. Em outras palavras, os aspectos dinâmicos descrevem “o que” o sistema deve fazer, enquanto os aspectos funcionais detalham “como” isso deve ser feito. </li>
          <li> A UML apresenta diagramas específicos para ambos os aspectos. Para os aspectos dinâmicos, temos:</li>
          <ul>
            <li> Caso de Uso</li>
            <li> Diagrama de Interação (Sequência e Colaboração)</li>
            <li> Diagrama de Transição de Estados</li>
          </ul>
          <li>Para os aspectos funcionais, destacamos:</li>
          <ul>
            <li>Descrição textual de Caso de Uso </li>
            <li>Diagrama de Atividades </li>
          </ul>
          <li>Entre os diagramas tanto para aspectos dinâmicos quanto funcionais, o diagrama de Caso de Uso é um dos mais utilizados. Ele é uma excelente ferramenta de comunicação entre os envolvidos, podendo especificar outros casos de uso e estabelecer relações diretas entre eles. </li>
          <li>Ao especificarmos a dinâmica de um caso de uso de um sistema, usamos o diagrama de caso de uso com seus respectivos relacionamentos. Por exemplo, no diagrama a seguir, temos uma relação entre "Atende Solicitação Almoxarifado" e os casos de uso específicos "Solicitação de Devolução" e "Atende Solicitação de Fornecimento". O "Atende Solicitação de Fornecimento", por sua vez, está incluído no caso "Verifica Cota". Casos como "Verifica Cota Material" e "V </li>
          <li>Para construir um diagrama de caso de uso eficaz (Booch; Rumbaugh; Jacobson, 1999), deve-se seguir algumas regras:</li>
          <ul>
            <li>O diagrama deve ter um nome. </li>
            <li> Minimizar o cruzamento de linhas.</li>
            <li>Deve apresentar um nível adequado de abstração. </li>
            <li>Relacionar casos próximos, quando houver uma relação. </li>
            <li>Apresentar apenas o agente e seu caso, para facilitar o entendimento. </li>
            <li>Evitar especificações excessivas e garantir que os aspectos importantes sejam detalhados.</li>
            <li>Focar em um aspecto do sistema dentro do seu escopo. </li>
          </ul>
          <li> Os diagramas de interação especificam os relacionamentos entre objetos com base em sua estrutura organizacional, considerando as mensagens enviadas e recebidas entre eles. O diagrama de sequência, por exemplo, além de mostrar as interações, também especifica a sequência em que elas ocorrem. Ele é frequentemente utilizado para ilustrar interações entre usuários e sistemas.</li>
          <li>Principais considerações para a criação de um diagrama de sequência:</li>
          <ul>
            <li>Definir o contexto da interação. </li>
            <li> Informar os parâmetros das mensagens.</li>
            <li>Dividir o diagrama por complexidade. </li>
            <li>A apresentação deve ser da esquerda para a direita. </li>
            <li>Informar as pré e pós-condições das mensagens. </li>
            <li>Representar a ordenação temporal das mensagens. </li>
            <li> Para objetos criados e destruídos, usar as notações apropriadas.</li>
          </ul>
          <li>No diagrama de colaboração, também conhecido como diagrama de comunicação, a interação entre objetos é o foco. Ele exibe a troca de informações e colaboração entre objetos, com a necessidade de uma ordem cronológica para dar sentido completo ao processo. Aspectos importantes:</li>
          <ul>
            <li>Nomear o diagrama. </li>
            <li>Estabelecer o contexto. </li>
            <li>Colocar as classes como vértices em um grafo. </li>
            <li>Desenhar as ligações por onde fluirão as interações. </li>
            <li>Numerar a sequência das interações. </li>
          </ul>
          <p>Por fim, o diagrama de transição de estados mostra a evolução de um sistema através de uma cadeia de estados, cada um representado por um retângulo, com transições indicadas por setas. Este diagrama é especialmente útil para sistemas com comportamento baseado em estados e ajuda a validar o comportamento lógico do sistema.</p>

          <p><strong> Diagramas Estruturais   </strong></p>
          <ul>
            <li>Os diagramas estruturais são utilizados para descrever a estrutura de sistemas ou partes deles, podendo se referir à parte física, como equipamentos, ou à parte lógica, como objetos em orientação a objetos. São frequentemente divididos em diagramas de componentes (representando a parte física), pacotes (representando a estrutura do sistema), objetos (mostrando a relação entre eles durante a execução), entre outros. </li>
            <li> Os diagramas de componentes podem ir além de representar partes físicas, incluindo também unidades funcionais, interfaces entre componentes, e estruturas arquiteturais. Eles são essenciais para identificar problemas e servir como documentação para futuras manutenções. </li>
            <li> Os diagramas de implantação representam os componentes de software e hardware de um sistema, mostrando as relações entre eles. Além disso, esses diagramas podem ilustrar a organização do sistema em pacotes e como as dependências entre pacotes e classes são estabelecidas. </li>
          </ul>

          <p><strong>Modelo Arquitetural 4+1    </strong></p>
          <ul>
            <li> Um modelo arquitetural é uma visão abstrata da realidade. Usamos modelos para capturar os elementos mais importantes, permitindo uma discussão focada e ajudando na tomada de decisões para projetos e produtos. Isso é necessário porque discutir todos os aspectos envolvidos de uma só vez seria muito complexo.</li>
            <li>O Modelo 4+1, proposto por Philippe Kruchten em 1995, organiza a descrição da arquitetura de sistemas complexos em cinco visões: quatro principais (lógica, de desenvolvimento, de processos e física) e uma visão adicional (cenários), que valida as outras quatro.</li>
            <p><strong> As Cinco Visões do Modelo 4+1:   </strong></p>
            <ul>
              <li>Visão Lógica: Foca nos aspectos funcionais do sistema, mostrando como os componentes de software suportam as funcionalidades principais. </li>
              <li>Visão de Desenvolvimento: Trata da organização estática do software, detalhando a estrutura dos arquivos de código, bibliotecas e artefatos. </li>
              <li>Visão de Processos: Foca no comportamento em tempo de execução, como concorrência, threads e processos, mostrando a dinâmica do sistema. </li>
            </ul>
          </ul>
        </ul>
      </div>
    
      <div id="modulo-2-capitulo-9" class="capitulo">
        <h2>Capítulo 9: Introdução ao Azure DevOps</h2>
      </div>
    
      <div id="modulo-2-capitulo-10" class="capitulo">
        <h2>Capítulo 10: Segunda Aula Interativa – Projeto no Azure DevOps</h2>
      </div>
    </div>

    <!-- Conteúdo do módulo 3 -->
    <div id="modulo-3">
      <h2>Módulo 3: Design Patterns, Estilos e Padrões Arquiteturais</h2>

      <div id="modulo-3-capitulo-0" class="capitulo">
        <p><strong>Capítulo 0 - Visão Geral do Módulo</strong></p>
        <ul>
          <li>0.1. Apresentação</li>
          <li>0.2. Apresentação do Módulo</li>
        </ul>
      </div>

      <div id="modulo-3-capitulo-1" class="capitulo">
        <p><strong>Capítulo 1 – Arquitetura de Software e Qualidade de Código</strong></p>
        <ul>
          <li>1.1. Introdução</li>
          <p>Qualidade de software, boas práticas de engenharia de software, principio desenvolvimento e projeto de software e técnicas e ferramentas para melhoria da qualidade. Catálogo de padrões de projeto, padrões para aplicações corporativas. Estilos e padrões arquiteturais, reconhecimento de características chaves de sistema, padrões arquiteturais e arquiteturas concentradas em domínios.</p>
          <p>A arquitetura de software, conceitos e propriedades fundamentais de um sistema considerando seu ambiente, seus elementos, seus relacionamentos e seus princípios de projeto e evolução. Como arquiteto de se preocupar com as características do sistema no vai ser construído, considerando as três partes muito importante que compõe a arquitetura de um sistema, a primeira delas define quais são as partes ou as estruturas, depois o papel dessas partes e também o relacionamento entre essas partes, e ao ambiente ao qual o software vai ser inserido</p>
          <p>As responsabilidades do arquiteto de softwares, vão muito além das decisões de alto nível do projeto. É muito importante que o arquiteto, apoie a equipe na empresa das melhores práticas de programação, zele pela qualidade e padronização do código fonte.</p>
          <p><strong> Conceitos importantes como:   </strong></p>
          <ul>
            <li> <strong> Clean Code: </strong>  Clean Code, ou "Código Limpo", é uma abordagem que enfatiza a legibilidade, simplicidade e manutenção de código. Um código limpo é fácil de entender, modificar e estender. Ele segue boas práticas de programação, como nomes claros para variáveis e funções, funções pequenas e focadas, e a eliminação de redundâncias. Clean Code busca reduzir a complexidade do código, tornando-o mais intuitivo e sustentável ao longo do tempo.    </li>
            <li> <strong> Object Calisthenics:  </strong> Object Calisthenics são um conjunto de regras e práticas criadas para melhorar a qualidade do código orientado a objetos. Elas foram projetadas para ajudar os desenvolvedores a escreverem código mais simples, mais legível e mais robusto. Alguns exemplos de regras incluem: "Não tenha mais de 2 argumentos em um método", "Evite o uso de loops", "Use apenas um nível de indentação por método" e "Nunca use null". O objetivo é promover uma programação mais limpa e bem estruturada, alinhada com os princípios da orientação a objetos.     </li>
            <li> <strong> TDD (Test-Driven Development): </strong> O TDD, ou Desenvolvimento Orientado a Testes, é uma metodologia de desenvolvimento de software onde os testes são escritos antes do código. O processo segue um ciclo contínuo de três etapas: Red (escrever o teste que falha), Green (escrever código suficiente para passar o teste), e Refactor (melhorar o código sem alterar seu comportamento). O TDD visa garantir que o código funcione como esperado desde o início e facilita a refatoração e manutenção, promovendo uma abordagem mais segura e eficiente para o desenvolvimento.     </li>
            <li> <strong> SOLID: </strong> SOLID é um acrônimo que representa cinco princípios fundamentais de design de software orientado a objetos. Eles são:      </li>
            <ul>
              <li> <strong> S - Single Responsibility Principle (SRP):  </strong>  Cada classe deve ter apenas uma responsabilidade, ou seja, um motivo para mudar.     </li>
              <li> <strong> O - Open/Closed Principle (OCP): </strong>  O software deve ser aberto para extensão, mas fechado para modificação.    </li>
              <li> <strong> L - Liskov Substitution Principle (LSP): </strong>  Objetos de uma classe derivada devem poder substituir objetos da classe base sem alterar a funcionalidade.    </li>
              <li> <strong> I - Interface Segregation Principle (ISP):  </strong>  Os clientes não devem ser forçados a depender de interfaces que não utilizam.    </li>
              <li> <strong> D - Dependency Inversion Principle (DIP):  </strong>  As classes de alto nível não devem depender de classes de baixo nível; ambas devem depender de abstrações.    </li>
            </ul>
          </ul>
          <p><strong> Patterns   </strong></p>
          <ul>
            <li>Design Patterns, ou Padrões de Projeto, são soluções reutilizáveis para problemas comuns de design que ocorrem em sistemas de software. Eles ajudam a estruturar o código de maneira eficiente e com boa manutenção, evitando reinventar a roda. Alguns dos padrões mais conhecidos incluem o Singleton, Factory, Observer, Strategy, entre outros. Os padrões ajudam os desenvolvedores a implementar soluções comprovadas e bem estruturadas para problemas específicos no design de software. </li>
          </ul>
          <p><strong> Code Smells   </strong></p>
          <ul>
            <li>Code Smells (ou "cheiros de código") referem-se a sinais ou indícios de que o código pode ser melhorado. Eles não são erros de sintaxe, mas sim práticas que podem levar a problemas de manutenção e evolução do software. Alguns exemplos de code smells incluem duplicação de código, funções ou classes com muitas responsabilidades, e métodos longos. Identificar e corrigir code smells pode ajudar a melhorar a qualidade do código e facilitar futuras modificações e refatorações. </li>
          </ul>
          <p><strong> Análise Estática de Código   </strong></p>
          <ul>
            <li> A Análise Estática de Código é uma técnica que examina o código fonte sem executá-lo, com o objetivo de encontrar possíveis erros, vulnerabilidades ou padrões que possam comprometer a qualidade do software. Ferramentas de análise estática de código verificam o código em busca de questões como violação de padrões de codificação, código duplicado, complexidade excessiva e possíveis bugs. Ela é essencial para garantir que o código atenda aos requisitos de qualidade e desempenho antes de ser executado em ambientes de produção. </li>
          </ul>
          <p>Esses conceitos formam a base de boas práticas de desenvolvimento e são fundamentais para garantir a qualidade, manutenibilidade e flexibilidade do software ao longo de seu ciclo de vida.</p>
          <p>Conclusão a arquitetura de software é uma disciplina diretamente relacionada com a qualidade final dos produtos de software. Demanda o conhecimento sobre diversas práticas e princípios. Tais princípios são fundamentais para o trabalho das equipes se transforme um trabalho de engenharia.</p>

          <li><strong>1.2. Code Smells </strong></li>
          <p>Alguns softwares possuem uma característica indesejada, entregam o resultado funcional esperado aos usuários, mas possuem problemas em suas estruturas internas. Praticas indevidas e outras funcionalidades vão sendo incorporadas usando como base as, mas definições que foram tomadas nas fases anteriores do projeto. </p>
          <p>Embora não impactem diretamente a execução dos sistemas, eles têm grande potencial de se tornarem efetivamente bugs, comprometerem o entendimento e a manutenção.</p>
          <p><strong>  Bloaters  </strong></p>
          <p>Bloaters (ou "inchaços") são code smells que surgem quando uma parte do código se torna excessivamente grande e difícil de manter. Esses problemas ocorrem quando o código cresce sem controle, tornando-se mais difícil de entender, modificar e testar.</p>
          <ul>
            <li> <strong> Long Method: </strong> Métodos com muitas linhas de código.     </li>
            <li> <strong>  Large Class: </strong>  Classes que acumulam muitas responsabilidades, tornando-se grandes e difíceis de entender.    </li>
            <li> <strong> Long Parameter List:  </strong>  Métodos ou funções com muitos parâmetros, dificultando a compreensão e uso.    </li>
          </ul>
          <p><strong>  Object-Orientation Abusers  </strong></p>
          <p>Os Object-Orientation Abusers são code smells relacionados ao uso incorreto ou inadequado dos conceitos de orientação a objetos. Eles ocorrem quando se faz um uso excessivo ou errado dos princípios da orientação a objetos, prejudicando a estrutura e a flexibilidade do sistema.</p>
          <ul>
            <li> <strong>Data Clumps  </strong> Agrupamento de dados relacionados que poderiam ser encapsulados em uma classe.     </li>
            <li> <strong> Switch Statements: </strong>O uso excessivo de instruções de switch em vez de utilizar o polimorfismo, o que viola o princípio da orientação a objetos e diminui a flexibilidade do código.      </li>
            <li> <strong>Refused Bequest:   </strong>   Quando uma classe filha herda métodos de uma classe pai, mas não os utiliza, violando o princípio da herança.   </li>
          </ul>
          <p><strong> Chance Preventers   </strong></p>
          Os Chance Preventers (ou "impedidores de oportunidades") são code smells que limitam a flexibilidade e a capacidade do sistema de se adaptar a mudanças. Eles restringem o código ao impedir que novas opções e soluções sejam exploradas.
          <ul>
            <li> <strong> Divergent Change: </strong> Quando diferentes partes de um sistema precisam ser alteradas simultaneamente, mas essas partes são modificadas de maneira independente, tornando o código mais propenso a erros.     </li>
            <li> <strong> Shotgun Surgery:  </strong> Quando uma pequena mudança no sistema exige que várias classes ou arquivos sejam alterados, aumentando a complexidade e o risco de introduzir erros.    </li>
            <li> <strong> Feature Envy: </strong> Quando um objeto ou classe precisa de dados de outro objeto de forma excessiva, o que indica que a responsabilidade pode estar mal distribuída entre as classes.     </li>
          </ul>
          <p><strong>  Dispensables  </strong></p>
          <p>Os Dispensables (ou "desnecessários") são code smells que indicam que algum código ou estrutura não tem utilidade ou não está contribuindo para o funcionamento do sistema. Eles aumentam a complexidade sem agregar valor real.</p>
          <ul>
            <li> <strong>Duplicate Code:  </strong>  Quando o código se repete em várias partes do sistema, aumentando a manutenção e o risco de inconsistências.    </li>
            <li> <strong>Dead Code:   </strong> Código que não é mais utilizado, mas que permanece no sistema, ocupando espaço e tornando o código mais difícil de entender.     </li>
            <li> <strong>Commented-out Code:  </strong>Código que foi comentado e não está sendo executado, mas que ocupa espaço no código, prejudicando sua legibilidade.      </li>
          </ul>
          <p>Essas categorias de Code Smells são sinais de que o código pode ser melhorado. Identificar e corrigir essas falhas pode levar a um código mais modular, flexível e fácil de manter. Ao seguir as boas práticas de design, como aplicar os princípios SOLID e refatorar o código regularmente, esses code smells podem ser minimizados, resultando em um software de maior qualidade e longevidade.</p>
          
          <ul>
            <li>1.2.1. Code Smells – Bloaters</li>
            <p>Os code smells do tipo bloaters referem-se a problemas causados pelo crescimento desordenado da estrutura do código, como métodos e classes, o que compromete a manipulação e manutenção do código. Esses problemas geralmente surgem ao longo do tempo, especialmente quando débitos técnicos não são sanados. Os principais exemplos dessa categoria incluem:</p>
            <ul>
              <li> <strong> Long method:  </strong>Métodos com muitas linhas de código.      </li>
              <li> <strong> Large class:  </strong>  Classes com muitos campos, métodos e linhas de código.    </li>
              <li> <strong>	Primitive obsession:  </strong> Uso excessivo de tipos primitivos em vez de objetos pequenos.     </li>
              <li> <strong> Long parameter list:  </strong>  Métodos com muitos parâmetros na assinatura.    </li>
              <li> <strong> Data clumps:  </strong> Agrupamento repetido de variáveis ou atributos em diferentes partes do código.      </li>
            </ul>
            <p>Esses code smells estão relacionados ao crescimento descontrolado do código e tendem a surgir à medida que o sistema evolui, frequentemente como resultado de falta de boas práticas de desenvolvimento ou conhecimento inadequado sobre o software.</p>
            <li>1.2.2. Code Smells – Couplers</li>
            <p>As causas dos code smells desta categoria são: Acoplamento excessivo entre classes e uso excessivo de delegação;</p>
            <ul>
              <li> <strong> Feature envy:  </strong> um método acessa mais dados de outro objeto do que seus próprios dados.     </li>
              <li> <strong> Inappropriated intimacy:  </strong>  uma classe acesso métodos ou atributos internos de outro classe.    </li>
              <li> <strong> Message chains: </strong>  um conjunto de métodos onde a implementação deles apenas chama outro método;    </li>
              <li> <strong> Middle man:  </strong>  uma classe que executa apenas uma ação a delega todos o restante do trabalho para outras classes.     </li>
            </ul>
            <p>Conclusão, os code smells do tipo couplers estão relacionados a violação dos princípios de coesão e acoplamento da O.O. Eles podem acontecer tanto por uso acessivo do acoplamento, quanto por excesso de delegação das responsabilidades para outras classes.</p>
          
          </ul>
          <li>1.3. Análise Estática de Código</li>
          <p>Avaliação do código, durante a análise, é possível aplicar diferentes regras para identificar, por exemplo: </p>
          <ul>
            <li>Presença de erros comuns de programação; </li>
            <li>Violação de política de nomenclatura; </li>
            <li>Códigos candidatos a refatoração; </li>
            <li>Testes de segurança; </li>
          </ul>
          <p><strong> No pipeline de CI/CD:   </strong></p>
          <ul>
            <li>Os benefícios capazes de desempenhar análises, de forma: Sistêmica, Consistente, Eficiente e Antecipada; </li>
            <li>Permite identificar uma vasta gama de deficiências, sintetizar e aplicar conhecimentos de especialistas, extrair e avaliar métricas, aplicar padrões de codificação e fornece feedback imediato; </li>
            <li>Permite algumas métricas representa unidades de tamanho de parte do código fonte como: Lines of code (LOC), Number of attibutes (NOA), Number of methods (NOM). Outras representam características da estrutura e relacionamento das classes: Wighted method per class (WMC), Lack of cohesion in methods (LCOM) e depth of inheritance tree (DIT). </li>
            <li>Threshold é uma abordagem que pode ser adotada e determinadar um threshold. Em uma análise baseada em threshold o resultado permite determinar quando um atributo está acima ou abaixo do valor esperado. Devem ser sempre monitorados e recalibrados. </li>
            <li>A definição de um threshold pode ser feita com base em: Referência (normas, padrões, etc), Benchmarks em um conjunto de sistemas, benchmarks de mercado e experiência profissional; </li>
            <li>Analise estática de código e code smells, diversos code smells estão diretamente relacionados a uma ou mais métricas, como exemplo: Long method, Large class, feature envy; </li>
          </ul>
          <p>Conclusão, a análise estática é uma prática importante para identificar diversos tipos de problemas em sistema, em tempo de compilação. É possível utiliza-la para extrair métricas do cpodigo e identificar code smells.          </p>
 
        </ul>
      </div>

      <div id="modulo-3-capitulo-2" class="capitulo">
        <p><strong>Capítulo 2 – Catálogos de Padrões</strong></p>
        <ul>
          <li>2.1. Introdução aos Catálogos de Padrões</li>
          <p>Arquitetura é uma das principais disciplinas da Engenharia de Software. Os produtos resultantes de seus processos contribuem de forma substancial para a garantia dos atributos de qualidade de um software. Além disso, a arquitetura envolve definições das partes elementares de um sistema e, portanto, espera se que todas sejam fundamentadas em práticas de engenharia. </p> 
          <p>Um arquiteto deve ser capaz de identificar características relevantes dos principais problemas que ocorrem durante o ciclo de vida de um software e propor soluções efetivas. Para auxiliar esse processo existem diversas propostas de padrões. Christopher Alexander define padrões como uma entidade que descreve um problema que ocorre repetidas vezes em um ambiente e apresenta uma essência de solução para esse problema, de tal forma que a solução possa ser replicada milhões de vezes sem nunca produzir resultados idênticos. Padrões são utilizados como templates para solucionar problemas recorrentes que se manifestam ao longo do ciclo de vida de um software. Por se tratarem de propostas amplamente testadas e bem documentadas, os padrões contribuem para garantir a qualidade do produto. Além disso, os padrões colaboram para a redução dos riscos dos projetos e para o estabelecimento de um vocabulário comum entre os profissionais, sejam desenvolvedores, testers, arquitetos, etc. Padrões na Arquitetura de Software têm sido estudados por décadas. Dado o grande número de propostas, eles são frequentemente organizados e divulgados em catálogos. Os catálogos concentram padrões com algum uso em comum, seja pelo tipo de problema ao qual se propõem a resolver ou por características das aplicações ao qual podem ser aplicados. </p>
          <p><strong> A documentação dos padrões frequentemente possui os seguintes elementos:    </strong></p>
          <ul>
            <li>Nome: descreve de forma sucinta o padrão;  </li>
            <li>Problema: define o problema que o padrão se propõe a resolver e quando o padrão deve ser utilizado.  </li>
            <li>Solução: descreve como o padrão propõe resolver o problema.  </li>
            <li> A solução deve ser sempre apresentada de forma genérica para possibilitar que o padrão seja aplicado em diferentes domínios de problemas e de forma independente de tecnologia. É comum a solução descrever os elementos, os relacionamentos entre os elementos e suas responsabilidades.  </li>
            <li>Resultados e consequências: descrevem os benefícios da adoção do padrão e suas consequências de forma a fundamentar a possível utilização ou não do padrão. Podem conter, por exemplo, impactos na flexibilidade, extensibilidade, portabilidade e manutenibilidade.  </li>
            <li> </li>
          </ul>
          <p><strong>  Existem diversos catálogos de padrões na literatura e alguns são enumerados na lista a seguir:   </strong></p>
          <ul>
            <li>GoF: um dos catálogos de padrões mais conheci dos e utilizados. Apresenta vinte e três padrões para solução de problemas frequentemente encontrados no desenho (projeto) de softwares orientados a objetos. Publicado no livro Design Patterns Elements of Reusable Object-Oriented Software de Gama et al.  </li>
            <li>AntiPatterns: catálogo de padrões que usa uma abordagem diferente dos demais. Ele apresenta soluções ruins, que não devem ser utilizadas, para problemas de projeto e codificação de software. Tais soluções podem comprometer a compreensão, a evolução e a manutenção do código fonte. Publicado no livro AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis de Brown et al.  </li>
            <li>Pattern Oriented Software Architecture (POSA): focado em padrões para desenvolvimento de sistemas de missão-crítica, muito utilizados no desenvolvimento de sistemas operacionais, servido res web, middlewares e softwares de plataforma. Publicado no livro Pattern-Oriented Software Architecture Volume 1: A System of Patterns de Buschmann et al.  </li>
            <li>Patterns of Enterprise Application Architecture (POEAA): apresenta diversos padrões para “aplicações corporativas”, com foco nas linguagens .Net e Java. Publicado no livro Patterns of Enterprise Application Architecture de Martin Fowler. 2  </li>
            <li> Design Patterns, Estilos e Padrões Arquiteturais </li>
            <li> DDD Patterns: discute padrões relevantes para equipes que utilizam a metodologia Domain Dri ven Design. Os detalhes de alguns padrões de DDD podem ser consultados no livro Patterns, Principles, and Practices of Domain-Driven Design de Scott Millett e Nick Tune. </li>
            <li> SOA Patterns: o livro Patterns: Service-Oriented Architecture and Web Services de Endrei et al. apresenta um catálogo com diversos padrões para solução de problemas frequentes na implementação de arquiteturas orientadas a serviços (SOA). Os padrões envolvem questões de projeto de arquitetura SOA, implementação de barramento de comunicação, descoberta de serviços, dentre outros. </li>
          </ul>
          <li>2.2. Patterns of Enterprise Application Architecture</li>
          <p>Padrões de Acesso a Dados e Sistemas Distribuídos - Martin Fowler</p>
          <p><strong>  Padrões de Acesso a Dados:  </strong></p>
          <p>Na arquitetura de software, requisitos como persistência de dados têm impacto significativo na qualidade do sistema. Martin Fowler, em seu livro Patterns of Enterprise Application Architecture, descreve vários padrões de acesso a dados que podem ser utilizados para resolver problemas comuns encontrados em diferentes fontes de armazenamento de dados, como bancos de dados relacionais, NoSQL, arquivos, entre outros.</p>
          <ul>
            <li> <strong> Active Record:  </strong> O padrão Active Record é usado quando as regras de persistência de dados são simples. Ele combina dados e comportamentos do negócio em um único objeto, simplificando o acesso à persistência. Nesse modelo, o objeto é responsável por carregar e salvar seus próprios dados no banco.     </li>
            <li> <strong>Data Mapper:   </strong>   O padrão Data Mapper é utilizado para separar os objetos do domínio do código de persistência. Ele atua como uma camada de mapeamento, traduzindo conceitos de orientação a objetos para a linguagem do banco de dados, permitindo que os objetos do domínio e a base de dados evoluam independentemente.    </li>
            <li> <strong> Unit of Work:  </strong>  O padrão Unit of Work gerencia transações, garantindo que todas as operações (inclusões, exclusões e modificações) em objetos afetados por uma transação sejam salvas no banco de dados de forma consistente. Este padrão é amplamente utilizado em aplicações web, onde cada requisição HTTP é tratada como uma transação independente.     </li>
            <li> <strong> Repository:  </strong>  O padrão Repository fornece uma camada intermediária entre o código do domínio e a fonte de persistência. Ele centraliza a lógica de acesso aos dados, oferecendo um local único para montar queries e aplicar regras de persistência. Esse padrão é útil em aplicações com múltiplos domínios ou consultas complexas.    </li>
            <li> <strong>  </strong>      </li>
          </ul>
          <p><strong> Padrões para Sistemas Distribuídos:   </strong></p>
          <p>Em sistemas distribuídos, a comunicação entre componentes e a integração com fontes externas podem ser desafiadoras. Fowler descreve alguns padrões que visam resolver problemas comuns neste tipo de arquitetura.          </p>
          <ul>
            <li> <strong> Gateway: </strong>  O padrão Gateway propõe o encapsulamento de acesso a recursos externos, como bancos de dados ou APIs, por meio de um objeto que remove o acoplamento entre a aplicação e a dependência externa. Isso reduz a complexidade, permitindo que a lógica da aplicação não precise lidar diretamente com os detalhes da fonte externa.    </li>
            <li> <strong>Service Hub:   </strong> O padrão Service Hub ajuda a mitigar problemas de desempenho durante testes, substituindo dependências externas por objetos stub. Isso permite que o teste se concentre na aplicação sem ser impactado por serviços externos lentos ou com falhas, melhorando a eficiência dos testes. </li>
            <li> <strong> Registry: </strong>   O padrão Registry oferece transparência de localização em sistemas distribuídos. Ele permite que clientes descubram a localização de serviços e recursos distribuídos dinamicamente, sem precisar de informações prévias sobre o servidor, tornando o sistema mais flexível e adaptável.    </li>
            <li> <strong> Remote Facade: </strong> No contexto de sistemas distribuídos, a comunicação entre objetos remotos é afetada pela latência da rede. O padrão Remote Facade sugere agrupar várias chamadas granulares em uma única chamada para reduzir o impacto da latência. O Remote Facade atua como um ponto único de acesso para múltiplas operações remotas, melhorando a performance da comunicação.     </li>
          </ul>
          <p> Conclusão: Esses padrões ajudam a enfrentar desafios comuns no desenvolvimento de sistemas corporativos e distribuídos. Ao aplicar os padrões descritos por Fowler, os arquitetos de software podem melhorar a modularidade, a flexibilidade e a escalabilidade dos sistemas, além de garantir maior eficiência e manutenção a longo prazo. </p>
          <li><strong> 2.3. Design Patterns – GoF</strong></li>
          <p>A definição de um threshold pode ser feita com base em: Referência (normas, padrões, etc), Benchmarks em um conjunto de sistemas, benchmarks de mercado e experiência profissional;  </p>
          <li><strong>2.4. Anti Patterns</strong></li>
          <p>A definição de um threshold pode ser feita com base em: Referência (normas, padrões, etc), Benchmarks em um conjunto de sistemas, benchmarks de mercado e experiência profissional;</p>
        </ul>
      </div>

      <div id="modulo-3-capitulo-3" class="capitulo">
        <p><strong>Capítulo 3 – GoF – Padrões de Criação</strong></p>
        <ul>
          <li><strong>3.1. Singleton</strong></li>
          <p>A definição de do padrão singleton ele atua sobre controle de instâncias de um objeto então Imagine que nós temos um determinado recurso vai ter um arquivo de configuração um sócrate de rede onde diversos processos podem consumir esse recurso na primeira execução quando esse recurso foi demandado nós vamos criar uma Instância de um objeto cliente e esse objeto cliente vai fazer o acesso ao recurso compartilhado quando uma nova execução acontecer o padrão final de utilizamos é criar uma nova Instância desse consumidor e essa Nova Instância afeta o recurso compartilhado e assim sucessivamente porém alguns recursos podem apresentar problemas se forem acessados por objetos diferentes consequentemente nas pernas três execuções em um sistema implementado com essa primitiva de comunicação nós vamos ter problemas dos mais diversos por acessar o recurso compartilhado ou três objetos simultaneamente cada um símbolo tem como proposta controlar o acesso a esses recursos quando a primeira execução acontecer nós vamos criar o objeto cliente desse recurso e em seguida quando a segunda ou a terceira execução surgirem elas vão compartilhar o mesmo objeto que existe atualmente e foi criado pela primeira execução dessa forma seja quantos objetos tentarem acessar esse recurso compartilhado todos eles vão utilizar apenas um cliente um consumidor o padrão sington.</p>
          <p>Ele garante que existirá uma única Instância de uma classe e somente uma forma de obter essa distância única E além disso essa Instância vai ser criada sob demanda sem nenhuma execução demandar o acesso àquele recurso compartilhado ela não vai ser criada dentro do sistema Em contrapartida o primeiro fato de existir o padrão siga como sistema pode eventualmente estar mascarando o problema de projeto dentro do sistema então nós precisamos realmente avaliar se aquela implementação do símbolo ela pode ser fatorada ou se ela realmente necessária ele requer tratamentos especiais como nós vimos Principalmente quando existe a possibilidade do alto índice de paralelismo e concorrência e aquelas equipes que usam testes unitários podem encontrar algumas dificuldades para gerar os moques dos objetos que são símbolos uma vez que existe um controle de qual Instância vai ser criada e tem um ponto único baseado métodos estáticos pode ser um pouco mais difícil complementar os testes unitários pelo sistema eu acho que precisamos ponderar os benefícios negativos se aplica as nossas necessidades nessa hora nós vimos que é possível controlar o ciclo de vida de um objeto garantindo que vai existir somente uma distância desse objeto durante toda a execução do sistema e nós podemos fazer uma analogia de que o pai é um síndico ele é uma evolução das variáveis globais que existem nos paradigmas da programação.</p>
          <li><strong>3.2. Builder</strong></li>
          <p>O padrão de criação Builder é utilizado para simplificar a criação de objetos complexos, onde a construção envolve múltiplas etapas, como inicialização de atributos, construção de objetos dependentes e obtenção de recursos compartilhados. Esse padrão permite a criação de diferentes representações de objetos por meio do mesmo construtor, tornando o processo mais flexível e organizado. Ele viabiliza a criação de objetos complexos de forma progressiva, facilitando a compreensão das etapas envolvidas.</p>
          <p>Entre os pontos positivos, destaca-se a flexibilidade na construção de objetos e a possibilidade de reutilizar etapas de criação, permitindo a materialização de diferentes tipos de objetos conforme o contexto. Além disso, o padrão contribui para a coesão das classes, alinhando-se aos princípios de responsabilidade única, ao separar a criação de um objeto de sua funcionalidade. </p>
          <p>Porém, o uso do padrão Builder pode aumentar a complexidade do projeto e das classes, tornando a implementação mais difícil de gerenciar, especialmente quando as etapas de construção se tornam recursivas ou exigem a criação de tipos concretos diferentes. Apesar disso, o padrão oferece uma abordagem consistente para a criação de objetos complexos.          </p>
          <li><strong>3.3. Factory Method </strong></li>
          <P>O padrão de criação é alguns conceitos de muitos sistemas possuem diferentes variações E além disso algumas etapas de criação da inicialização desses conceitos são comuns então nós temos uma árvore de heranças com diferentes níveis a criação aqui é a criação desses diferentes produtos conceitos dessa árvore de herança e dentro delas nós temos etapas comuns de criação de todos os tipos de produtos porém dentro do processo de criação ainda existem algumas etapas que são específicas de acordo com o produto que está sendo criado padrão nessa estrutura ele permite representar esse tipo de problema criando uma solução para ele e qualquer proposta imagine nós temos a necessidade de criar uma fábrica de sorvetes então quando uma classe do nosso sistema tem um papel de consumidor de clientes precisa produzir um sorvete dentro do padrão a inicialização do sorvete para uma fábrica porém o consumidor não vai chegar para fábrica de cria um sorvete de morango ou cria um sorvete de chocolate ou cria um sorvete de baunilha o cliente ele vai acionar a fábrica informar o tipo do sorvete que ele deseja e a fábrica tem um papel de construir o objeto real porém algumas etapas são comuns a todos os tipos de produtos nós temos um produto com diferentes tipos ou seja existem variações a materialização desses produtos Como obter o copinho ou a casquinha e decorar ele com a casinha Em contrapartida o sorvete sim produzido ele é específico de cada tipo de produto Então essa alergia ilustra a proposta do padrão a fábrica ela vai permitir que sejam criados diferentes tipos de produtos nós somos reutilizar as etapas comuns no caso porém conseguindo cumprir as etapas específicas de pegar um sorvete de morango ou chocolate. </P>
          <p>Ele viabiliza a construção de diferentes tipos de objetos em uma estrutura de herança onde cada classe filha pode determinar o comportamento de algumas etapas do processo de inicialização.</p>
          <li>3.4. Abstract Factory</li>
          <p>o padrão de criação abstratica alguns software são classificados como linhas do produtos de software que que significa isso eles demandam combinações diferentes de tipos de produtos e cada contexto de execução pode dominar uma combinação diferente as linhas de produtos de software são aqueles sistemas onde nós temos diferentes requisitos muitas vezes não funcionais como uma certa bancada um mecanismo de autenticação login e para cada um desses requisitos nós temos diferentes implementações eu posso ter o mecanismo de persistência como implementação posso ter um log com diferentes bibliotecas de lá alguém passa ter autenticação com diferentes algoritmos de autenticação e um software que é uma língua de produto eu posso na hora empacotar ele com persistência e autenticação com isso por exemplo e esse mesmo software por um outro contexto eu posso empacotar ele ou executá-lo com persistência no ciclo o log semi-log e autenticação e além do texto essas variações nós precisamos ter na linha de produtos software essa capacidade de combinar todos os tipos de produtos gerando a expectativa do cliente com mais em cada contexto Então esse padrão ele é diferente muitas vezes as pessoas acaba confundindo mas o papel dele é atuar em linha de produtos uma vez nós temos essa necessidade ele pode viabilizar a criação dessas famílias de produtos relacionados de forma que não há necessidades concretas dos objetos ou seja quando eu preciso de um determinado tipo de produto para usá-lo eu vou me basear em Abstrações desse produto sem me preocupar que na hora de execução eu vou ter uma persistência transparente os meus objetos consumidores. Compatibilidade entre objetos criados para cada Factor e ele remove o acoplamento entre os objetos Concretos e os seus consumidores uma vez que ele se baseiam em Abstrações Em contrapartida ele apresenta um nível maior de complexidade porém considerando que nós temos a demanda a necessidade de uma linha de produtos de software é a sua complexidade adicional pode se fazer valer. O padrão abstract Factor flexibiliza a criação de família de objetos garante a compatibilidade entre objeto criados e remove o acoplamento entre cliente e o produto concreto.</p>
        </ul>
      </div>

      <div id="modulo-3-capitulo-4" class="capitulo">
        <p><strong>Capítulo 4 – GoF – Padrões Estruturais</strong></p>
        <ul>
          <li><strong>4.1. Adapter</strong></li>
          <p>A definição de um padrões estruturais do catálogo falando do padrão a tendência que nós temos atualmente é reutilizar cada vez mais aplicação delegadas componentes e outras estruturas que se sentem porém muitas vezes nós nos deparamos com situações onde uma classe legada do sistema que já existe já é utilizada por diferentes pontos do sistema e por algum motivo não pode ser evoluída porque não é Nossa ou porque usa uma tecnologia mais antiga ou porque ainda nós não temos tempo hábil para poder fatorar essa classe e nós precisamos criar um novo código do cliente e vai utilizar porém o código do cliente ele espera um contrato que é distinta do que legal parece o problema é rápido</p>
          <p>Tem como proposta viabilizar a comunicação do cliente com a classe delegada mesmo eles tendo interfaces diferentes a proposta desse padrão É permitir que as classes clientes utilizam diferentes implementações de um conceito de forma Universal nós vimos que a classes podem ter interface diferente mas Além disso podem acontecer cenários onde a classe delegada tem duas implementações distintas é uma só então ele vai gerar uma interface comum estabelecida para que as clientes possa se comunicar com aquelas legais sendo ela uma ou duas ou quantas forem necessárias essa proposta inclui a criação adaptador a implementação incompatível ou seja nós vamos modelar qual é a visão oficial a visão padrão caso alguma classe legada implemente Essa visão padrão ela vai ser transparente com os consumidores porém aquelas que forem compatíveis vão ter adaptadores que traduzem as visões para que a cliente não precise tomar decisões fazer inspeções e qual delegada para tornar mais terrível. </p>
          <p>A proposta de solução do padrão permite definir uma representação padrão para um conceito dentro do sistema e por meio dela utilizar diferentes implementações de forma uniforme.</p>
          <li><strong>4.2. Facade</strong></li>
          <p>Existem no Sistema uma classe complexa ou ainda um componente complexo essa classe ela pode ser uma classe do sistema ou uma classe de terceiros que ela tem uma série de comportamentos e nós temos dentro de nosso sistema uma classe cliente com alguma determinada lógica que alteracionada vai consumir a estrutura dessa classe completa porém muitas vezes o uso dessa classe pode não ser trivial pode demandar várias chamadas a nível de granulares para métodos dessa classe ela pode ter problemas de coesão de acopramento</p>
          <p>E com isso se eu tenho somente uma classe cliente esses possíveis problemas nessa classe podem não ser significativos mas na medida eu começo a ter outras funcionalidades do nosso sistema se comunicando com essa classe eu vou ter efetivamente diferentes pontos do sistema com a replicação dessa lógica complexa de consumo desse método </p>
          <p>Às vezes o Mero o fato de eu conseguir reutilizar confiança com a delegação ou qualquer outro recurso da orientação do projeto resolvem esse problema de duplicidade porém eu posso encontrar limitações onde essas classes não possuem uma representação comum e como nós já sabemos não é interessante eu ter essa regra tem implementada em diferentes pontos principalmente sendo classes do sistema com conhecimento ele fazia de outra classe que pode nem ser do nosso sistema e amanhã eu troco essa classe Porque troquei o fornecedor por exemplo eu vou ter inúmeros pontos do sistema sendo alterados Esses são exemplos de problemas onde o padrão com ele nós vamos criar uma interface de comunicação com essa classe complexa as classes consumidores do nosso sistema sempre que precisarem acessar a classe complexa bom se basear na fachada e a fachada ela vai simplificar o uso da numerações necessárias para cumprir uma única responsabilidade Então ela absorve para ela a necessidade de conhecer essa classe complexa E além disso ela simplifica esse acesso gerando uma representação interna do sistema Ou seja eu consigo representar o negócio com base na Ótica do nosso sistema e não com base na Ótica de fornecedor com essa classe eu preciso apenas escrever a fachada se outra classe do sistema passa a necessidade daquela operação eram três chamadas de métodos todas elas Agora acessar a facada vamos dizer uma demonstração prática de como esse padrão pode ser implementado e as características particularidades. Como nós vimos o padrão permite isolar sistemas de artefatos de terceiros e artefatos complexos ele permite simplificar o uso de objetos complexos ou com problemas de desenho.</p>
          <li><strong>4.3. Flyweight</strong></li>
          <p>o padrão Flyweight não tem execução de sistema uma classe pode dar origem a diversos objetos porém em alguns casos parte do estado ou seja os atributos desses objetos pode ser igual pode ser compartilhada pelas várias instâncias que existem naquele objeto se esses dados não forem compartilhados entre essas instâncias vai haver um consumo desnecessário de memória que pode comprometer a performance do sistema Então esse padrão tem como objetivo atacar o consumo excessivo de memória ele é duplicação de estados de atributos de objetos que tem valores em comuns são iguais porém muitas vezes acabamos gerando referências de memórias duplicadas para guardar o mesmo dado Otimizar o uso de memória por meio do compartilhamento desses estados comuns entre as diferenças distâncias de objetos de uma classe vamos ver como esse padrão pode ser implementado tem como ideia Central reduzir o consumo de memória eliminando a duplicidade de estados de objetos que são comuns as diferentes instâncias que existem durante a execução do sistema a proposta de solução desse padrão contempla a criação de um contexto uma Factor e os n objetos que vão existir que são representados como esses objetos. Essa é a essência na solução do padrão como nós vemos padrão Flyweight torna possível reduzir consideravelmente o consumo de memória quando existe uma quantidade grande de objetos similares que são compartilhados entre diferentes classes de um sistema.</p>
          <li>4.4. Composite</li>
          <p>O padrão serviços e manipulados como uma composição, ou seja, como um todo e uma vez que nós desempenhamos uma ação sobre esse objeto sobre isso conceito todas as partes que formam esse elemento único podem sofrer a relação </p>
          <p>O padrão comparsa ele propõe por árvores de objetos de formas complexas com quantos níveis forem necessários E além disso nós vamos ter a possibilidade de consumir essa estrutura como um único objeto e durante o uso todas as objetos dessa estrutura podem ser acessados individualmente e quando eu desempenhar uma ação com aquele objeto que representa a estrutura todas as partes vão ser acionadas e podem Executar a sua responsabilidade dentro da estrutura. Permite manipular composições complexas e objetos como unidade ele utiliza o conceito polimorfismo para permitir objetos de tipos concretos distintos sejam utilizados e o uso da recursividade viabiliza estruturas de diferentes topologias sendo processadas sendo utilizadas como uma unidade.</p>
          <li><strong>4.5. Decorator</strong></li>
          <p>Nessa aula nós vamos concluir o estudo sobre os padrões estruturais falando em padrão de crédito na orientação pelo objeto uma vez que Nós criamos uma Instância de uma classe o objeto criado nunca muda a sua forma Seu Crime um objeto aluno ele vai ser aluno durante toda a existência desse objeto no sistema por mais que eu consiga visualizar de forma diferente se essa classe aluno tiver uma interface se ela tiver uma classe abstrata e eu consegui ver esse objeto pelas suas características baseadas dessas Abstrações ele sempre na memória vai ser um aluno e essa característica faz com que não seja possível adicionar ou remover comportamentos de um objeto em tempo de execução mas existem cenários onde essa possibilidade pode se tornar necessária e o padrão Decorator ele vai nos ajudar a criar uma solução que permita incluir substituir ou remover comportamentos de um objeto depois que ele foi criado os comportamentos são construídos que vão encapsular o objeto original então se eu quero incluir o comportamento a mais eu vou criar um objeto com esse comportamento a mais e ele vai envolver objeto original sempre que eu desempenhar algo com isso objeto encapsulado ação vai cair primeiro no envelope para depois ser enviada por objeto original e o meu envelope ele vai ter mesmo contrato mesmo interface que o objeto original Então todo mundo que enxerga que usa a classe conseguiria usar o possível.</p> 
          <p>Tem alguns pontos positivos ele permite estender o comportamento do objeto sem a necessidade de alterar a sua classe ou a sua estrutura ele torna possível combinar diferentes comportamentos de um objeto de acordo com o contexto de execução Em contrapartida ele aumenta consideravelmente a complexidade do código então nós precisamos pontuar se a nossa necessidade realmente demanda o uso do padrão Mas se a nossa resposta for afirmativa faz todo sentido nós adotarmos a proposta em alguma implementações pode ser complexo tratar coordenação e remoção da pilha de execução então ele tem que ser usado não tem mais isso afinal de começar a encadear demais comportamentos adicionados envolvidas substituídos pode se tornar difícil prever o Real comportamento vai ter nós ficamos porque permite adicionar substituir e remover comportamentos de um objeto contornando assim a limitação que existe da orientação por objeto. </p>
        </ul>
      </div>

      <div id="modulo-3-capitulo-5" class="capitulo">
        <p><strong>Capítulo 5 – GoF – Padrões Comportamentais</strong></p>
        <ul>
          <li>5.1. Command</li>
          <p> O padrão Command na teoria da orientação do projeto é definido que as classes representam os conceitos do domínio do problema todas as entidades todos os agentes que estão envolvidos na simulação Viva do problema são candidatos a se tornarem classes dentro do sistema e as ações desempenhadas por esses agentes por essas entidades devem ser encapsuladas e implementadas em métodos dessas classes porém alguns cenários nós precisamos representar ações que vão ser desempenhadas num sistema ou seja os Command que são executados Porém Aqui essas ações elas não são métodos elas são as classes do sistema e o padrão Calma que propõe encapsular as informações necessárias para a execução de um objeto ou seja tratar todas as informações necessárias encapsuladas em um objeto aquelas ações sejam executadas não somente executá-las mas também criar uma interface comum de execução para essas ações na demonstração dessa aula nós vamos ver como nós podemos representar ações nos sistemas encapsulas dentro de uma classe e permitir com que em determinado agente do sistema Execute diferentes ações uma vez que nós vamos ter essa representação padrão para requisições de Command.</p>
          <p> Flexibilizar a execução de ações nos sistemas por diferentes mecanismos ele permite a implementação de mecanismos de fazer e desfazer e agrega muitas funcionalidades interessantes quando nós precisamos criar um consumidor que tem o papel de disparar ações dentro do sistema além de permitir reusar essas ações para serem executadas em diferentes canais. </p>
          <li>5.2. Template Method</li>
          <p> O padrão Template Method algumas vezes nós nos deparamos com situações onde uma funcionalidade precisa ser implementada mas existem variações desse comportamento a classe que implementa essa funcionalidade pode não ser capaz de determinar como implementar todas as etapas desse algoritmo porém algumas das etapas ela consegue definir e implementar e as outras ela sabe apenas que elas existem o padrão não tem método ele vive a criar uma estrutura por um esqueleto dessa funcionalidade Ou seja a classe o pai a classe que concentra o ponto de acesso a essa funcionalidade vai determinar todos os passos daquela funcionalidade as etapas que ele consegue implementar ele já vai implementadas e aquelas que ele não é capaz de implementar ele vai delegar para as classes filhas com isso a diferentes variações que são as classes filhas vão poder definir como aquelas etapas de um pai não foi capaz de implementar devem ser construídas e como o esqueleto da funcionalidade foi definido na classe ai todas as variações automaticamente vão herdar as implementações que já foram definidas na classe esse padrão se assemelha muito a oferta e método mas aqui o foco é o comportamento e para nós vermos a diferença entre um e outro e as particularidades.</p>
          <p> Nós vimos que o padrão permite reduzir a implementação de algoritmos extensos reduz a possibilidade de duplicação de código e simplifica a manutenção e a evolução de Especialidades de variações presentes no algoritmo uma vez que nós conseguimos concentrar as regras comuns nas classes pais e delegar para as filhas as etapas que são de suas responsabilidades </p>
          <li>5.3. State</li>
          <p>Ele atua em cenários onde nós temos uma classe com diferentes comportamentos porém a implementação desses comportamentos depende diretamente do estado dos atributos da classe um grande exemplo de implementação desse padrão é quando nós temos algum jogo eletrônico como por exemplo Mário se nós representarmos o personagem em uma classe ele vai ter um estado que determina Qual a situação do personagem no jogo tem diversas ações podem ser desempenhadas na medida que o usuário interage é um jogo estou com meu personagem sendo a fase inicial do Mário.</p>
          <p>Ele vai pular como intensidade ele pode correr como uma determinada intensidade um botão que é o personagem pode não fazer nada porém se eu pego uma flor de Fogo o meu personagem vai se transformar eu vou mudar o estado do personagem não faz mais por exemplo aqui eu continuo tendo personagem Mário porém dependendo do como eu for implementar esse personagem eu vou ter que fazer dentro do método correr dentro do método saltar ações que correspondem a situação do pai Mário Além disso se eu era o Mário as mesmas ações mudam de acordo com o estado do personagem nesse momento só pega uma pena das ações mudam de novo se todas essas situações por representadas todos os métodos de ações do personagem vão ter uma série de uma série de uma séries quando ele ficar qual é a situação do personagem ele Visa atuar sobre esse tipo de situação ele vai permitir que o objeto Mude o seu comportamento e cada estado vai ter uma classe separada com a implementação das ações que refletem aquele Estado então eu tiro da classe a implementação das ações e gera uma classe com os métodos com as responsabilidades para cada situação do objeto e as transições de estados vão fazer com que vem na classe por exemplo e coloca dentro do estado dele a classe que desempenha essas ações de acordo com a situação do personagem. </p>
          <p>Contribui para reduzir a complexidade de implementação de objeto com múltiplos estados ele permite criar representações que encapsulam a situação atual de um determinado objeto com ele é possível melhorar a responsabilidade única das classes remover estruturas indesejadas de Infiel e substituir isso por exemplo.</p>
          <li>5.4. Strategy</li>
          <p>Sobre um Strategy a manutenção de um software pode se tornar uma grande dor de cabeça quando existem códigos que possuem muitas ramificações os famosos e emaranhados de fiel e suíte Case essas estruturas se tornam suscetíveis à evolução e constantes que acabam gerando novas ramificações problemas indesejados e muitas vezes nós não somos capazes de identificar e entender o que aquela estrutura realmente faz por meio do padrão estratos nós encapsulamos cada uma dessas derivações do algoritmo alvo em classes específicas essa ideia é muito parecida com que nós estudamos o padrão state mas lá nós separamos as ações com base no estado do objeto aqui nós vamos pegar um determinado algoritmo independente deles Independente de um estado ou não mas ele é uma ramificação de um algoritmo maior e encapsular em uma classe A classe principal que antes da implementação de padrão tem todas as ramificações passa armazenar uma referência para a estratégia ou seja por objeto que tem aquela ramificação.</p>
          <p>Tem como ponto positivo o fato de tornar possível alternar a forma de execução de um determinado algorífico em tempo de execução ele permite contornar algumas limitações do uso de herança usando por exemplo composição e contribui para que nós não tenhamos uma quantidade grande de fiel Sweet Case tempo de nosso sistema Em contrapartida aí eficácia de implementação desse padrão depende do índice de ocorrências das variações quanto maior a quantidade de variações mais fácil fundamentar a adoção desse padrão o consumidor principal passa a ser responsável por definir essa estratégia Então quem vai usar o objeto principal que contém a estratégia acaba sendo responsável por materializar a estratégia que ele quer utilizar mudando a ótica de dependências dentro da situação do sistema e em algumas linguagens ele pode Hoje ser substituído por recursos nativos da própria linguagem então é muito importante que vocês conhecerem a ferramenta que você usam porque pode ser que você já tem um recurso nativos, por meio do padrão é possível isolar implementações de algoritmo e alternar o seu uso mantendo a coesão de cada implementação  </p>
        </ul>
      </div>

      <div id="modulo-3-capitulo-6" class="capitulo">
        <p><strong>Atividade de Fixação</strong></p>
      </div>

      <div id="modulo-3-capitulo-7" class="capitulo">
        <p><strong>Primeira Aula Interativa - Capítulo 6 – Princípios SOLID</strong></p>
        <p>Os princípios SOLID são diretrizes fundamentais para o design de software orientado a objetos, promovendo código mais modular, flexível e fácil de manter. Eles foram definidos por Robert C. Martin (Uncle Bob) e são amplamente utilizados no desenvolvimento de sistemas.        </p>
        <ul>
          <li>6.1. Simple Responsibility Principle: Single Responsibility Principle (SRP) – Cada classe ou módulo deve ter uma única responsabilidade, ou seja, deve existir apenas uma razão para modificar a classe. Isso melhora a coesão e facilita a manutenção do código.          </li>
          <li>6.2. Open Closed Principle: O código deve ser aberto para extensão, mas fechado para modificação. Isso significa que novas funcionalidades devem ser adicionadas sem alterar o código existente, geralmente utilizando abstração e herança.</li>
          <li>6.3. Liskov Substitution Principle: Objetos de uma classe derivada devem poder substituir objetos da classe base sem alterar o comportamento do sistema. Esse princípio garante a correta utilização da herança e evita dependências frágeis.</li>
          <li>6.4. Interface Segregation Principle:  Interfaces devem ser específicas para cada contexto, evitando interfaces muito grandes e genéricas. Isso impede que classes sejam forçadas a implementar métodos desnecessários, tornando o sistema mais modular.</li>
          <li>6.5. Dependency Inversion Principle: Módulos de alto nível não devem depender de módulos de baixo nível, ambos devem depender de abstrações. Isso reduz o acoplamento e melhora a flexibilidade do sistema ao utilizar injeção de dependência.</li>
        </ul>
      </div>

      <div id="modulo-3-capitulo-8" class="capitulo">
        <p><strong>Capítulo 7 – Estilos Arquiteturais</strong></p>
        <ul>
          <li>7.1. Estilos Arquiteturais</li>
          <p>A concepção da arquitetura de um software é uma equação complexa que envolve inúmeras variáveis, oriundas, principalmente, dos requisitos esperados para o sistema. Esse processo demanda a análise e ponderação dos trade offs de cada possível abordagem candidata e o arquiteto deve ser capaz de avaliá–las em um alto nível de abstração, uma vez que o sistema ou componente está em fase preliminar de concepção. Se o arquiteto tiver em mãos diretrizes que permitem organizar as abordagens candidatas de forma a reconhecer suas características e permitir determinar se o sistema alvo é semelhante a outros no qual cada abordagem já foi aplicada ele será capaz de avaliar os benefícios e os pontos negativos e, assim, fundamentar suas decisões. Porém, as soluções precisam ser abstratas o suficiente de forma a viabilizar a comparação independente de tecnologias e ramo de atuação de negócio. Tudo isso torna fundamental o conhecimento dos estilos arquiteturais. Estilos arquiteturais descrevem soluções para resolução de problemas na arquitetura de software, porém, atuam em alto nível, permitindo caracterizar uma família de sistemas do ponto de vista da sua organização estrutural. Isso significa que eles produzem uma terminologia que caracteriza componentes de software com base no aspecto identificável da sua organização, sempre a partir de uma visão do nível mais alto de abstração e independente de tecnologia. O estilo arquitetural de um software permite descrever como as camadas, os componentes e os módulos irão se comunicar, identificando e isolando suas responsabilidades. Não existe um estilo arquitetural universal capaz de resolver todos os problemas, uma vez que cada tipo de sistema possui uma característica marcante. Por isso, cada estilo arquitetural é capaz de resolver uma classe de problemas. Existem sistemas que demandam requisitos elevados de segurança, enquanto outros podem ter como característica fundamental o desempenho, a replicação global de dados ou um elevado índice de disponibilidade. Desta forma, os sistemas que seguirem um determinado estilo arquitetural se beneficiarão de determinados atributos em favor de outros. É importante salientar que estilos arquiteturais não são sinônimos de padrões arquiteturais. Um padrão arquitetural apresenta uma solução amplamente testada, documentada e replicável para problemas recorrentes de arquitetura dentro de um estilo arquitetural. Esses termos são frequentemente confundidos, porém, atuam em níveis distintos da solução. Estilos arquiteturais fornecem uma visão periférica em torno do problema enquanto padrões arquiteturais descrevem o processo de como a solução deve ser construída, focado em uma solução concreta. As seções a seguir detalham os principais tipos de estilos arquiteturais.</p>
          <li>7.2. Estilos Arquiteturais – Structure</li>
          <p>Os estilos arquiteturais do tipo Structure têm por objetivo suportar o planejamento da arquitetura do sistema fornecendo diretrizes para a decomposição e organização dos componentes e comportamentos do sistema. Também são conhecidos pelo jargão “From mud to structure”. </p>
          <p><strong> Os principais são:    </strong></p>
          <ul>
            <li>Layered  </li>
            <li>Pipes and filters  </li>
            <li>Component-based  </li>
          </ul>
          <p>Esses estilos têm alta relevância na teoria de arquitetura de software uma vez que as discussões sobre como distribuir as responsabilidades fazem parte de todos sistemas minimamente estruturados. Em contrapartida, nem todos sistemas demandam requisitos de adaptação, por exemplo.</p>
          <p>O estilo arquitetural Layered, também conhecido como arquitetura baseada em camadas, sugere a organização dos sistemas em cada camada, em que cada camada possui uma responsabilidade específica e to dos os artefatos de software residentes em uma deter minada camada devem desempenhar um papel asso ciado a essa responsabilidade. Seu uso contribui para desenvolver aplicações mais fáceis de entender, testar e manter, além de auxiliar o desenvolver paralelo e in dependente de cada camada do sistema. </p>
          <p>O estilo arquitetural por si não define de forma explícita as camadas que devem compor o sistema, ele é frequentemente refinado e transformado em uma solução concreta pelos padrões arquiteturais como MVC, MVP, dentre outros que serão estudados nos capítulos posteriores do curso. Entretanto, é comum encontramos pelo menos qua tro camadas nas principais soluções: </p>
          <ul>
            <li>Presentation Layer </li>
            <li>Business Layer </li>
            <li>Persistence Layer  </li>
            <li>Database Layer.  </li>
          </ul>
          <p>Já o estilo arquitetural Pipe and Filters, ilustrado em Figura 8, visa decompor um processo complexo de forma que cada tarefa é encapsulada em elementos distintos e reutilizados e, a execução do processo como um todo ocorre através do encadeamento de tais componentes. Além de permitir o reuso das atividades, esse modelo arquitetural contribui para a melhoria do desempenho dos processos e simplifica o processo evolutivo, permitindo que novas etapas sejam facilmente inseridas ou removidas do fluxo de processamento.</p>
          <p>Padrão Registry - As premissas do estilo Pipe and Filters são utilizadas na organização de componentes autônomos de sis temas distribuídos, no processamento de requisições HTTP de servidores web e também na organização de camadas em alguns padrões arquiteturais que estuda remos nos capítulos posteriores, como Hexagonal Ar chitecture.</p>
          <li>7.3. Estilos Arquiteturais – Message Styles</li>
          <p>O processamento assíncrono entre sistemas distribuídos pode ser utilizado para garantir a conformidade com diferentes requisitos de qualidade de um sistema que, via integração síncrona, podem não ser tecnicamente viáveis. Os estilos arquiteturais deste tipo classificam as diferentes abordagens frequentemente adotadas no uso de processamento de mensagens, sendo os principais: </p>
          <p><strong>    </strong></p>
          <ul>
            <li>Implicit invocation  </li>
            <li>Asynchronous messaging  </li>
            <li>Publish-subscribe  </li>
          </ul>
          <p>Esses três estilos arquiteturais formam a base das principais arquiteturas modernas, em que a presença de middlewares orientados a mensagens nas integrações entre aplicações e componentes da própria aplicação e o uso de eventos para processamento assíncrono estão cada vez mais presentes.</p>
          <li>7.4. Estilos Arquiteturais – Adaptive Systems</li>
          <p> Existem cenários que imputam aos sistemas a necessidade de serem flexíveis e customizáveis, permitindo que mudanças nos requisitos funcionais e não funcionais sejam aplicadas diretamente pelos consumidores do sistema. Os estilos arquiteturais deste tipo categorizam as principais soluções adotadas para satisfazer essa necessidade. Os principais estilos arquiteturais catalogados nesta categoria são: </p>
          <ul>
            <li> Microkernel </li>
            <li> Reflection </li>
            <li>Domain-specific language </li>
          </ul>
          <li>7.5. Estilos Arquiteturais – Distributed Systems</li>
          <p>Um arquiteto deve dominar as boas práticas de projeto e desenvolvimento de sistemas distribuídos e os estilos arquiteturais desta categoria permitem identificar as características chaves das principais abordagens para composição de sistemas distribuídos e integração entre aplicações. Os principais estilos arquiteturais desta categoria são: </p>
          <ul>
            <li>Service-oriented  </li>
            <li>Peer to peer style  </li>
            <li>Object request broker  </li>
            <li>Cloud native. </li>
          </ul>
          <li>7.6. Estilos Arquiteturais – Deployment</li>
          <p>A arquitetura é uma disciplina holística e envolve as diversas fases do ciclo de vida de um software e suas diferentes necessidades. Saber classificar e analisar o trade offs dos principais modelos de implantação dos sistemas é fundamental para o sucesso de um software, uma vez que a escolha do modelo de implantação incorreto pode anular todos os pontos positivos do projeto de um software. Os estilos arquiteturais mais conhecidos deste tipo são:</p>
          <ul>
            <li>Client-Server  </li>
            <li>N-tier  </li>
          </ul>
          <p>No estilo arquitetural Client-Server visa distribuir o runtime do software é distribuído entre dois tipos de nós e ambos se integram por meio de um canal de comunicação. Os componentes presentes nos clientes podem, ainda, serem estruturados com base em uma separação de camadas lógicas (layers), assim como no servidor. Além disso, um cliente pode se comunicar com um ou vários servi dores diferentes utilizando vários protocolos.</p>
          <p>Um cliente pode requisitar dados e algoritmos para um servidor. Além disso, os clientes podem ser classificados como Thin Clients e Fat Clients. O critério para essa definição se baseia na capacidade de processa mento e quantidade de responsabilidades atribuídas para os componentes de software que rodam no cliente. A arquitetura N-tier se baseia nos princípios do esti lo arquitetural N-tier, porém, tem foco na distribuição física do software (tiers). Seu principal objetivo é distribuir o software em camadas físicas de acordo com a complexidade e os requisitos arquiteturais do software. Embora a implementação mais tradicional seja a separação em três camadas, nas aplicações modernas é comum a utilização de várias camadas como pode ser observado no exemplo ilustrado na Figura 10.</p>
          <p>Um sistema pode demandar diversos estilos arquiteturais para atender às suas necessidades, além disso, eles podem ser combinados, produzindo soluções híbridas. Este capítulo descreve brevemente os estilos arquiteturais e devem ser utilizados como um guia para o aprofundamento dos estudos. </p>
        </ul>
      </div>

      <div id="modulo-3-capitulo-9" class="capitulo">
        <p><strong>Capítulo 8 – Padrões Arquiteturais</strong></p>
        <ul>
          <li>8.1. Padrões Arquiteturais</li>
          <p>Vamos dar início ao estudo dos padrões arquiteturais nós vamos estudar nessa aula os conceitos do padrões arquiteturais com base naquilo que nós vimos nos estilos arquiteturais é a primeira aula do módulo Eu comentei que existem diferentes definições de arquitetura mas todas elas têm um lucro em comum como nós podemos ver a definição do prêmio do gato definir arquitetura como a estrutura dos componentes suas inter-relações e os princípios e diretrizes que regem o seu design e a evolução ao longo do tempo por mais que a estrutura do português dessa definição seja um pouco diferente da outra ela tem a mesma estrutura em comum que é definir as partes o papel dessas partes as regras de relacionamento entre elas e também outros elementos como as regras e evolução ao longo do tempo as características do ambiente ao qual o software se inclui mas a definição de arquitetura ele tem sempre esses três pilares fundamentais e quando nós falamos padrões nós estamos falando de essências de soluções que visam resolver problemas recorrentes que são amplamente testados e podem ser replicados e adaptadas em inúmeros contextos diferentes isso é válido padrões de projeto de análise e também será válido para padrões eleitorais então quando nós falamos de padrões arquiteturais nós estamos falando de essência de soluções que descrevem abordagens para a organização da estrutura de um sistema aqui nós não estamos mais preocupados com a estrutura de um código fonte específico ou como implementar uma solução por um problema de projeto do código fonte nós olhamos para uma ótica maior que é a organização do sistema quer pegar um determinado que define as características de um sistema as características Chaves de um sistema e propor soluções para problemas que acontecem dentro desses universo o foco passa a ser então separação de interesses culturais também são capazes de imprimir características desejadas a um sistema dependendo do padrão adotado no sistema pode ter um comportamento uma capacidade ele não terá por isso é muito importante conhecer as características a proposta de cada padrão para que quando nós Recebemos o que é esperado no sistema nós conseguimos fundamentar todas as decisões que nós vamos tomar e escolher os padrões adequados a escolha do padrão deve levar em consideração Além disso ele simplificam a definição da arquitetura de preferência é aquela que foi Projetada pelo sistema uma vez que eu adoro padrões eu consigo comunicar de uma forma mais simples uma forma padronizada O que é esperado de referência tenha eles também contribui para minimizar o esforço necessário para o desenvolvimento e a manutenção do sistema principalmente testados quando nós paramos tecnologias eles não focam resolver problemas concretos eles focam em caracterizar o sistema melhor dizendo eles focam em caracterizar famílias pegar diversos sistemas que possuem características que distinguem essa família para isso nós precisamos basear nas características que discriminam essas famílias componentes os padrões eles vão se basear e existem padrões para resolver esse problema se o meu problema é a organização estrutural eu posso dar por exemplo se eu estou trabalhando em eventos no meu sistema então Além disso eu posso ainda combinar os padrões porque eles têm propósito diferente existem inúmeros outros tipos naturais o caso do sistema interativos são muito conhecidos como MVC, MVP ou MVVM, desejáveis para um determinados  vimos que os padrões arquiteturais propõem soluções para problemas recorrentes na elaboração de uma arquitetura de um software eles permitem aplicar características desejáveis para um determinado sistema e devem ser utilizados em conjunto com os estilos arquiteturais.</p>
          <li>8.2. Model View Controller (MVC)</li>
          <p>O padrão arquitetural MVC, um dos mais conhecidos na literatura de desenvolvimento de sistemas. Formalizado em 1979 a partir de um estudo sobre a linguagem, o padrão MVC tem sido amplamente utilizado em sistemas orientados a objetos. A proposta desse padrão visa organizar a estrutura de um sistema, separando os interesses do sistema e, principalmente, em sistemas interativos, ou seja, aqueles que envolvem interação Homem-Máquina. </p>
          <p>Como um padrão arquitetural, o MVC possui um problema-alvo, uma proposta de solução e os elementos que fazem parte dessa proposta, como vimos nos padrões de projeto. Ele pode ser de alta complexidade, exigindo um esforço considerável no projeto, manutenção e desenvolvimento dos componentes. No entanto, equipes que buscam uma abordagem para maximizar recursos e a portabilidade dos componentes podem se beneficiar significativamente desse padrão. Sua proposta está diretamente relacionada ao conceito de arquitetura que discutimos anteriormente. </p>
          <p>O primeiro pilar do MVC é a definição das partes e suas responsabilidades, além do relacionamento entre elas. O MVC é composto por três camadas: </p>
          <p><strong> Os Três Pilares do MVC   </strong></p>
          <ul>
            <li><strong>Model: </strong>Responsável por gerenciar os dados e o estado da aplicação. O model processa os dados e os envia para a fonte de persistência. Em algumas variações do MVC, o model pode ser ativo ou passivo. Quando ativo, ele transmite o resultado do processamento; quando passivo, ele recebe as demandas e transmite o resultado para fora da aplicação, sem interagir diretamente com a view. </li>
            <li><strong>View:</strong>: A view apresenta os dados ao usuário e coordena a interação entre o usuário e a aplicação. Ela coleta as informações fornecidas pelo usuário antes de acionar o controller. A view não é responsável pela lógica de negócios, apenas pela interface com o usuário, e envia as ações do usuário ao controller para que a demanda seja executada.            </li>
            <li><strong>Controller: </strong> O controller atua como um intermediário entre a view e o model. Ele coordena as ações do model, decide qual view exibir com base no contexto de execução e escolhe a view apropriada para renderizar o resultado para o usuário. O controller é essencial para rastrear as mudanças no model e determinar qual view deve ser exibida.</li>
          </ul>
          <p><strong> Comunicação entre as Camadas   </strong></p>
          <ul>
            <li>O terceiro pilar do MVC refere-se às regras de comunicação entre as camadas. O processo de comunicação começa com a interação do usuário na view, que envia uma ação ao controller. O controller então atualiza o model, realizando as ações necessárias. Uma vez que a regra de negócio seja executada, o controller examina o modelo atualizado e escolhe qual view será exibida ao usuário. O controller entrega o modelo à view, e esta passa a exibir os dados ao usuário. </li>
            <li>Uma característica importante do MVC é que o controller pode escolher diferentes views, dependendo do contexto da execução. Por exemplo, se o fluxo principal for seguido sem erros, o controller pode escolher uma view específica. Caso contrário, ele pode optar por uma view de erro, dependendo da situação. </li>
          </ul>
          <p><strong>  Vantagens do MVC  </strong></p>
          <p>Entre as principais vantagens do padrão MVC, podemos destacar:</p>
          <ul>
            <li><strong>Isolamento: </strong>O padrão oferece uma estrutura modular, onde alterações em uma camada não afetam as demais. Isso facilita a manutenção e evolução do sistema. </li>
            <li><strong>Estabilidade:  </strong>O MVC facilita o teste de camadas de forma independente, o que contribui para uma maior estabilidade no sistema. </li>
            <li><strong>Reusabilidade: </strong> O padrão permite o reaproveitamento de views, modelos e controllers em diferentes partes do sistema.</li>
            <li><strong>Portabilidade: </strong> Com o MVC, é possível manter um controller e trocar as views sem afetar a lógica do sistema.</li>
          </ul>
          <p><strong>  Variações do MVC  </strong></p>
          <ul>
            <li>Existem várias variações do padrão MVC, como o MVP e o MVVM, que mantêm a essência do MVC, mas com algumas diferenças nas responsabilidades e nos fluxos de comunicação entre as camadas. Essas variações têm alvos diferentes, mas continuam utilizando a estrutura básica do MVC para separar as responsabilidades e facilitar o desenvolvimento. </li>
          </ul>
          <p>Conclusão:O padrão MVC contribui significativamente para a melhoria do desenvolvimento e manutenção de sistemas, oferecendo uma abordagem sistemática para modelagem, separação de interesses, e maximizando o reuso e a portabilidade dos componentes. Ele é uma solução robusta e testada que continua a ser amplamente adotada em diversos tipos de sistemas. </p>
          <li>8.3. Model View Presenter (MVP)</li>
          <p> O MVP é uma variação do padrão MVC (Model-View-Controller) e foi proposto nos anos 90 pela Talent, uma empresa formada por Apple, IBM e HP. Esse padrão introduz algumas diferenças em relação ao MVC, principalmente na separação de responsabilidades entre a interface do usuário e as regras de negócios. </p>
          <p>No MVC, embora exista uma separação de preocupações, as regras de navegação e de apresentação do dado ficam delegadas à view (a interface gráfica). Isso pode ser um problema porque muitas vezes as regras de navegação envolvem validações, transformação de dados para apresentação e controle do fluxo dentro da interface. No MVP, essa responsabilidade é retirada da view e delegada ao presenter.</p>
          <p>Ao separarmos as regras de navegação, o MVP permite que o código relacionado à interface gráfica seja mais testável, já que muitas vezes, em outros padrões, as interfaces gráficas dependem de componentes antigos ou não concebidos com foco em estabilidade. Isso dificulta a realização de testes, especialmente quando se trata de regras de navegação complexas. Com o MVP, conseguimos testar essas regras de forma isolada, já que estão encapsuladas no presenter, e não diretamente na view.</p>
          <p>Outro benefício do MVP é que ele proporciona maior portabilidade. Quando o model ou o presenter são alterados, o impacto nas views é minimizado, pois elas não têm relacionamento direto com os controles de negócios. Isso torna o sistema mais modular e facilita a manutenção. </p>
          <p>Agora, vamos entender melhor os três pilares do MVP:</p>
          <p><strong>  O MVP é composto por três partes:  </strong></p>
          <ul>
            <li> <strong> Model: </strong> Representa os dados e as regras de negócios. Ele é responsável pela persistência e pelo processamento dos dados.     </li>
            <li> <strong> View: </strong> Responsável pela interface com o usuário. A view não possui lógica de negócios, apenas exibe os dados que o presenter fornece.     </li>
            <li> <strong> Presenter:  </strong> É o intermediário entre o model e a view. Ele encapsula as regras de navegação e lógica de apresentação, manipulando os dados do model e formatando-os para exibição na view. Cada presenter está associado a uma view específica.     </li>
          </ul>
          <p><strong> Responsabilidades das Partes   </strong></p>
          <ul>
            <li>Model: Encapsula as regras de negócio e a persistência de dados. Ele notifica o presenter sobre as mudanças no sistema. </li>
            <li>View: A view é passiva, ou seja, ela depende do presenter para fornecer os dados e as interações. Ela não toma decisões sobre como os dados são apresentados. </li>
            <li>Presenter: O presenter é responsável por coordenar a interação entre o model e a view. Ele processa os dados do model e os formata de forma que a view possa exibi-los corretamente. </li>
          </ul>
          <p><strong> Comunicação entre as Partes   </strong></p>
          <ul>
            <li> O fluxo de comunicação no MVP começa quando a view envia para o presenter as ações do usuário (por exemplo, um clique em um botão). O presenter então atualiza o model, que retorna os dados processados e notifica o presenter sobre a nova realidade do sistema. O presenter então processa esses dados e os envia para a view, que apenas os exibe. </li>
          </ul>
          <p><strong>Vantagens do MVP:    </strong></p>
          <ul>
            <li>Isolamento das Regras de Negócio: O MVP permite uma separação clara entre as regras de negócio e a interface gráfica, o que melhora a manutenção e a testabilidade do código. </li>
            <li>Estabilidade: Como a lógica de navegação e de apresentação é isolada no presenter, é mais fácil manter o código estável, evitando problemas típicos de teste e manutenção da interface gráfica. </li>
            <li>Testabilidade: O código de navegação e lógica de apresentação pode ser testado de forma mais eficaz, pois não depende diretamente da interface gráfica, que é mais difícil de testar. </li>
          </ul>
          <p>Conclusão: O MVP promove uma separação clara de responsabilidades, com um foco maior no isolamento das regras de negócio da interface do usuário. O presenter tem um relacionamento de um para um com a view, diferente do que temos no MVC. Isso torna o sistema mais modular, estável e testável, além de facilitar a manutenção e portabilidade. </p>
          <li>8.4. Model View ViewModel (MVVM)</li>
          <p>O padrão MVVM. Criado em 2005 por Jangosman, o MVVM é uma variação do padrão MVP e, por sua vez, do MVC. O foco principal do MVVM é a separação lógica entre a interface do usuário e as regras de negócio, proporcionando uma maior flexibilidade e organização do código.</p>
          <p>Para entendermos melhor o MVVM, é importante relembrar os três pilares que definem a arquitetura de sistemas:</p>
          <p><strong>Definição das Partes (Camadas):     </strong></p>
          <ul>
            <li><strong>View:</strong> Responsável pela apresentação dos dados e coleta das entradas do usuário.</li>
            <li><strong>ViewModel: </strong>Atua como um "orquestrador", sendo o intermediário entre a interface gráfica e a lógica de negócios. </li>
            <li><strong>Model: </strong>Representa a inteligência do negócio, contendo as regras de processamento e manipulação de dados.  </li>
          </ul>
          <p><strong>  Papel de Cada Parte:  </strong></p>
          <ul>
            <li>View: Continua sendo a responsável pela apresentação dos dados e pela coleta dos inputs do usuário, mas com uma maior separação das lógicas de negócio.</li>
            <li>ViewModel: Ao contrário do MVP, onde o apresentador tem um papel mais ativo, no MVVM o ViewModel tem a responsabilidade de orquestrar a interação entre a View e o Model. Ele manipula os dados do modelo e prepara essas informações para serem apresentadas na interface. </li>
            <li>Model: Representa a parte lógica do negócio, realizando o processamento e interagindo com fontes de dados, como bancos de dados ou APIs.</li>
          </ul>
          <p> No MVVM, a comunicação entre as camadas é baseada no conceito de Data Binding (vinculação de dados). O ViewModel interage com o Model para atualizar os dados, e, por meio de Data Binding, a View é automaticamente atualizada quando os dados no ViewModel mudam.</p>
          <p>No MVVM, quando há uma alteração no estado do Model, essas mudanças são refletidas no ViewModel, que, por sua vez, atualiza a View de forma automática, sem a necessidade de chamadas explícitas de atualização.</p>
          <p> Como funciona o Data Binding no MVVM?</p>
          <p>No MVVM, a principal diferença em relação ao MVP está no uso do Data Binding. O ViewModel possui propriedades que estão diretamente vinculadas aos controles da interface (como campos de texto ou grids). Quando um valor no ViewModel é alterado, o Data Binding garante que essas alterações sejam refletidas automaticamente na interface do usuário. Além disso, se o usuário alterar os dados na interface, o ViewModel será atualizado automaticamente.</p>
          <p>Por exemplo, imagine que o nome de usuário está sendo exibido em um campo de texto. Quando o nome do usuário é alterado no Model, o ViewModel captura essa alteração e a reflete na View. O Data Binding pode até permitir que a View envie as alterações diretamente ao ViewModel, sem necessidade de código adicional.</p>
          <p>Diferença do MVVM para o MVC e MVP</p>
          <p>No MVC e MVP, a comunicação entre as camadas é mais explícita. O Controller ou o Presenter assume a responsabilidade de atualizar a View com base nas alterações no Model. Já no MVVM, a maior parte dessa comunicação é automática através do Data Binding, o que facilita a manutenção e a reutilização do código, além de reduzir a quantidade de código de ligação entre as camadas.</p>
          <p>Conclusão: O MVVM permite uma separação clara entre as regras de interface de usuário e as regras de negócio, facilitando a manutenção, reutilização e testes. O uso do Data Binding torna a comunicação entre as camadas mais eficiente e menos propensa a erros, já que as atualizações são feitas automaticamente. Com isso, o MVVM se torna uma excelente escolha para sistemas interativos, especialmente em plataformas como WPF, Xamarin e outras que oferecem suporte nativo ao Data Binding. </p>
        </ul>
      </div>

      <div id="modulo-3-capitulo-10" class="capitulo">
        <p><strong>Capítulo 9 – Arquiteturas de Camadas</strong></p>
        <p>As arquiteturas centradas em domínio focam no isolamento das regras de negócio, garantindo que o núcleo da aplicação fique independente das interações externas e tecnologias específicas.</p>
        <ul>
          <li><strong>9.1. Hexagonal Architecture</strong></li>
          <p>Esse modelo propõe um núcleo isolado (hexágono) onde estão as regras de negócio, enquanto a comunicação com o mundo externo ocorre por portas e adaptadores.</p>
          <ul>
            <li> <strong>Núcleo:  </strong>  Contém a lógica de negócio, independente de tecnologia.    </li>
            <li> <strong>Portas:  </strong>  Abstrações que expõem funcionalidades do núcleo e interagem com tecnologias externas.    </li>
            <ul>
              <li> <strong> Driver Ports (entrada): </strong>  Disparam regras de negócio.    </li>
              <li> <strong> Driven Ports (saída): </strong>  Acessam serviços externos.    </li>
            </ul>
            <li> <strong>Adaptadores:   </strong>  Implementam as portas.    </li>
            <ul>
              <li> <strong> Driver Adapters:  </strong> Chamam o núcleo (APIs, UI). Conectam o núcleo a serviços externos (banco de dados, APIs).    </li>
            </ul>
          </ul>
          <p><strong>Exemplo Prático: Sistema de Corretora de Valores   </strong></p>
          <ul>
            <li> <strong> Domínio: </strong>  Entidades como Ação, Conta, Carteira e Custódia.    </li>
            <li> <strong> Regras de Negócio: </strong>  Exemplo do método ComprarAcao, que executa etapas como validação, criação de ordens e envio à B3.    </li>
            <li> <strong> Isolamento de Tecnologia:  </strong>  O núcleo acessa tecnologias via portas, permitindo troca de implementações sem impacto no código de negócios.    </li>
          </ul>
          <p><strong> Benefícios   </strong></p>
          <ul>
            <li> <strong>  Isolamento do Domínio : </strong> Lógica desacoplada de infraestrutura.      </li>
            <li> <strong>Testabilidade :  </strong>  Possibilidade de testes unitários sem dependências externas.    </li>
            <li> <strong> Flexibilidade e Manutenibilidade:  </strong>  Troca de tecnologias sem afetar o núcleo.     </li>
            <li> <strong>Portabilidade:  </strong> Adaptação a novos cenários com mudanças mínimas.     </li>
          </ul>
          <p>Aplicabilidade: Ideal para sistemas com múltiplos canais de execução, domínios complexos e requisitos elevados de testabilidade e flexibilidade.</p>
          <li><string>9.2. Onion Architecture</string></li>
          <p>A Onion Architecture, um modelo arquitetural interessante e prático.</p>
          <p>Ao estudar arquiteturas baseadas em camadas, frequentemente encontramos estruturas onde o fluxo de dependência é de cima para baixo. Ou seja, uma camada depende diretamente da camada logo abaixo, criando o que chamamos de dependência transitória. Por exemplo:</p>
          <ul>
            <li>A camada de interface do usuário depende da camada de regra de negócio. </li>
            <li>A camada de regra de negócio depende da camada de dados. </li>
            <li>Consequentemente, a camada de interface do usuário também acaba dependendo indiretamente da camada de dados. </li>
            <li>Embora este fluxo seja comum, ele gera problemas quando as camadas dependem diretamente de infraestrutura ou tecnologias específicas. Nesse cenário, a tecnologia se espalha por diferentes camadas do sistema, criando um acoplamento indesejado </li>
          </ul>
          <p>A Onion Architecture resolve esses problemas reorganizando as dependências de maneira concêntrica. As camadas seguem um fluxo de dependência de fora para dentro:</p>
          <ul>
            <li>Camada Externa (Tecnologia): Mais periférica, lida com detalhes de tecnologia, como infraestrutura e frameworks. </li>
            <li>Camada de Aplicação: Contém os serviços e lógica de aplicação que orquestram o sistema. </li>
            <li>Camada de Domínio: Localizada no núcleo, é composta por regras de negócio puras, sem dependências externas. </li>
            <li>Quanto mais próximo do núcleo, mais tratamos do negócio. Quanto mais periférico, mais lidamos com a tecnologia. </li>
          </ul>
          <p><strong>  Principais Diretrizes  </strong></p>
          <ul>
            <li>Isolamento da Tecnologia: As camadas internas (regra de negócio e domínio) não devem depender diretamente da tecnologia. ara isso, utilizam-se abstrações que as camadas externas devem implementar.  </li>
            <li>Modelagem do Domínio: O núcleo contém as regras e modelos do domínio. Ele pode ser extensível e permitir subdivisões conforme a complexidade do negócio. </li>
            <li>Implementação das Abstrações: As camadas externas implementam as abstrações definidas internamente e realizam a composição da aplicação. </li>
          </ul>
          <p> Benefícios </p>
          <ul>
            <li> Maior Manutenibilidade: Separação clara de responsabilidades.</li>
            <li> Estabilidade: Redução do impacto de mudanças tecnológicas no domínio.</li>
            <li> Aceitação de Mudanças: Adaptação mais simples a novos requisitos de negócio.</li>
          </ul>
          <p><strong>  Limitações  </strong></p>
          <ul>
            <li> Complexidade Inicial: Requer maior esforço de implementação e maior curva de aprendizado.</li>
            <li> Não Ideal para Sistemas Simples: É mais adequado para sistemas complexos e de longa duração.</li>
          </ul>
          <p>Considerações Finais: A Onion Architecture organiza camadas de forma concêntrica, colocando o domínio no núcleo. Essa abordagem promove o isolamento da tecnologia e ajuda a manter o foco no negócio. Embora possa exigir maior esforço inicial, o retorno em estabilidade e manutenibilidade justifica sua adoção, especialmente em projetos de grande escala e longo prazo.  </p>
          
          <li>9.3. Clean Architecture</li>
          <p>O Clean Architecture é um modelo arquitetural centrado no domínio, estruturado em camadas concêntricas para separar regras de negócio de detalhes tecnológicos. Diferente de outras abordagens, como a Hexagonal Architecture, ele enfatiza a organização clara das camadas e suas responsabilidades.</p>
          <p><strong> Estrutura   </strong></p>
          <ul>
            <li> <strong> Entidades (Central):  </strong>   Regras de negócio corporativas reutilizáveis em diversos sistemas.    </li>
            <li> <strong> Use Cases: </strong>  Regras de negócio específicas da aplicação, expondo abstrações para dependências externas.            </li>
            <li> <strong> Interface Adapters: </strong>  Adaptadores para APIs, controladores e outros canais de comunicação.    </li>
            <li> <strong> Frameworks and Drivers: </strong>   Integrações externas, como bancos de dados e servidores web, sem lógica de negócio.    </li>
          </ul>
          <p><strong> Fluxo de Informação   </strong></p>
          <ul>
            <li> A interação começa com eventos externos (ex.: chamadas de API). </li>
            <li> A informação flui para dentro, passando pelos Use Cases e sendo processada pelas regras de negócio. </li>
            <li> O resultado é preparado para apresentação ao usuário por meio de portas de saída. </li>
          </ul>
          <p><strong>  Benefícios  </strong></p>
          <ul>
            <li> <strong> Separação de Interesses: </strong>   Isola regras de negócio de infraestrutura.    </li>
            <li> <strong> Flexibilidade: </strong> Facilita a troca de tecnologias sem impactar o domínio.     </li>
            <li> <strong> Escalabilidade: </strong>  Ideal para aplicações modernas e de grande porte.     </li>
            <p>O Clean Architecture permite um fluxo bem definido, onde as dependências sempre apontam para dentro, promovendo manutenibilidade e aderência às melhores práticas de desenvolvimento de software. </p>
          </ul>
        </ul>
      </div>

      <div id="modulo-3-capitulo-11" class="capitulo">
        <p><strong>Capítulo 10 – Padrões para Sistemas Distribuídos</strong></p>
        <p>Bem-vindo ao décimo capítulo do módulo Design Patterns! Hoje, vamos iniciar o estudo dos padrões voltados para sistemas distribuídos, explorando seus desafios, modelos arquiteturais e boas práticas. </p>
        <p><strong> Revisão dos Capítulos Anteriores   </strong></p>
        <ul>
          <li> </li>
          <li> </li>
          <li> </li>
          <li> </li>
          <li> </li>
          <li> <strong> Padrões de projeto: </strong> Conceitos fundamentais para organização do código.     </li>
          <li> <strong> Padrões de sistemas interativos: </strong>  Como MVC e MVP.    </li>
          <li> <strong> Padrões focados em domínio: </strong>  Separação de responsabilidades no software.    </li>
        </ul>
        <p>Agora, nosso foco será a integração entre aplicações, explorando sistemas autônomos que se comunicam por canais de comunicação.</p>
        <ul>
          <li>10.1. Padrões para Sistemas Distribuídos</li>
          <p>A Importância dos Sistemas Distribuídos, atualmente, é raro encontrar aplicações que funcionem isoladamente. A integração com outras aplicações e o reaproveitamento de sistemas legados são tendências cada vez mais comuns. No entanto, essa comunicação introduz desafios que tornam essencial o uso de padrões arquiteturais. </p>
          <p><strong> Principais Desafios   </strong></p>
          <ul>
            <li> </li>
            <li> </li>
            <li> </li>
            <li> </li>
            <li> </li>
            <li> <strong>  Heterogeneidade </strong>      </li>
            <ul>
              <li>Sistemas executando em diferentes plataformas. </li>
              <li>Variações de latência e largura de banda nas conexões. </li>
              <li>Integração entre sistemas operacionais distintos. </li>
            </ul>
            <li> <strong> Escalabilidade </strong>      </li>
            <ul>
              <li>Capacidade de suportar um grande volume de acessos sem perda de desempenho. </li>
            </ul>
            <li> <strong> Segurança </strong>      </li>
            <ul>
              <li>Proteção dos dados não apenas nos servidores, mas também na comunicação entre eles. </li>
            </ul>
            <li> <strong>  Flexibilidade e Tratamento de Falhas </strong>      </li>
            <ul>
              <li>Garantia de confiabilidade, mesmo diante de falhas. </li>
            </ul>
          </ul>
          <p><strong> Modelos Arquiteturais em Sistemas Distribuídos   </strong></p>
          <p>Dentre os principais modelos de arquitetura, destacam-se:</p>
          <p><strong> Modelo Cliente-Servidor   </strong></p>
          <ul>
            <li>O modelo mais comum, onde: Um processo cliente solicita recursos a um processo servidor. </li>
            <li> Dependendo do fluxo, um sistema pode assumir ambos os papéis. </li>
            <li>Variações, uso de clusters para maior disponibilidade.  </li>
            <li>Variações, Sincronização de servidores em bancos de dados críticos (exemplo: transações financeiras). </li>
          </ul>
          <p><strong>Modelo Peer-to-Peer (P2P)    </strong></p>
          <ul>
            <li> Todos os nós podem atuar como cliente e servidor simultaneamente.</li>
            <li> Utilizado em: Compartilhamento de arquivos. Edição colaborativa de documentos. Redes blockchain </li>
            <li> Desafios: Maior complexidade de implementação. Garantia de compatibilidade entre diferentes nós.  Riscos de segurança no compartilhamento direto de informações.  </li>
          </ul>
          <p><strong>  Middleware em Sistemas Distribuídos:  </strong> O middleware atua como um intermediário entre a aplicação e a camada de rede, proporcionando um modelo de programação coeso e homogêneo. Ele facilita a comunicação entre sistemas heterogêneos e abstrai detalhes técnicos da rede.</p>
          <p><strong>Catálogos de Padrões: </strong> Para aprofundar o estudo sobre sistemas distribuídos, recomenda-se referências como: Martin Fowler, Gregory e Bob </p>


          <li>10.2. Enterprise Application Patterns – Point-to-Point Channel</li>
          <p>O padrão Point-to-Point Channel é um modelo de comunicação assíncrona em sistemas distribuídos, garantindo que cada mensagem enviada seja entregue exclusivamente a um único receptor. </p>
          <p><strong>  Middleware Orientado a Mensagens (MOM)  </strong></p>
          <p>O Middleware Orientado a Mensagens (MOM) facilita a comunicação entre aplicações sem exigir conexão direta entre elas. Em vez disso, as mensagens são enviadas para um canal, que:</p>
          <ul>
            <li> Armazena a mensagem.</li>
            <li> Garante sua entrega ao receptor posteriormente.</li>
            <li>Permite comunicação assíncrona, garantindo alta velocidade e confiabilidade. </li>
          </ul>
          <p><strong>  Elementos-chave do MOM:  </strong></p>
          <ul>
            <li> Messenger: Integra aplicações via middleware.</li>
            <li>Message: Dados enviados contendo comandos ou eventos. </li>
            <li>Channel: Meio que conecta emissor e receptor. </li>
          </ul>
          <p><strong> Implementação e funcionamento   </strong></p>
          <p>O MOM geralmente opera por meio de filas:</p>
          <ul>
            <li> O emissor insere mensagens na fila gerenciada pelo middleware.</li>
            <li> O receptor recupera as mensagens quando disponível.</li>
            <li> A comunicação é fracamente acoplada, pois o receptor pode estar indisponível no momento do envio.</li>
          </ul>
          <p><strong> Vantagens do Middleware Orientado a Mensagens   </strong></p>
          <ul>
            <li>Permite comunicação mesmo quando o receptor está offline. </li>
            <li>Garante entrega da mensagem assim que o receptor estiver ativo. </li>
            <li> Suporta envio assíncrono, otimizando a escalabilidade do sistema.</li>
          </ul>
          <p><strong> O Padrão Point-to-Point Channel   </strong></p>
          <p>Esse padrão garante que:</p>
          <ul>
            <li>Cada mensagem seja processada por apenas um receptor, evitando duplicações. </li>
            <li>Mensagens sejam enviadas em ordem e com prioridade, dependendo da configuração do middleware. </li>
            <li> O sistema seja escalável, distribuindo mensagens entre múltiplos receptores sem que uma mesma mensagem seja processada mais de uma vez.</li>
          </ul>
          <p>Conclusão: O Point-to-Point Channel é um padrão essencial para garantir comunicação confiável em sistemas distribuídos. Ele permite processamento exclusivo de mensagens, essencial para cenários onde a duplicação de processamento pode gerar inconsistências ou prejuízos. </p>
          <li>10.3. Enterprise Application Patterns – Publish Subscribe Channel</li>
          <p>O padrão Publish Subscribe Channel é uma abordagem essencial para sistemas distribuídos orientados a eventos, permitindo que múltiplos receptores sejam notificados de um evento de forma assíncrona.</p>
          <p><strong> Funcionamento do Publish Subscribe Channel   </strong></p>
          <ul>
            <li>Publicador (Publisher): O emissor do evento publica mensagens em um canal de comunicação. </li>
            <li>Canal de Mensagens: Armazena notificações e garante a entrega a todos os assinantes. </li>
            <li>Assinantes (Subscribers): Sistemas ou processos interessados no evento são notificados assim que a mensagem estiver disponível. </li>
            <li>Garantia de Entrega: Um evento só é removido do canal após ser entregue a todos os assinantes, evitando perda de mensagens. </li>
          </ul>
          <p><strong>  Diferença entre Fila e Tópico  </strong></p>
          <ul>
            <li> Fila: Utilizada no padrão Point-to-Point Channel, onde cada mensagem é entregue a um único receptor.</li>
            <li> Tópico: Utilizado no Publish Subscribe Channel, permitindo que múltiplos assinantes recebam a mesma mensagem simultaneamente. </li>
          </ul>
          <p><strong> Vantagens do Publish Subscribe Channel   </strong></p>
          <ul>
            <li> Comunicação assíncrona: Publicador e assinantes não precisam estar ativos ao mesmo tempo.</li>
            <li>Garantia de entrega: Todos os interessados recebem a notificação, mesmo que estejam temporariamente offline. </li>
            <li>Escalabilidade: Permite que um evento seja enviado para múltiplos receptores ao mesmo tempo. </li>
          </ul>
          <p>Conclusão:O Publish Subscribe Channel é um padrão eficiente para integração de sistemas distribuídos, garantindo comunicação assíncrona confiável e possibilitando notificações em larga escala. </p>
          <li>10.4. Enterprise Application Patterns – Concurrency</li>
          <p>A concorrência em sistemas distribuídos é um dos desafios mais complexos do desenvolvimento, pois envolve múltiplas transações acessando os mesmos dados simultaneamente, o que pode levar a problemas difíceis de prever e testar. </p>
          <p><strong> Problemas Clássicos de Concorrência   </strong></p>
          <ul>
            <li>Perda de Update: Uma transação sobrescreve a alteração de outra, causando perda de dados. </li>
            <li> Leitura Suja: Uma transação lê um dado não confirmado por outra transação, levando a inconsistências caso haja rollback.</li>
            <li> Leitura Não Repetível: Uma transação lê um dado que é alterado por outra antes de finalizar, gerando valores inconsistentes. </li>
            <li>Leitura Fantasma: Uma consulta inicial retorna um conjunto de dados que muda antes da transação terminar, causando inconsistências. </li>
          </ul>
          <p><strong>  Soluções para Concorrência  </strong></p>
          <ul>
            <li>Imutabilidade: Torna os dados inalteráveis, eliminando conflitos, mas aumentando o uso de armazenamento. </li>
            <li> Isolamento: Garante que apenas uma transação por vez acesse um conjunto de dados, prevenindo inconsistências. </li>
            <li> Controle de Concorrência: </li>
            <ul>
              <li> Otimista: Assume que conflitos são raros e resolve problemas apenas quando ocorrem, ideal para sistemas distribuídos com poucas atualizações simultâneas.</li>
              <li>Pessimista: Bloqueia registros para evitar concorrência, garantindo consistência, mas podendo impactar o desempenho.  </li>
            </ul>
          </ul>
          <p>O controle de concorrência é essencial para sistemas distribuídos e deve ser escolhido com base nos requisitos de escalabilidade, custo de processamento e necessidade de sincronização offline.</p>
        </ul>
      </div>

      <div id="modulo-3-capitulo-12" class="capitulo">
        <p><strong>Capítulo 11 – Arquiteturas de Sistemas Distribuídos</strong></p>
        <ul>
          <li>11.1. Enterprise Application Integration (EAI)</li>
          <p>A Enterprise Application Integration (EAI) é uma abordagem arquitetural que busca integrar aplicações empresariais de forma eficiente e escalável, eliminando a complexidade da comunicação ponto a ponto.</p>
          <p><strong>  Problemas da Integração Direta (Ad Hoc)  </strong></p>
          <ul>
            <li> Dificuldade de gerenciar múltiplas conexões.</li>
            <li>Impacto imprevisível de mudanças em aplicações. </li>
            <li>Diversidade de tecnologias (JSON, XML, bancos de dados distintos).</li>
            <li>Complexidade crescente com sistemas legados e redundantes.</li>
          </ul>
          <p><strong>Solução EAI    </strong></p>
          <p>O EAI centraliza a comunicação entre aplicações por meio de um backbone de integração, facilitando:</p>
          <ul>
            <li> A padronização da troca de informações.</li>
            <li> A comunicação transparente entre sistemas heterogêneos.</li>
            <li>O suporte a múltiplos padrões (arquivos, bancos de dados, RPC, mensagens assíncronas). </li>
          </ul>
          <p><strong> Benefícios do EAI   </strong></p>
          <ul>
            <li>Melhora o relacionamento com clientes e parceiros. </li>
            <li> Prolonga o ciclo de vida de sistemas legados.</li>
            <li>Reduz o time-to-market, acelerando a transformação digital. </li>
            <li> Facilita fusões e aquisições, simplificando a unificação de sistemas.</li>
            <li>Otimiza processos internos, promovendo padronização e eficiência. </li>
          </ul>
          <p>O EAI é uma solução robusta para a integração corporativa, combinando processos, software e hardware com um backbone central para garantir escalabilidade e eficiência.</p>
          
          <li>11.2. Service Oriented Architecture (SOA)</li>
          <p>A Service Oriented Architecture (SOA) é um padrão arquitetural que visa integrar aplicações por meio de serviços reutilizáveis, garantindo flexibilidade, governança e redução de custos.</p>
          <p><strong>  Motivações para Adotar o SOA  </strong></p>
          <ul>
            <li>Reduzir custos de manutenção e desenvolvimento. </li>
            <li>Melhorar a governança e rastreabilidade das integrações. </li>
            <li> Aumentar a flexibilidade e a escalabilidade da TI.</li>
          </ul>
          <p><strong>  Proposta do SOA  </strong></p>
          <ul>
            <li>Encapsular processos comuns de negócio em serviços. </li>
            <li>Expor serviços por meio de interfaces abertas e padronizadas. </li>
            <li>Integrar aplicações sem a necessidade de modificar sistemas existentes. </li>
          </ul>
          <p><strong>Serviços no SOA    </strong></p>
          <ul>
            <li> São tarefas repetitivas do negócio, como consultar cotações ou contratar funcionários.</li>
            <li>Exposição de dados corporativos, tornando informações acessíveis sem alterar aplicações. </li>
            <li>Governança para controlar acessos, reuso e eficiência dos serviços. </li>
          </ul>
          <p><strong> Antes e Depois do SOA   </strong></p>
          <ul>
            <li> Antes: Sistemas isolados, sem reaproveitamento e com múltiplos acessos diretos a bases de dados.</li>
            <li>Depois: Aplicações compostas por serviços reutilizáveis e organizados. </li>
          </ul>
          <p><strong> Benefícios do SOA   </strong></p>
          <ul>
            <li>Maior reutilização de serviços e sistemas legados. </li>
            <li>Padronização e interoperabilidade entre diferentes tecnologias. </li>
            <li>Automação de processos e melhoria na qualidade e segurança. </li>
            <li>Redução do tempo de manutenção e maior eficiência operacional. </li>
          </ul>
          <p><strong>   SOA x Web Services </strong></p>
          <ul>
            <li> Web services são uma tecnologia para integração.</li>
            <li> SOA é um conceito mais amplo, focado em governança, reutilização e abstração.</li>
          </ul>
          <p><strong> Governança no SOA   </strong></p>
          <ul>
            <li>Garante controle e rastreamento do ciclo de vida dos serviços. </li>
            <li> Define políticas e regras para acesso e utilização dos serviços.</li>
          </ul>
          <p><strong> Enterprise Service Bus (ESB)   </strong></p>
          <ul>
            <li>Backbone central que organiza a troca de informações entre serviços. </li>
            <li>Facilita a integração eficiente e estruturada dentro da arquitetura SOA. </li>
          </ul>
          <p><strong>Desafios do SOA    </strong></p>
          <ul>
            <li>Definir quais processos devem ser transformados em serviços. </li>
            <li>Modelar os serviços de forma eficaz e sustentável. </li>
            <li>Implementar uma arquitetura governável e escalável. </li>
          </ul>
          <p>O SOA é uma evolução da integração corporativa, estruturando processos e dados em serviços reutilizáveis e governados, proporcionando maior eficiência e flexibilidade para as empresas.</p>
          <li>11.3. Enterprise Service BUS (ESB)</li>
          <p>O Enterprise Service Bus (ESB) é um componente essencial em arquiteturas SOA (Service-Oriented Architecture), funcionando como um barramento que centraliza a comunicação entre serviços. Ele roteia mensagens, facilita a descoberta de serviços, converte formatos de dados (HTML, XML, JSON, binário) e possibilita a integração de diversas tecnologias.</p>
          <p><strong>Entre suas principais funcionalidades estão:    </strong></p>
          <ul>
            <li>Repositório de Serviços: Elimina integrações ponto a ponto e centraliza a governança. </li>
            <li>Roteamento e Mediação: Direciona solicitações para o serviço correto sem necessidade de localização física. </li>
            <li> Suporte a Múltiplos Formatos e Protocolos: Permite integração entre diferentes sistemas.</li>
            <li> Orquestração e Fachadas de Serviços: Habilita a criação de fluxos de trabalho complexos.</li>
            <li>Medição e Enriquecimento de Mensagens: Garante entrega confiável e enriquece dados sem codificação adicional. </li>
            <li> Transformação de Mensagens: Converte formatos como XML para JSON dinamicamente.</li>
          </ul>
          <p>Além disso, o ESB oferece segurança, auditoria, alta disponibilidade e estabilidade, atuando como um gateway de mensagens.</p>
          <p>Aplicações: É amplamente utilizado na integração de sistemas corporativos, portais, aplicações móveis e workflows automatizados.</p>
          <p>Exemplos de ESB no mercado:Algumas implementações populares incluem IBM WebSphere ESB, Oracle Service Bus e Microsoft BizTalk Server.</p>
          <p>Conclusão:O ESB simplifica a comunicação entre serviços, melhora a governança e garante flexibilidade na arquitetura SOA, tornando a integração de sistemas mais eficiente e escalável. </p>
        </ul>
      </div>

      <div id="modulo-3-capitulo-13" class="capitulo">
        <p><strong>Atividade Modular</strong></p>
      </div>

      <div id="modulo-3-capitulo-14" class="capitulo">
        <p><strong>Segunda aula interativa - Capítulo 12 – Aplicação de Padrões Arquiteturais</strong></p>
        <ul>
          <li>12.1. Aplicação de Padrões Arquiteturais – MVC</li>
          <li>12.2. Aplicação de Padrões Arquiteturais – MVP</li>
        </ul>
      </div>
    </div>

    
    <!-- Conteúdo do módulo 4 -->
    <div id="modulo-4">
      <h2>Módulo 4: Design Patterns, Estilos e Padrões Arquiteturais</h2>

      <p>Iniciando a nossa jornada para aprender um pouco mais sobre os princípios de arquitetura de software da atualidade, ao longo deste conteúdo trabalharemos juntos para explorar tendências relacionadas às arquiteturas modernas. Vamos analisar as atualidades e observar aquilo que tem evoluído.</p>
      <p>Nosso foco será examinar as principais arquiteturas e tecnologias do momento, incluindo frameworks mais proeminentes que merecem maior destaque e atenção. Ao mesmo tempo, discutiremos alguns princípios básicos que devem ser considerados em contextos gerais.</p>
      <p>O objetivo deste módulo é, de forma simples, olhar para o mercado, entender o que é mais importante e relevante e tentar trazer uma visão geral das tendências atuais. Naturalmente, um único conteúdo não é suficiente para cobrir todos os aspectos, mas daremos um panorama geral sobre o que mais se destaca. Em momentos futuros, podemos aprofundar esses conceitos de forma mais detalhada.</p>
      <p>Espero que esta jornada seja produtiva! Ao longo das próximas aulas, abordaremos mais sobre as tendências e os princípios de arquitetura de software da atualidade. Quando falamos em atualidade, é essencial considerar aspectos como interatividade, escalabilidade, disponibilidade e outras características fundamentais, que exploraremos em maior profundidade neste módulo.</p>

      <div id="modulo-4-capitulo-1" class="capitulo">
        <p><strong>Capítulo 1 – Introdução a Arquiteturas de Sistemas Web</strong></p>
        <ul>
          <li><strong>1.1. Evolução da Arquitetura de Sistemas Web</strong></li>
          <p>No início, tudo era mato. Os sites eram estáticos, mas, com o aumento da quantidade de usuários, a necessidade de processamento também cresceu. Foi então que surgiu a necessidade de trabalhar com camadas: de um lado, muitos clientes; do outro, o servidor.</p>
          <p>Conforme o número de usuários continuou aumentando, tornou-se essencial gerenciar essa arquitetura de forma mais eficiente. Assim, as aplicações começaram a ser estruturadas em camadas, como no modelo de três camadas (frontend, backend e banco de dados).</p>
          <p>Mas o crescimento não parou por aí. Com a demanda cada vez maior, surgiu a necessidade de distribuir o processamento. Foi então que o conceito de orientação a serviços ganhou força. Antes, todo o processamento ocorria no servidor; agora, passou a ser distribuído em módulos.</p>
          <p>A evolução continuou e chegamos aos microserviços, um modelo associado ao conceito de computação em nuvem (cloud computing). Nesse modelo, o sistema é composto por vários módulos independentes, podendo ser implantados em diferentes infraestruturas — tanto próprias quanto de terceiros. Isso permite maior escalabilidade e flexibilidade.</p>
          <p>Naturalmente, os módulos ficaram menores, e o próximo passo foi o serverless. Aqui, nem tudo precisa ser desenvolvido internamente. Algumas partes do sistema podem ser consumidas como serviços de terceiros, pagando-se apenas pelo uso.</p>
          <li><strong>1.2. Princípios Arquiteturais</strong></li>
          <p>Os princípios arquiteturais fundamentais que norteiam o desenvolvimento de sistemas modernos. Esses princípios são estratégias amplas que, quando seguidas, promovem a criação de arquiteturas sólidas, flexíveis e fáceis de evoluir. A seguir, apresentamos os principais pontos abordados:</p>
  
          <p><strong>  1.	Definição de Princípios:  </strong></p>
          <ul>
            <li> <strong>	Princípios Arquiteturais: </strong>  Diretrizes amplas que aumentam a probabilidade de sucesso no desenvolvimento de sistemas.    </li>
            <li> <strong>	Design Patterns: </strong> Soluções específicas para problemas recorrentes.     </li>
          </ul>
          <p><strong> 2.	Importância dos Princípios:   </strong></p>
          <ul>
            <li> Promovem elasticidade, escalabilidade e evolução.     </li>
            <li> Facilitam a manutenção e a evolução dos sistemas ao longo do tempo.    </li>
          </ul>
          <p><strong>3.	Princípios Destacados:    </strong></p>
          <ul>
            <li> <strong> Separação de Responsabilidades:  </strong>  Cada módulo deve ter uma responsabilidade clara e específica, reduzindo complexidade e facilitando manutenção.    </li>
            <li> <strong> Evitar Duplicação de Código:  </strong>   Centralizar funcionalidades comuns, como autenticação, para minimizar esforços e erros em mudanças futuras.   </li>
            <li> <strong>	Aberto-Fechado (Open/Closed):  </strong>  Componentes devem ser abertos para extensão, mas fechados para modificação, permitindo adaptações sem comprometer o código existente.    </li>
            <li> <strong>  Programação para Interfaces: </strong> Definir claramente como os módulos se comunicam antes de implementar seus detalhes internos.     </li>
            <li> <strong> Dependências Explícitas:  </strong>  Usar injeção de dependência para deixar claras as relações entre os módulos, facilitando testes e manutenção.    </li>
            <li> <strong> Inversão de Controle:  </strong>  Delegar o gerenciamento de dependências para frameworks especializados, criando sistemas desacoplados e coesos.    </li>
          </ul>
          <p><strong> 4.	Benefícios dos Princípios:   </strong></p>
          <ul>
            <li> Redução de efeitos cascata em alterações.</li>
            <li> Incremento da modularização e clareza do código.</li>
            <li> Flexibilidade para incorporar novos módulos e funcionalidades.</li>
            <li> Maior facilidade em testar, rastrear erros e evoluir sistemas complexos.</li>
          </ul>
          <p><strong>5.	Abordagem Incremental:    </strong></p>
          <ul>
            <li>Entregas básicas e refatoração contínua para ajustar e aprimorar o sistema ao longo do tempo. </li>
          </ul>
          <li>1.3. Principais Arquiteturas</li>
          <p>Arquitetura de software é o esqueleto de um sistema que define como ele será construído para atender aos requisitos funcionais e não funcionais, garantindo características de qualidade. Ela abrange o design, o planejamento e a estruturação das soluções para resolver problemas específicos de um sistema.</p>
          <p>Uma boa arquitetura é essencial para alinhar a solução às necessidades do sistema. Por exemplo, projetar uma arquitetura que dependa de comunicação via web para um sistema em tempo real com alta latência seria uma escolha inadequada. Assim, compreender os requisitos e características do sistema é crucial para prover uma arquitetura eficiente e funcional. </p>
          <p>Cada tipo de arquitetura tem suas vantagens e desvantagens e deve ser escolhido conforme as necessidades específicas do sistema. A arquitetura ideal equilibra escalabilidade, desempenho, manutenção e flexibilidade, garantindo a entrega de uma solução eficiente para o problema identificado. </p>
          <p><strong>  Características Importantes da Arquitetura  </strong></p>
          <ul>
            <li>Escalabilidade: Capacidade do sistema de aumentar sua capacidade de atendimento. </li>
            <li> Manutenibilidade: Facilidade de adaptação ao longo do tempo para adicionar novas funcionalidades.</li>
            <li>Desempenho: Resposta rápida às solicitações dos usuários.</li>
          </ul>
          <p>Principais Tipos de Arquitetura</p>
          <p><strong> Arquitetura Monolítica   </strong></p>
          <ul>
            <li> Então, vamos falar um pouco sobre as características das arquiteturas monolíticas. Como o próprio nome sugere, um sistema monolítico é único e totalmente integrado. A palavra monolítico vem de monólito, ou seja, uma única pedra sólida que não se quebra. Nesse modelo, todas as funcionalidades estão concentradas em um único código centralizado.</li>
            <li> Esse tipo de arquitetura pode até ser modularizado internamente, mas, no fim das contas, tudo está dentro do mesmo código. E quais são as vantagens disso? Durante muitas décadas, essa foi a abordagem mais utilizada porque é mais simples de desenvolver, gerenciar e manter. O controle centralizado facilita a administração do sistema, tornando-o confiável nesse sentido. </li>
            <li> Por outro lado, há desvantagens. À medida que o sistema cresce, sua manutenção se torna mais difícil. Imagine um código com 40 ou 50 mil linhas — isso pode tornar o desenvolvimento mais complexo. Isso não significa que todo sistema legado seja monolítico, mas muitas aplicações antigas seguem esse modelo. </li>
            <li> Ainda assim, a arquitetura monolítica tem seu valor em determinados contextos. Se for necessário que uma aplicação rode localmente, com uma estrutura de controle centralizada, por questões de segurança ou desempenho, um sistema monolítico pode ser a melhor solução. A comunicação interna dentro de um monólito é muito rápida, o que pode trazer ganhos de performance. </li>
            <li>O problema aparece quando é necessário escalar o sistema. Para aumentar a capacidade, normalmente é preciso comprar um servidor mais potente e reinstalar tudo, o que dificulta a escalabilidade. Esse modelo de crescimento é chamado de escalabilidade vertical, pois exige o aumento da capacidade de um único servidor, em vez de distribuir a carga entre vários. </li>
            <li> Esse é um dos principais desafios das arquiteturas monolíticas, especialmente no contexto das aplicações web, onde o modelo cliente-servidor precisa lidar com um grande volume de requisições.</li>
          </ul>
          <p><strong>  Arquitetura Cliente-Servidor  </strong></p>
          <ul>
            <li>Outra característica importante das aplicações web é a arquitetura cliente-servidor. Basicamente, nesse modelo, temos vários clientes no frontend fazendo solicitações a um backend, que possui grande capacidade de processamento para responder a essas requisições. </li>
            <li>A comunicação entre cliente e servidor normalmente ocorre por meio de algum protocolo simples, mas amplamente adotado, como o HTTP. Esse modelo trouxe diversos benefícios, como a possibilidade de separar e otimizar a utilização dos recursos do sistema. Além disso, permite utilizar diferentes tecnologias no frontend e no backend, proporcionando maior modularidade e interoperabilidade. </li>
            <li>No entanto, como vimos ao longo da evolução da web, essa abordagem, embora melhor do que as anteriores, não resolve todos os desafios. À medida que os sistemas se tornaram mais complexos, foi necessário adicionar novas camadas além do cliente e do servidor. </li>
            <li> Um exemplo dessa evolução foi a criação de uma terceira camada, responsável pelo banco de dados, onde ocorre a persistência das informações. Essa mudança trouxe uma separação mais clara entre a lógica de negócios e a gestão de dados, além de ser uma questão essencial para garantir eficiência no uso do hardware e da tecnologia envolvida.</li>
            <li> A evolução da arquitetura cliente-servidor foi muito positiva e continua sendo amplamente utilizada em sistemas empresariais. No entanto, mesmo com essa divisão, o processamento ainda está concentrado em um único local. Foi justamente essa limitação que impulsionou o surgimento de novas arquiteturas, mais escaláveis e distribuídas.</li>
          </ul>
          <p><strong> Arquitetura Orientada a Serviços (SOA)   </strong></p>
          <ul>
            <li> Nesse contexto, surge outro tipo de arquitetura: a orientada a serviços (SOA). Já mencionamos um pouco sobre ela, e, basicamente, sua proposta é dividir o processamento do sistema em vários módulos distribuídos, mantendo um controle gerencial centralizado.</li>
            <li> Com a SOA, o sistema é composto por diversos módulos independentes, que se comunicam entre si, mas há um módulo central responsável pelo gerenciamento e controle dessas interações. Esse modelo proporciona uma padronização na comunicação, tornando-a geralmente mais eficiente e rápida do que a encontrada em arquiteturas cliente-servidor tradicionais.</li>
            <li>Na SOA, a comunicação entre os módulos pode ocorrer por canais dedicados e através de APIs utilizando protocolos como SOAP ou REST. Essas abordagens são mais eficientes e flexíveis, mas ainda assim não atingem um nível de desempenho extremo. </li>
            <li>Vantagens da SOA: Uma das grandes vantagens desse modelo é a reutilização de módulos. Um serviço implementado em um sistema pode ser reaproveitado em outros, permitindo integrações eficientes. Isso possibilita, por exemplo, que um mesmo serviço atenda a diferentes sistemas, promovendo modularização e flexibilidade.  </li>
            <li>Desafios da SOA:Por outro lado, essa arquitetura traz desafios. Além de projetar corretamente os componentes do sistema, é necessário planejar como esses componentes irão se comunicar. Criar essa estrutura e definir padrões de integração não é uma tarefa simples. </li>
            <li>Além disso, a governança dos serviços ao longo do tempo é fundamental. Manter a organização, documentação e versionamento dos serviços exige um esforço contínuo para garantir que a arquitetura se mantenha eficiente e sustentável. </li>
          </ul>
          <p><strong>  Arquitetura de Microserviços </strong></p>
          <ul>
            <li>O surgimento dos microserviços ocorreu como uma evolução natural da arquitetura orientada a serviços (SOA). Embora SOA tenha sido uma grande inovação, ela trouxe desafios, como a complexidade na integração e a governança, tornando o gerenciamento de múltiplos serviços distribuídos algo trabalhoso e difícil. </li>
            <li>Os microserviços surgem para enfrentar esses desafios, permitindo não apenas a distribuição do processamento, mas também dos dados, de forma que o processamento ocorra localmente nos módulos.</li>
            <li>Diferente da SOA, onde um módulo simples pode se comunicar excessivamente com outros (trocando dados entre locais distintos), os microserviços seguem o princípio de autonomia. Cada serviço opera com seus próprios dados próximos a ele, evitando a necessidade de comunicação constante com outros módulos. Assim, um serviço pode realizar transações localmente e só se comunicar com outro quando realmente precisar confirmar um dado externo. </li>
            <li> Além disso, os microserviços podem utilizar provedores de cloud computing, reduzindo a necessidade de gerenciamento manual da infraestrutura. Isso oferece mais flexibilidade e escalabilidade, permitindo que os sistemas cresçam conforme a demanda.</li>
            <li>Desafios da Arquitetura de Microserviços: </li>
            <li> Entretanto, essa abordagem também aumenta a complexidade. Se já existiam desafios na SOA, nos microserviços essa modularização cresce ainda mais. Gerenciar poucos serviços já exige governança, mas administrar dezenas ou centenas de microserviços pode ser um grande desafio.</li>
            <li>Outro ponto importante é a necessidade de balanceamento de carga. Nos microserviços, se um serviço for sobrecarregado, é possível iniciar novas instâncias para atender à demanda. No entanto, para isso funcionar corretamente, é necessário um mecanismo de balanceamento, que direcione as requisições para as instâncias disponíveis de maneira eficiente. Esse controle adiciona uma nova camada de complexidade ao sistema. </li>
          </ul>
          <p><strong> Arquitetura Serverless   </strong></p>
          <ul>
            <li>A arquitetura serverless funciona da seguinte forma: imagine que você precisa desenvolver um serviço específico, mas em vez de implementá-lo do zero, você utiliza uma solução já existente. Por exemplo, se precisar realizar um cálculo específico, em vez de criar essa funcionalidade manualmente, você pode usar um serviço da Amazon (ou de outro provedor) que já tenha essa operação pronta. Assim, você apenas paga pelo uso desse cálculo e recebe o resultado sem precisar gerenciar a infraestrutura. </li>
            <li>Vantagens do Serverless </li>
            <ul>
              <li>Custo baseado no uso: o valor por execução pode ser mais alto, mas como é utilizado de forma pontual, uma boa gestão financeira pode reduzir os custos totais. </li>
              <li>Execução sob demanda: o modelo serverless é baseado na execução de funções em resposta a eventos, sem a necessidade de gerenciar servidores. </li>
              <li> Escalabilidade automática: a infraestrutura ajusta automaticamente a capacidade de processamento conforme a demanda. Se você precisa processar 5 requisições por dia e, de repente, a carga sobe para 10.000 requisições, o provedor (como a Amazon) escalará automaticamente para atender à demanda.</li>
            </ul>
            <li>Complemento aos Microserviços: O serverless não substitui os microserviços, mas pode complementá-los. Ele permite que certas funções sejam executadas sem a necessidade de manter servidores ativos o tempo todo. Além da Amazon, há outros provedores que oferecem esse tipo de serviço, como Azure Functions e Google Cloud Functions. </li>
          </ul>
          <p>Em resumo, em vez de desenvolver e manter uma infraestrutura própria, você paga apenas pelo uso de algo que já foi desenvolvido e está sempre disponível quando precisar.</p>
          <p><strong>   Arquitetura Orientada a Eventos (Event-Driven) </strong></p>
          <ul>
            <li>Podemos pensar a arquitetura dirigida a eventos (Event-Driven Architecture - EDA) como uma evolução natural das arquiteturas anteriores. Cada nova abordagem surge para resolver problemas específicos, mas isso não significa que uma arquitetura seja universalmente melhor. Ela será mais adequada para determinadas necessidades e desafios. </li>
            <li> Antes de aprofundarmos nesse modelo, é importante compreender que, nos últimos anos, algumas arquiteturas se tornaram amplamente utilizadas no mercado. Elas compartilham princípios semelhantes, e entre elas, podemos destacar três principais abordagens.</li>
          </ul>

          <p><strong> Arquiteturas Modernas   </strong></p>
          <p><strong>  Onion Architecture  </strong></p>
          <ul>
            <li>Qual é o conceito por trás da arquitetura Onion? A figura representativa dessa abordagem ilustra bem a ideia: no núcleo da aplicação, ficam as regras de domínio, ou seja, os serviços e modelos que definem o coração do sistema. Esse núcleo representa as regras de negócio, que devem ser priorizadas e desenvolvidas primeiro. A partir dele, o sistema se expande para fora, adicionando camadas externas conforme necessário. </li>
            <li>Por exemplo, a camada de infraestrutura, como o banco de dados, não deve influenciar o núcleo. Pelo contrário, o banco de dados deve ser tratado como um detalhe externo, que interage com a regra de negócio, mas sem afetar diretamente sua estrutura. </li>
          </ul>
          <p><strong>Vantagens dessa abordagem    </strong></p>
          <p>A principal vantagem dessa arquitetura é a inversão de dependências: as camadas externas dependem do núcleo, e não o contrário. Isso traz diversos benefícios, como:</p>
          <ul>
            <li> Maior flexibilidade tecnológica – Se for necessário trocar o banco de dados por uma solução mais eficiente e barata, essa mudança não impacta o núcleo da aplicação.</li>
            <li>Código mais sustentável – Como as regras de negócio estão isoladas no núcleo, qualquer alteração tecnológica externa pode ser feita sem necessidade de mudanças internas. </li>
            <li> Manutenção facilitada – Atualizações e evoluções geralmente ocorrem mais nas bordas do sistema do que no núcleo. Com essa arquitetura, as modificações externas não exigem replicação de mudanças para dentro.</li>
          </ul>
          <p>Em resumo, a Onion Architecture trabalha com uma estrutura de camadas organizadas de dentro para fora, garantindo que o sistema tenha baixo acoplamento, seja mais modular, sustentável e preparado para evoluções futuras.</p>
          <p><strong>  Clean Architecture  </strong></p>
          <ul>
            <li>A Clean Architecture é bastante similar à Onion Architecture, mas enfatiza ainda mais a modularização do sistema. Na Onion Architecture, o modelo de domínio está no núcleo da aplicação. Já na Clean Architecture, essa estrutura é organizada de forma mais explícita, seguindo uma divisão bem definida: </li>
            <li>Entidades – Representam os conceitos fundamentais do domínio. </li>
            <li>Casos de Uso – Definem as regras de negócio e as interações principais do sistema. </li>
            <li>Serviços de Aplicação – Responsáveis por coordenar a comunicação entre as camadas. </li>
            <li>A estrutura segue o mesmo princípio da inversão de dependências: as camadas externas dependem das internas, e não o contrário. </li>
          </ul>
          <p><strong>  Vantagens da abordagem  </strong></p>
          <ul>
            <li>A Clean Architecture parte da seguinte premissa: as regras de negócio são muito amplas, então precisamos identificar o que realmente não muda ao longo do tempo. </li>
            <li>Por exemplo, se você está desenvolvendo um sistema de vendas, um item de venda dificilmente terá mudanças frequentes, pois faz parte do conceito central do domínio. Sendo assim, o sistema deve ser construído a partir dessas entidades estáveis, garantindo maior robustez e flexibilidade para mudanças futuras. </li>
            <li> Além disso, essa arquitetura reforça que a maior parte das mudanças ocorrerá nas camadas externas. Por isso, a dependência deve fluir de dentro para fora. Isso evita que qualquer alteração em tecnologias externas, como um banco de dados ou um serviço de terceiros, cause mudanças em cascata dentro do núcleo da aplicação. Dessa forma, a manutenção se torna mais simples, e a evolução do sistema ocorre de maneira mais organizada e sustentável.</li>
          </ul>
          <p><strong> Hexagonal Architecture (Arquitetura Hexagonal)   </strong></p>
          <ul>
            <li>A arquitetura hexagonal segue um conceito semelhante às arquiteturas anteriores, estruturando a aplicação no centro, com entidades externas se comunicando por meio do conceito de portas e adaptadores. </li>
            <li> Portas: São os pontos de entrada e saída para troca de dados e serviços.</li>
            <li> Adaptadores: São responsáveis por permitir que diferentes tecnologias consigam se comunicar.</li>
          </ul>
          <p><strong>  Principais conceitos  </strong></p>
          <ul>
            <li>Ao compararmos com a Onion Architecture, percebemos que a Hexagonal Architecture é uma evolução, mas com uma especificação menos rígida sobre a estrutura interna. O foco aqui é garantir que o sistema seja interoperável. </li>
            <li>A ideia principal é programar para interfaces, mas expandindo esse conceito para toda a arquitetura. Isso significa que, ao desenvolver o sistema, você trabalha com portas e adaptadores, permitindo que as partes internas e externas se comuniquem sem dependências diretas. </li>
          </ul>
          <p><strong> Vantagens da abordagem   </strong></p>
          <p>Se houver uma mudança tecnológica, como a necessidade de alterar a forma como o sistema se conecta a um desktop, basta ajustar o adaptador correspondente, sem impactar a lógica interna da aplicação. Esse modelo permite ignorar não apenas a persistência de dados, mas também outros atributos secundários, tornando a aplicação mais flexível e adaptável a diferentes cenários.</p>
          <p>O grande objetivo das arquiteturas modernas, incluindo a Hexagonal Architecture, é oferecer:</p>
          <ul>
            <li> Facilidade de evolução</li>
            <li> Alta capacidade de manutenção</li>
            <li>Flexibilidade para diferentes contextos ao longo do tempo </li>
          </ul>
        </ul>
      </div>
      
      <div id="modulo-4-capitulo-2" class="capitulo">
        <p><strong>Capítulo 2 – Frameworks SPA para desenvolvimento WEB</strong></p>
        <ul>
          <li>2.1. SPA – Single Page Application</li>
          <li>2.2. Principais frameworks da atualidade: Angular, Vue.js e React.</li>
        </ul>
      </div>
      
      <div id="modulo-4-capitulo-3" class="capitulo">
        <p><strong>Capítulo 3 – Introdução às APIs e Arquiteturas REST e GraphQL</strong></p>
        <ul>
          <li>3.1. Introdução às APIs REST</li>
          <p>Uma API (Interface de Programação de Aplicações) é uma ponte que permite a comunicação entre sistemas distintos. Em outras palavras, se um programa utiliza a tecnologia "X" e outro a tecnologia "Y", a API define um padrão de comunicação que possibilita a troca de informações entre esses dois programas, mesmo que estejam em locais diferentes.</p>
          <p>Além de definir o protocolo de comunicação, uma API também implementa toda a infraestrutura necessária para essa interação. Ela estabelece regras sobre como mensagens devem ser enviadas e recebidas, incluindo detalhes como formato e conteúdo das solicitações e respostas.</p>
          <p>REST e o Conceito de Comunicação Web:Uma das formas mais conhecidas de construir APIs é o REST (Representational State Transfer), que surgiu nos anos 2000 para resolver problemas relacionados à comunicação no contexto web. O REST é baseado no protocolo HTTP, amplamente utilizado na internet. Sua principal característica é ser stateless, ou seja, não mantém informações do estado do cliente entre requisições.  </p>
          <p><strong>  Principais Métodos HTTP no REST:  </strong></p>
          <ul>
            <li> GET: Usado para obter dados.</li>
            <li> POST: Inserir novos dados.</li>
            <li> PUT/PATCH: Atualizar dados existentes.</li>
            <li> DELETE: Remover dados.</li>
          </ul>
          <p>Cada método trabalha com identificadores únicos de recursos, conhecidos como URIs (Uniform Resource Identifiers), que indicam os endereços dos recursos na rede.</p>
          <p>Vantagens e Desafios do REST</p>
          <p><strong>  Vantagens:  </strong></p>
          <ul>
            <li>Simplicidade: Utiliza padrões conhecidos (HTTP). </li>
            <li> 	Escalabilidade: Fácil de expandir com novos serviços.</li>
            <li>	Integração: Compatível com diversas plataformas. </li>
            <li>Adotado Mundialmente: É amplamente conhecido e utilizado. </li>
          </ul>
          <p><strong>  Desafios:  </strong></p>
          <ul>
            <li>	Insegurança: Informações transmitidas no formato JSON são facilmente legíveis. </li>
            <li>	Limitações de Cache: Necessidade de controles secundários para otimizar desempenho.</li>
            <li>Manutenção de Versões: Gerenciar múltiplas versões pode se tornar complexo ao longo do tempo. </li>
          </ul>
          <p><strong>  Autenticação em APIs REST  </strong></p>
          <p>Para garantir que apenas clientes autorizados acessem os recursos, é necessário implementar mecanismos de autenticação. Alguns exemplos incluem: </p>
          <ul>
            <li> Token JWT (JSON Web Token): o	Gera um token exclusivo para o cliente, que deve ser enviado em cada requisição. </li>
            <li> 	OAuth:	Um protocolo de autorização amplamente utilizado, como o Google OAuth, para validar clientes. </li>
            <li> API Keys:	Chaves exclusivas associadas a cada cliente, utilizadas para autenticação e controle de acesso. </li>
          </ul>
          <p><strong> Respostas e Erros Padrão em APIs REST   </strong></p>
          <p>O REST adota códigos de status HTTP para indicar o resultado de uma solicitação, como:</p>
          <ul>
            <li> 200 (OK): Solicitação bem-sucedida. </li>
            <li> 404 (Not Found): Recurso não encontrado. </li>
            <li> 500 (Internal Server Error): Erro no servidor. </li>
          </ul>
          <p>A utilização de APIs REST apresenta uma solução eficiente para a comunicação entre sistemas distintos, especialmente em contextos web. Sua simplicidade e flexibilidade o tornaram amplamente adotado. No entanto, é fundamental estar atento às suas limitações, como questões de segurança e gerenciamento de versões, para garantir que as APIs atendam aos requisitos de sistemas modernos e escaláveis.</p>
          <li>3.2. Introdução ao GraphQL</li>
          <p>A solução que vamos apresentar é robusta, ideal para cenários complexos, mas com um custo mais elevado. Para problemas simples, ela pode não ser a melhor escolha, pois não substitui totalmente o REST, mas sim complementa, dependendo do caso de uso.</p>
          <p>Essa tecnologia foi desenvolvida pelo Facebook em 2012 para atender às suas necessidades específicas. Na rede social, o tipo de consulta dos usuários não era simples como buscar apenas uma linha em um banco de dados. Um perfil de usuário, por exemplo, inclui foto, vídeos, postagens, curtidas e outros dados armazenados em diferentes locais. O REST tradicional, nesse cenário, muitas vezes retornava dados desnecessários, resultando em ineficiência. Para resolver isso, o Facebook desenvolveu essa nova abordagem e, em 2015, disponibilizou-a para a comunidade.</p>
          <p>A grande vantagem dessa solução é a possibilidade de delimitar exatamente quais dados serão retornados ou manipulados em cada requisição. Por exemplo, se há 50 informações disponíveis, você pode solicitar apenas as 4 ou 5 necessárias, evitando sobrecarga de dados. Além disso, ela permite integrar dados de múltiplas fontes em uma única solicitação, otimizando a comunicação entre cliente e servidor.</p>
          <p>No REST, o servidor costuma retornar um conjunto fixo de dados para cada consulta. Já na abordagem apresentada, a consulta é flexível e ajustada às necessidades específicas do cliente. Isso elimina problemas como "overfetching" (trazer mais dados do que o necessário) e "underfetching" (trazer menos dados do que o necessário).</p>
          <p>A solução utiliza um esquema fortemente tipado. Antes de iniciar, você define quais informações estarão disponíveis para consulta ou alteração. Essa abordagem melhora a gestão de memória e garante mais segurança ao sistema. Por exemplo: </p>
          <ul>
            <li>Query: Utilizada para obter dados. </li>
            <li>	Mutation: Utilizada para alterar dados.</li>
            <li>	Subscription: Permite obter informações em tempo real.</li>
          </ul>
          <p>Esses conceitos tornam a solução ideal para sistemas que precisam lidar com grande volume de dados e interações complexas.</p>
          <p><strong>  Ferramentas de apoio  </strong></p>
          <p> Existem várias ferramentas que facilitam o uso dessa abordagem:</p>
          <ul>
            <li>Apollo: Ajuda no gerenciamento de consultas do lado do cliente. </li>
            <li>	Playground: Permite testar as consultas de forma interativa antes de implementá-las. </li>
            <li>Relay: Facilita a integração com outras tecnologias. </li>
            <li>  Embora o número de ferramentas ainda seja menor comparado ao REST, elas são robustas e atendem bem às necessidades do mercado. </li>
          </ul>
          <p><strong>  Vantagens:  </strong></p>
          <ul>
            <li> Redução do fluxo de dados entre cliente e servidor.</li>
            <li>Flexibilidade nas consultas, trazendo apenas os dados necessários. </li>
            <li> 	Integração simplificada de múltiplas fontes de dados.</li>
          </ul>
          <p><strong>   Desafios: </strong></p>
          <ul>
            <li> Esquema fortemente tipado, exigindo planejamento detalhado no início. </li>
            <li> 	Curva de aprendizado maior do que o REST tradicional.</li>
            <li> 	Controle de cache diferenciado, com uma abordagem distinta do REST.            </li>
          </ul>
          <li>3.3. Demonstração do desenvolvimento de API</li>
        </ul>
      </div>
      
      <div id="modulo-4-capitulo-4" class="capitulo">
        <p><strong>Capítulo 4 – Documentação de APIs com SWAGGER</strong></p>
        <ul>
          <li>4.1. Documentação de APIs com SWAGGER</li>
          <p> O Swagger é uma ferramenta que permite documentar APIs REST de forma prática e visual. Antes de entender como ele funciona, é importante compreender o conceito de APIs REST. </p>
          <p><strong> Conceito de REST   </strong></p>
          <ul>
            <li>REST (Representational State Transfer) é um estilo arquitetural para construção de APIs. Nem toda API desenvolvida utilizando o protocolo HTTP é RESTful, pois, para ser considerada assim, precisa aderir aos princípios desse modelo arquitetural. </li>
            <li>O Swagger auxilia na construção de APIs bem estruturadas, RESTful e, principalmente, bem documentadas. </li>
          </ul>
          <p><strong>  Benefícios do Swagger  </strong></p>
          <ul>
            <li> Ferramentas gráficas: Proporcionam uma abordagem visual e intuitiva para construção de APIs. </li>
            <li> Conformidade com a especificação OpenAPI: Assegura uma interface padronizada e consistente. </li>
            <li> Facilidade de documentação: Garante clareza e concisão na documentação da API. </li>
            <li>Automação: Permite a geração automática de documentação e até de código para requisições. </li>
          </ul>
          <p><strong>  Por que é importante documentar APIs?  </strong></p>
          <ul>
            <li> Clareza e entendimento: Todos os envolvidos (desenvolvedores, testadores e clientes) compreendem o propósito da API. </li>
            <li> Facilidade de integração: Terceiros conseguem integrar suas aplicações rapidamente. </li>
            <li> Manutenção e evolução: O sistema pode ser atualizado de forma mais ágil e organizada. </li>
          </ul>
          <p><strong> Componentes Básicos de uma Documentação com Swagger   </strong></p>
          <ul>
            <li> Pontos de acesso (Paths): Especificação dos endpoints disponíveis na API.</li>
            <li>Métodos HTTP: Definição dos métodos suportados por cada endpoint (GET, POST, PUT, DELETE, etc.). </li>
            <li> Parâmetros: Descrição dos parâmetros aceitos pela API (query parameters, headers, body, etc.). </li>
            <li> Respostas: Documentação das respostas padrão, indicando o que a API retorna em caso de sucesso ou erro. </li>
            <li> Segurança: Informações sobre autenticação e autorização, como o uso de tokens ou chaves de acesso.</li>
          </ul>
          <p><strong>  Arquivo de Configuração  </strong></p>
          <p>A configuração do Swagger exige um arquivo no formato JSON ou YAML, que define: </p>
          <ul>
            <li> Estrutura e endpoints da API.</li>
            <li> Regras de validação.</li>
            <li> Detalhes das respostas e erros.</li>
          </ul>
          <p><strong> Testes com Swagger   </strong></p>
          <p> Uma das principais vantagens do Swagger é sua interface gráfica interativa, que permite: </p>
          <ul>
            <li> Testes dinâmicos: Realizar requisições e validar respostas sem a necessidade de executar a API em produção. </li>
            <li> Facilidade de uso: Equipes conseguem verificar a documentação e realizar testes de integração de maneira intuitiva. </li>
          </ul>
          <p><strong>Vantagens e Desafios do Swagger    </strong></p>
          <ul>
            <li>Facilidade de uso: Interface visual clara e amigável. </li>
            <li>Agilidade no desenvolvimento: Geração automática de código e documentação. </li>
            <li>Integração entre equipes: Permite que times multidisciplinares trabalhem de forma eficiente. </li>
          </ul>
          <p><strong>  Desafios  </strong></p>
          <ul>
            <li> Configuração inicial: Exige a criação de um arquivo de configuração correto (JSON ou YAML).</li>
            <li>Curva de aprendizado: Requer um bom entendimento sobre REST e a especificação OpenAPI. </li>
          </ul>
          <p>O Swagger é amplamente utilizado devido à sua capacidade de simplificar o processo de documentação e integração de APIs. Embora REST nem sempre seja o método mais rápido ou eficiente, a necessidade crescente de comunicação entre serviços distribuídos torna ferramentas como o Swagger cada vez mais relevantes.</p>

          <li>4.2. Demonstração do uso do SWAGGER em aplicação real</li>
        </ul>
      </div>
      
      <div id="modulo-4-capitulo-5" class="capitulo">
        <p><strong>Capítulo 5 – Demonstração de Arquiteturas de Microsserviços</strong></p>
      </div>
      
      <div id="modulo-4-capitulo-6" class="capitulo">
        <p><strong>Capítulo 6 – Arquiteturas Orientadas a Eventos</strong></p>
        <ul>
          <li>6.1. Introdução às Arquiteturas Orientadas a Eventos</li>
          <p>A arquitetura orientada a eventos baseia-se na comunicação de eventos, ou seja, mudanças significativas de estado, como "pedido solicitado", "pedido processado", etc. Essa abordagem otimiza a troca de informações entre sistemas, tornando a comunicação mais eficiente, leve e rápida, ideal para contextos de alto desempenho e sistemas distribuídos.</p>
          <p>Por exemplo, em vez de uma loja notificar individualmente cada cliente sobre mudanças de preços, ela atualiza um painel central (repositório) acessado pelos clientes interessados. Assim, reduz-se o volume de transações e a troca de dados, tornando o sistema mais ágil e menos dependente de interações constantes.</p>
          <p><strong>  Os principais componentes dessa arquitetura incluem:  </strong></p>
          <ul>
            <li> Produtores de eventos: Geram e disparam eventos (ex.: loja alterando preços). </li>
            <li> Consumidores de eventos: Recebem e processam eventos relevantes (ex.: clientes verificando preços). </li>
            <li> Event Bus: Canal central de comunicação que transporta os eventos entre produtores e consumidores. </li>
          </ul>
          <p>Modelos de comunicação como "publish-subscribe" e "event streaming" são usados para atender às diferentes necessidades de sistemas e consumidores. A arquitetura orientada a eventos permite sistemas mais desacoplados, modulares e escaláveis, sendo comum em serviços distribuídos. Ela também melhora a resiliência a falhas, já que problemas em consumidores não afetam produtores ou outros consumidores. </p>
          <p>Por fim, é crucial garantir rastreamento e consistência na comunicação, especialmente em sistemas críticos, como bancos, onde histórico e verificações são essenciais.</p>
          <p>Resumo: A aula aborda arquiteturas orientadas a eventos, que otimizam a comunicação em sistemas distribuídos, baseando-se na troca de eventos significativos (mudanças de estado). Os principais componentes incluem produtores, consumidores e um Event Bus para transporte. Essa abordagem reduz a troca de dados, facilita a escalabilidade e melhora a resiliência do sistema. Exemplos práticos incluem sistemas de notificações centralizadas, como atualizações de preços em lojas. Modelos como "publish-subscribe" e "event streaming" são usados conforme a necessidade dos consumidores. A arquitetura promove flexibilidade, modularidade e eficiência, sendo especialmente útil em contextos de serviços distribuídos e alta demanda.</p>

          <li>6.2. Demonstração de uma Aplicação Orientada a Eventos</li>
          <p> A arquitetura orientada a eventos tem como base o conceito de evento, que é uma mudança de estado que pode representar uma atualização ou algo significativo que precisa ser comunicado. Por exemplo, a criação de um novo pedido ou o registro de um novo usuário. Esses eventos indicam alterações relevantes no sistema.          </p>
          <p> Vimos que, nessa arquitetura, existem alguns elementos principais. Um deles é o conceito de publicação e assinatura (Pub/Sub), onde temos um elemento responsável por publicar eventos e outros que consomem ou "assinam" esse conteúdo. Além disso, existem diferentes formas de implementação, como o fluxo contínuo de eventos, que podem ser gerados de maneira esporádica, com base em mudanças de estado, ou de forma contínua.          </p>
          <p> Na aula 6.2, vamos explorar mais profundamente a aplicação prática da arquitetura orientada a eventos, com foco no conceito de publisher (publicador). Implementaremos, de forma prática, um publicador e alguns elementos consumidores para demonstrar o funcionamento desse modelo. Esse tipo de arquitetura nos permite criar sistemas desacoplados, facilmente escaláveis, resilientes e com grande flexibilidade para incorporar novos elementos.          </p>
        </ul>
      </div>
      
      <div id="modulo-4-capitulo-7" class="capitulo">
        <p><strong>Capítulo 7 – Introdução às Arquiteturas de Sistemas Mobile</strong></p>
        <ul>
          <li>7.1. Desenvolvimento Móvel Nativo</li>
          <p> Vamos dar sequência à nossa disciplina Princípios de Arquiteturas de Software da Atualidade. Neste capítulo, abordaremos o desenvolvimento mobile e a arquitetura desses sistemas.</p>
          <p> Esse capítulo está estruturado em três formas principais de desenvolvimento: nativo, cross-platform e híbrido. Na aula de hoje, focaremos no desenvolvimento nativo, explorando seus conceitos e características. Vamos falar sobre o que é o desenvolvimento nativo no contexto mobile, com exemplos específicos de Android e iOS, além de discutir as tendências e vantagens desse modelo. </p>
          <p> O que é o desenvolvimento nativo? Imagine que você tem dois sistemas operacionais principais no mercado: Android e iOS. Desenvolver algo de forma nativa significa criar um software especificamente para cada um desses sistemas operacionais, utilizando suas linguagens e ferramentas dedicadas.         </p>
          <p><strong>Por exemplo:    </strong></p>
          <ul>
            <li> Para Android, você utiliza Java ou Kotlin.</li>
            <li> Para iOS, você utiliza Swift ou Objective-C. </li>
          </ul>
          <p>Essas aplicações são desenvolvidas exclusivamente para uma plataforma, aproveitando ao máximo os recursos oferecidos por ela.</p>
          <p>Vantagens do desenvolvimento nativo:  Acesso total aos recursos do sistema operacional Com o desenvolvimento nativo, você consegue utilizar todos os recursos e APIs específicas de cada plataforma, como gráficos avançados, bibliotecas dedicadas e interações com hardware. </p>
          <p>Melhor desempenho:  Aplicativos nativos são mais rápidos e eficientes, pois são otimizados para o sistema operacional em que rodam.</p>
          <p>Experiência de usuário aprimorada: Por serem desenvolvidos para um sistema específico, os aplicativos nativos oferecem interfaces mais fluídas e melhor integração com o sistema operacional. </p>
          <p>Adequação para casos específicos: Para aplicações como jogos, que exigem gráficos avançados, ou sistemas com altas demandas de segurança, como software militar, o desenvolvimento nativo é a melhor escolha.</p>
          <p>Desafios do desenvolvimento nativo Custo elevado:  Como você precisa desenvolver dois códigos distintos (um para Android e outro para iOS), o custo de desenvolvimento e manutenção é maior.</p>
          <p>Duplicação de esforço: Cada sistema operacional exige sua própria base de código, o que aumenta a complexidade de gerenciamento e manutenção. </p>
          <p>Ferramentas e linguagens principais</p>
          <p><strong>   Para Android: </strong></p>
          <ul>
            <li>Java: Uma linguagem versátil, mas considerada verbosa. Ideal para equipes já familiarizadas com a linguagem.            </li>
            <li>Kotlin: Mais moderna e concisa que Java, é atualmente a linguagem preferida para desenvolvimento Android.            </li>
          </ul>
          <p><strong> Para iOS:   </strong></p>
          <ul>
            <li> Swift: Uma linguagem poderosa, projetada pela Apple, que tem se tornado a principal escolha para desenvolvimento iOS.  </li>
            <li> Objective-C: Embora ainda usada, está em desuso em favor do Swift.   </li>
          </ul>
          <p>Tendências no desenvolvimento nativo, Facilitação do desenvolvimento, Ferramentas como Android Studio e Xcode oferecem ambientes integrados (IDEs) que aceleram o processo de criação de aplicativos, com bibliotecas e componentes nativos prontos.          </p>
          <p>Realidade aumentada e virtual: Linguagens e plataformas estão cada vez mais equipadas para suportar aplicações inovadoras, como realidade aumentada e computação de borda.   </p>
          <p><strong>  Evolução das linguagens  </strong></p>
          <ul>
            <li> Kotlin está ganhando protagonismo no desenvolvimento Android. </li>
            <li>Swift continua como a principal escolha para iOS, com ferramentas como SwiftUI, que facilitam a criação de interfaces gráficas.  </li>
          </ul>
          <P> Conclusão: O desenvolvimento nativo é uma excelente escolha quando se deseja criar aplicativos otimizados e robustos, aproveitando ao máximo os recursos do sistema operacional. Contudo, deve ser utilizado com cuidado, considerando seu custo elevado e a necessidade de gerenciamento de múltiplas bases de código. Na próxima aula, vamos explorar o desenvolvimento mobile híbrido, comparando suas vantagens e desvantagens com o desenvolvimento nativo.          </P>

          <li>7.2. Desenvolvimento Móvel Crossplataform</li>
          <p> Agora, vamos explorar o desenvolvimento cross-plataform, ou seja, o desenvolvimento multiplataforma. Esse modelo permite criar um único código que pode ser utilizado em mais de uma plataforma, como iOS e Android.          </p>
          <p> O que é o Desenvolvimento Cross-Plataform? O desenvolvimento cross-plataform refere-se a criar uma base única de código que será utilizada em diferentes sistemas operacionais. Isso contrasta com o desenvolvimento nativo, onde cada plataforma (iOS e Android) exige um código específico. A principal vantagem desse modelo é a economia de tempo e custos, uma vez que você desenvolve apenas uma vez e o código é adaptado para rodar nas diferentes plataformas. </p>
          <p>Por outro lado, como é uma solução genérica que visa atender a múltiplos sistemas, ela pode apresentar limitações em desempenho e acesso a recursos específicos de cada plataforma. Algumas características técnicas podem estar disponíveis apenas no iOS ou no Android, e as ferramentas cross-plataform buscam equilibrar essas diferenças. Assim, o desempenho pode ser bom, mas dificilmente será igual ao de uma aplicação nativa.          </p>
          <p>Ferramentas de Desenvolvimento Cross-Plataform: O Xamarin é uma plataforma de desenvolvimento cross-plataform criada pela Microsoft. Ele utiliza a linguagem C# e permite desenvolver interfaces gráficas e lógicas de negócio compartilhadas entre iOS e Android.  </p>
          <p><strong>  Vantagens do Xamarin:  </strong></p>
          <ul>
            <li>Integração com o ecossistema Microsoft (.NET): A ferramenta oferece suporte completo ao ambiente Microsoft, proporcionando confiabilidade e boas práticas.</li>
            <li>Código compartilhado: A lógica de negócio pode ser compartilhada entre as plataformas, evitando duplicação de código.  </li>
            <li>Acesso às APIs nativas: O Xamarin utiliza associações para acessar APIs específicas de cada plataforma, garantindo uma experiência próxima ao nativo.  </li>
            <li>Desempenho: Apesar de não ser totalmente nativo, o código é compilado para o ambiente específico (iOS ou Android), garantindo um desempenho próximo ao esperado.  </li>
          </ul>
          <p><strong> Limitações do Xamarin:   </strong></p>
          <ul>
            <li> Tamanho dos aplicativos: Aplicativos desenvolvidos com Xamarin podem ser maiores em comparação aos nativos, devido às bibliotecas adicionais incluídas no pacote. </li>
            <li> Ecossistema menor: A base de bibliotecas e ferramentas é limitada ao ambiente Microsoft. </li>
            <li> Complementação de código: Em alguns casos, é necessário adicionar trechos específicos para cada plataforma, caso haja funcionalidades exclusivas que não podem ser compartilhadas.   </li>
          </ul>
          <p>Kotlin Multiplatform (KMM): Outra ferramenta interessante é o Kotlin Multiplatform, uma solução multiplataforma da JetBrains baseada em Java. Essa ferramenta permite desenvolver um único código que pode ser compilado para diversas plataformas, incluindo dispositivos móveis, desktops e até dispositivos IoT, como relógios e geladeiras.          </p>
          <p><strong> Vantagens do Kotlin Multiplatform:   </strong></p>
          <ul>
            <li>Código único: Assim como no Xamarin, a lógica de negócio pode ser compartilhada entre plataformas.            </li>
            <li>Simulador integrado: Permite testar aplicativos em diferentes dispositivos e resoluções, sem a necessidade de hardware específico (como um dispositivo físico da Apple para testar iOS).             </li>
            <li> Portabilidade: A portabilidade do Kotlin permite que o código seja executado em diversas plataformas, além de facilitar o desenvolvimento com APIs nativas.   </li>
          </ul>
          <p><strong>  Limitações do Kotlin Multiplatform:  </strong></p>
          <ul>
            <li>Complexidade de aprendizado: Para quem não tem experiência com Java ou Kotlin, pode haver uma curva de aprendizado mais acentuada.            </li>
            <li> Desempenho: Embora o desempenho seja bom, ele não atinge o nível de um aplicativo totalmente nativo. </li>
            <li> Licenciamento: Alguns recursos avançados podem exigir o pagamento de licenças, enquanto a versão gratuita é limitada a projetos menores.  </li>
          </ul>
          <p>Conclusão: Tanto o Xamarin quanto o Kotlin Multiplatform são ótimas opções para o desenvolvimento cross-plataform. O Xamarin é mais indicado para desenvolvedores com experiência no ecossistema .NET, enquanto o Kotlin Multiplatform oferece maior flexibilidade para quem busca uma solução que abranja diversas plataformas além de iOS e Android.          </p>
          <p>Ambas as ferramentas oferecem desempenho próximo ao nativo, mas não chegam a superar o desenvolvimento nativo em termos de performance e acesso completo aos recursos da plataforma. A escolha entre elas dependerá do contexto do projeto, das necessidades específicas e da experiência da equipe de desenvolvimento.           </p>


          <li>7.3. Desenvolvimento Móvel Híbrido</li>
          <p>Vamos dar sequência à nossa disciplina Princípios de Arquitetura de Software da Atualidade. Estamos no Capítulo 7, falando sobre as diferentes formas de desenvolvimento móvel, também conhecido como desenvolvimento mobile. </p>
          <p>Já abordamos o desenvolvimento nativo e o desenvolvimento cross-platform, e nesta aula entraremos no conceito de desenvolvimento híbrido.</p>
          <p>O que é o Desenvolvimento Híbrido? De forma geral, o desenvolvimento híbrido utiliza conceitos de desenvolvimento web para criar aplicações que podem ser executadas em diversas plataformas. Enquanto os aplicativos nativos são desenvolvidos com bibliotecas específicas para cada sistema operacional, e o cross-platform permite o desenvolvimento de um único código para ser adaptado a diferentes plataformas, o desenvolvimento híbrido vai além. Ele utiliza tecnologias web para criar aplicativos que podem rodar em Android, iOS, e até mesmo em navegadores e desktops.          </p>
          <p>Por exemplo, no modelo híbrido, você cria uma aplicação web que é exibida como se fosse um aplicativo nativo no dispositivo móvel. Isso reduz custos de desenvolvimento, pois é um processo mais rápido e simples, mas tem limitações quando se trata de aplicativos que exigem alta performance, interfaces gráficas complexas, ou acesso intenso a recursos nativos dos dispositivos.           </p>
          <p>Ferramentas de Desenvolvimento Híbrido: Flutter e React Native, Nesta aula, exploraremos duas ferramentas amplamente utilizadas no desenvolvimento híbrido: o Flutter e o React Native. Vamos falar sobre suas características, vantagens e quando optar por cada uma.  </p>
          <p><strong>  Flutter  </strong></p>
          <p> O Flutter é um framework desenvolvido pelo Google e utiliza a linguagem Dart. Algumas características e vantagens: </p>
          <ul>
            <li> Linguagem Dart: Para usar o Flutter, é necessário conhecimento em Dart, o que pode ser uma barreira para quem não conhece essa linguagem. </li>
            <li>Interface gráfica rica e declarativa: O Flutter oferece uma biblioteca vasta para criar interfaces gráficas modernas e responsivas de forma rápida e eficiente. </li>
            <li>Compilação para código nativo: Apesar de ser um framework híbrido, o Flutter realiza a compilação para código nativo, garantindo um desempenho muito próximo ao de aplicativos nativos. </li>
            <li>Facilidade no desenvolvimento: Por ser um framework com muitas funcionalidades prontas, ele acelera o desenvolvimento, especialmente para aplicações que não demandam uso intenso de recursos gráficos. </li>
            <li>Para utilizar o Flutter, é necessário instalar o SDK e configurar uma IDE compatível.  </li>
          </ul>
          <p><strong>  React Native  </strong></p>
          <p>O React Native é um framework desenvolvido pelo Facebook que utiliza a linguagem JavaScript. Algumas características e vantagens:</p>
          <ul>
            <li>Linguagem JavaScript: Diferentemente do Flutter, que exige o aprendizado de Dart, o React Native utiliza JavaScript, uma linguagem amplamente conhecida, facilitando a curva de aprendizado.            </li>
            <li>Componentes reutilizáveis: Permite a reutilização de componentes do React para o desenvolvimento móvel, o que acelera o processo de criação de aplicativos.            </li>
            <li> Ambiente de desenvolvimento: Pode ser configurado usando ferramentas como o Expo, que simplifica o desenvolvimento e oferece um ambiente visual mais acessível.            </li>
            <li> Desempenho satisfatório: Embora o React Native não tenha o mesmo nível de desempenho que o Flutter em aplicações mais pesadas, ele é suficientemente eficiente para a maioria das aplicações híbridas.  </li>
          </ul>
          <p><strong> Comparação entre Flutter e React Native   </strong></p>
          <p>Ao comparar as duas ferramentas, não há uma solução universalmente "melhor". A escolha depende do contexto e dos requisitos do projeto.</p>
          <ul>
            <li> Linguagem de programação: O Flutter utiliza Dart, uma linguagem menos difundida, enquanto o React Native usa JavaScript, que tem maior adesão e comunidade de desenvolvedores.            </li>
            <li>Interface gráfica: O Flutter oferece uma biblioteca rica e personalizável, sendo uma boa escolha para aplicativos que demandam interfaces elaboradas.            </li>
            <li>Curva de aprendizado: O React Native tem uma curva de aprendizado mais rápida devido ao uso de JavaScript e à popularidade da linguagem.            </li>
            <li>Desempenho: O Flutter, com sua compilação para código nativo, oferece um desempenho ligeiramente superior em aplicações que exigem mais processamento. Já o React Native compensa com flexibilidade e facilidade de uso.             </li>
          </ul>
          <p><strong>  Tendências no Desenvolvimento Híbrido  </strong></p>
          <ul>
            <li> Flutter: O número de usuários e desenvolvedores que utilizam o Flutter tem crescido significativamente, o que contribui para o aumento de funcionalidades e melhorias no framework.            </li>
            <li> React Native: O uso do Expo tem facilitado ainda mais o desenvolvimento com React Native, tornando o processo mais intuitivo e eficiente.  </li>
            <li> Os frameworks híbridos estão cada vez mais eficientes e resolvendo problemas com soluções de custo-benefício atraente, especialmente para projetos menos complexos. </li>
          </ul>


        </ul>
      </div>
      
      <div id="modulo-4-capitulo-8" class="capitulo">
        <p><strong>Capítulo 8 – Arquiteturas Cloud Native e Serverless</strong></p>
        <ul>
          <li>8.1. Introdução às Arquiteturas Cloud Native</li>
          <p>Arquiteturas cloud-native são aquelas projetadas, desde o início, para operar em ambientes de nuvem. Diferentemente de aplicações que foram criadas para rodar em servidores locais e posteriormente migradas para a nuvem, as aplicações cloud-native já são concebidas com componentes preparados para aproveitar ao máximo os recursos oferecidos por provedores de nuvem. Isso inclui escalabilidade, resiliência, agilidade no desenvolvimento e facilidade de provisionamento.          </p>
          <p>As principais características desse tipo de arquitetura são a escalabilidade dinâmica e a flexibilidade. Por exemplo, em momentos de alta demanda, como na Black Friday, a infraestrutura pode ser automaticamente ajustada para atender ao aumento no número de solicitações. Quando a demanda diminui, os recursos são desprovisionados, otimizando custos.          </p>
 
          <p><strong>Componentes Fundamentais das Arquiteturas Cloud-Native    </strong></p>
          <ul>
            <li>Contêineres: Os contêineres encapsulam a aplicação e suas dependências em um único pacote, o que facilita a replicação e o provisionamento em diferentes ambientes. Diferentemente de máquinas virtuais, os contêineres compartilham o mesmo sistema operacional, o que os torna mais leves e eficientes. Ferramentas como Docker permitem criar e gerenciar contêineres de forma prática.            </li>
            <li>Orquestração: A orquestração, realizada por ferramentas como Kubernetes, gerencia o ciclo de vida dos contêineres. Ela permite provisionar, escalar, atualizar e desprovisionar recursos de forma automática, garantindo que a infraestrutura acompanhe as demandas de uso.            </li>
            <li>Microserviços: A arquitetura de microserviços divide uma aplicação em pequenos serviços independentes. Isso facilita a manutenção, a escalabilidade e o desenvolvimento incremental. Cada microserviço pode ser implementado, testado e escalado separadamente. </li>
          </ul>
          <p><strong>Benefícios :    </strong></p>
          <ul>
            <li>Escalabilidade:  Possibilidade de escalar verticalmente (aumentando os recursos de uma única instância) ou horizontalmente (adicionando novas instâncias).
            <li>Resiliência: Capacidade de recuperação automática em caso de falhas. </li>
            <li>Flexibilidade: Infraestrutura adaptável às mudanças de demanda. </li>
            <li>Agilidade: Entregas contínuas (CI/CD) tornam o desenvolvimento mais rápido e eficiente. </li>
            <li>Otimização de custos: Pagamento baseado no uso, o que reduz gastos desnecessários. </li>
          </ul>
          <p><strong>  Desafios e Considerações  </strong></p>
          <ul>
            <li>Gerenciamento de custos: Se os recursos não forem desprovisionados adequadamente, os custos podem aumentar. </li>
            <li> Complexidade: A gestão de uma infraestrutura dinâmica exige conhecimento técnico e ferramentas apropriadas.            </li>
            <li> Segurança: É essencial implementar boas práticas de segurança para proteger dados e garantir conformidade com regulamentações locais e internacionais.            </li>
          </ul>
          <p><strong>  Ferramentas e Tecnologias  </strong></p>
          <ul>
            <li> Docker: Gerenciamento de contêineres.            </li>
            <li> Kubernetes: Orquestração de contêineres.  </li>
            <li> Terraform: Automação do provisionamento de infraestrutura. </li>
            <li> CI/CD: Integração e entrega contínuas para atualizações rápidas e seguras. </li>
          </ul>
          <p><strong>  Exemplos de Uso  </strong></p>
          <ul>
            <li>Aplicações Web: Ambientes de grande variação de acesso. </li>
            <li>Processamento de Dados: Execução de cargas intensivas de forma escalável. </li>
            <li>Gerenciamento de Dispositivos IoT: Escalabilidade para lidar com o aumento de dispositivos conectados. </li>
          </ul>
          <p>Conclusão: As arquiteturas cloud-native são projetadas para maximizar as vantagens oferecidas pela nuvem, como flexibilidade, escalabilidade e resiliência. No entanto, exigem planejamento cuidadoso para otimizar custos, gerenciar a segurança e acompanhar a evolução das demandas ao longo do tempo.  </p>
          <li>8.2. Introdução às Arquiteturas Serverless</li>
          <p>Vamos falar um pouco mais sobre arquiteturas serverless, um tema muito importante quando discutimos arquiteturas atuais e tendências futuras. Nesta aula, abordaremos os conceitos de arquiteturas serverless, os componentes necessários, as vantagens de utilizá-las e os casos típicos de aplicação. </p>
          <p>Primeiramente, é importante entender o conceito. Quando falamos em "serverless", na prática, isso não significa "sem servidor". O servidor existe, mas não é de responsabilidade do dono da aplicação. Ele é gerenciado por um terceiro, e o desenvolvedor não precisa se preocupar com essa infraestrutura.</p>
          <p><strong>   Evolução das Arquiteturas </strong></p>
          <p>Ao longo do tempo, as arquiteturas de software passaram por várias transformações:</p>
          <ul>
            <li>Arquiteturas Monolíticas: O software era desenvolvido de forma centralizada, em um único sistema.            </li>
            <li>Arquiteturas Orientadas a Serviços: Surgiu a ideia de modularizar e distribuir o processamento pela rede, evitando sobrecarregar um único servidor.            </li>
            <li> Microserviços: Com o tempo, os serviços foram fragmentados em unidades menores, chamadas microserviços, que podem ser gerenciadas e executadas de forma independente.            </li>
            <li>Arquiteturas Serverless: A evolução seguinte foi a fragmentação de microserviços em funções específicas que podem ser executadas sob demanda por um provedor externo.            </li>
          </ul>
          <p>O conceito de serverless é simples: imagine que você tem uma função específica no seu código que é executada milhares de vezes por dia, como um cálculo matemático. Em vez de sobrecarregar o seu servidor para realizar essa função, você a delega a um provedor externo, que realiza o processamento e retorna o resultado. Isso permite que você foque no desenvolvimento da lógica da sua aplicação, sem se preocupar com a infraestrutura ou com a escalabilidade.          </p>
          <p><strong>  Características Principais do Serverless  </strong></p>
          <ul>
            <li> Gerenciamento terceirizado: Toda a infraestrutura, incluindo escalabilidade e manutenção, é responsabilidade do provedor.             </li>
            <li> Pagamento por uso: Você só paga pelas funções executadas, sem a necessidade de manter servidores provisionados continuamente.             </li>
            <li> Desempenho otimizado: Recursos são alocados dinamicamente, e o provedor garante que a demanda seja atendida.            </li>
          </ul>
          <p><strong>  Características Principais do Serverless  </strong></p>
          <ul>
            <li>Gerenciamento terceirizado: Toda a infraestrutura, incluindo escalabilidade e manutenção, é responsabilidade do provedor.            </li>
            <li>Pagamento por uso: Você só paga pelas funções executadas, sem a necessidade de manter servidores provisionados continuamente.            </li>
            <li>Desempenho otimizado: Recursos são alocados dinamicamente, e o provedor garante que a demanda seja atendida.            </li>
          </ul>
          <p><strong>  Modelos de Implementação  </strong></p>
          <p>Existem dois modelos principais em arquiteturas serverless:</p>
          <ul>
            <li> Functions as a Service (FaaS): Funções individuais são executadas sob demanda. Exemplos incluem AWS Lambda, Google Cloud Functions e Azure Functions.             </li>
            <li> Backend as a Service (BaaS): Serviços de backend, como autenticação, banco de dados ou armazenamento, são disponibilizados como serviços gerenciados. Você pode utilizar soluções de provedores para evitar provisionar servidores dedicados. </li>
          </ul>
          <p><strong>   Benefícios </strong></p>
          <ul>
            <li> Escalabilidade automática: A infraestrutura se ajusta automaticamente à demanda. </li>
            <li> Redução de custos: Você paga apenas pelo uso, sem custos fixos de servidores ociosos. </li>
            <li> Foco na lógica da aplicação: Não é necessário gerenciar hardware ou dimensionar infraestrutura. </li>
          </ul>
          <p><strong>  Desafios  </strong></p>
          <ul>
            <li> Latência inicial (Cold Start): As primeiras execuções de funções após períodos de inatividade podem ser mais lentas. </li>
            <li>  Limitações de execução: Algumas plataformas impõem limites de tempo (geralmente entre 5 e 30 minutos por execução). </li>
            <li> Gerenciamento de estado: Como os dados não são mantidos no servidor, o controle do estado precisa ser feito pelo cliente.  </li>
          </ul>
          <p><strong>  Casos de Uso  </strong></p>
          <ul>
            <li> Automação de processos: Ideal para processos repetitivos e pré-determinados. </li>
            <li> APIs e microserviços ágeis: Facilita o desenvolvimento de APIs e a escalabilidade. </li>
            <li> Mensageria e eventos: Respostas a mudanças de estado em sistemas. </li>
            <li> Processamento pontual: Execução de cálculos ou tarefas específicas sob demanda. </li>
          </ul>
          <p><strong>  Tendências Futuras  </strong></p>
          <ul>
            <li> Integração com contêineres: Combinar serverless com contêineres para criar arquiteturas ainda mais flexíveis.            </li>
            <li> Serverless de longo prazo: Suporte a funções mais complexas e com tempos de execução maiores, fragmentando tarefas em etapas menores. </li>
          </ul>
        </ul>
      </div>
      
      <div id="modulo-4-capitulo-9" class="capitulo">
        <p><strong>Capítulo 9 – Introdução às FaaS (AWS Lambda e Azure Functions)</strong></p>
        <p>Neste capítulo 9, vamos nos aprofundar no conceito de funções FaaS (Function as a Service), trazendo um pouco da realidade da Amazon, da Microsoft e da ESA sobre como trabalhar com esses conceitos. Antes de entrar especificamente nas plataformas dos grandes provedores, faremos uma breve introdução ao conceito de funções FaaS.</p>
        <ul>
          <li>9.1. Funções como Serviço</li>
          <p>Quando falamos em FaaS, estamos basicamente nos referindo ao uso da computação em nuvem para executar partes do código sem a necessidade de gerenciar toda a infraestrutura por trás. Nesse modelo, você deixa o código hospedado em um provedor de serviço. Sempre que precisar que esse código seja executado, você paga apenas pelo uso. Trata-se de um conceito que visa fragmentar ainda mais o código e distribuí-lo ao longo da rede de forma eficiente.          </p>
          <p> Objetivo do Modelo: O principal objetivo desse modelo é permitir que o código esteja hospedado em um servidor de terceiros, sem a necessidade de provisionar um container ou uma máquina dedicada. O provedor de serviço gerencia toda a infraestrutura. Esse ambiente pode abrigar códigos de diversos clientes, sendo ativados apenas quando ocorre uma solicitação específica. </p>
          <p>A ideia central é criar uma estrutura na qual um evento dispara a execução de uma função. Assim, você consegue executar o código em resposta a um evento sem se preocupar com o provisionamento ou a manutenção da infraestrutura.           </p>
          <p><strong> Características do FaaS   </strong></p>
          <ul>
            <li> Escalabilidade automática: O sistema escala automaticamente conforme a demanda. Não é necessário reservar previamente capacidade para atender a picos de utilização.            </li>
            <li> Pagamento por uso: Você paga apenas pelo tempo de execução do código, tornando o custo mais eficiente.            </li>
            <li> Despreocupação com infraestrutura: Toda a gestão da infraestrutura é realizada pelo provedor.            </li>
            <li> Limitações: Os provedores podem impor restrições, como o número de solicitações por hora ou a quantidade máxima de memória disponível por função. </li>
          </ul>

          <p><strong>Funcionamento das Funções    </strong></p>
          <p>O desenvolvimento em FaaS segue um modelo no qual o código é escrito em pequenas funções independentes. Essas funções podem ser acionadas por eventos, como:          </p>
          <ul>
            <li> Mudanças de estado em aplicações. </li>
            <li> Disparos manuais ou automáticos, como alterações de temperatura em dispositivos IoT. </li>
            <li> O código é executado em um ambiente isolado, gerenciado por um provedor de nuvem, permitindo flexibilidade e dinamismo. </li>
          </ul>
          <p><strong>  Vantagens  </strong></p>
          <ul>
            <li> Escalabilidade e flexibilidade: O sistema se adapta automaticamente ao volume de requisições. </li>
            <li> Custo reduzido: Você paga apenas pelo uso efetivo. </li>
            <li> Foco na lógica de negócios: O desenvolvedor pode concentrar esforços na aplicação, sem precisar gerenciar infraestrutura. </li>
          </ul>
          <p><strong>  Desafios  </strong></p>
          <ul>
            <li>Financeiros: É necessário pensar em custos ao longo do tempo, considerando a oscilação da demanda e o modelo de cobrança por uso. </li>
            <li> Limitações de recursos: Provedores impõem restrições que podem não atender a demandas específicas, como execuções contínuas ou muito complexas. Nesse caso, arquiteturas tradicionais podem ser mais apropriadas.            </li>
          </ul>
          <p><strong> Tendências e Futuro do FaaS   </strong></p>
          <ul>
            <li> Assim como o Docker e o Kubernetes surgiram para orquestrar microserviços, no futuro, veremos ferramentas para integrar funções de diferentes provedores em fluxos lógicos. No entanto, funções muito longas ou complexas podem exigir estratégias específicas, como fragmentação em funções menores.            </li>
            <li> Outra tendência é a integração entre FaaS e outras tecnologias, como containers, para aproveitar ao máximo as vantagens de cada abordagem.            </li>
          </ul>
          </br>

          <li>9.2. Princípios gerais de FaaS na Azure</li>
          <li>9.3. Princípios gerais de FaaS na AWS</li>
        </ul>
      </div>
      
      <div id="modulo-4-capitulo-10" class="capitulo">
        <p><strong>Capítulo 10 – Demonstração Prática da Arquitetura FaaS</strong></p>
      </div>
      

    </div>
    



  </div>
</body>
</html>
